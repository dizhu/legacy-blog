<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>代码混音师</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://coderemixer.com/"/>
  <updated>2020-01-14T07:51:04.555Z</updated>
  <id>https://coderemixer.com/</id>
  
  <author>
    <name>CodeRemixer</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>元胞自动机 101 —— 13 Architypes: Humanist</title>
    <link href="https://coderemixer.com/2020/01/14/archetypes-humanity/"/>
    <id>https://coderemixer.com/2020/01/14/archetypes-humanity/</id>
    <published>2020-01-14T05:22:47.000Z</published>
    <updated>2020-01-14T07:51:04.555Z</updated>
    
    <content type="html"><![CDATA[<h2 id="序"><a href="#序" class="headerlink" title="序"></a>序</h2><p>前一晚改论文改睡着了，结果错过了。早上醒来发现题目还挺简单的，来聊一聊谜题的出题思路吧。</p><p><img src="https://storage.googleapis.com/ingress-internal-event-data/13archetypes/humanist/humanist2_a6f9854f-6e0c-5050-a10d-91f4aaa4c382.png" alt="题目"></p><h2 id="一种新科学"><a href="#一种新科学" class="headerlink" title="一种新科学"></a>一种新科学</h2><p>元胞自动机是一种由元胞、元胞状态、领域、和状态更新规则构成的一个自动机，其数学表达为：</p><p>$$ A = (L, d, S, N, f) $$</p><p>换成人话就是说，对于一个 d 维度的有限状态矩阵，每次每个格点的状态更新取决于其上一次中周围格点的状态。元胞自动机是研究混沌现象的一个重要模型，在 Wolfram 出版的书籍《一种新科学》（我个人对这是不是一种新科学持保留态度）中被进行了非常深入的探讨。</p><p>Wolfram 把初等一维元胞自动机的全部 256 种规则进行了分类，分成了四类：平稳型、周期型、混沌型、复杂型。</p><ul><li>平稳型就是无论初始局面如何，最后终会变成稳定均匀状态。</li><li>周期性则是无论初始局面如何，最终会变成稳定的震荡结构，随机性会被过滤。</li><li>混沌型指初始局面会演化成一个伪随机或混沌状状态。</li><li>复杂型则是上面的一系列组合，可能会出现混沌，而一部分的初始结构会稳定保留，结构于结构会相互作用。（比如像规则 110 被证明是图灵完备的，那么其局面自然会随着初始输入变化有很大变化，可能稳定可能混沌了。）</li></ul><p>但这个分类有个很大的问题，就是每一个类别几乎都能找到例外。所以这到底是一种新科学还是一种伪科学还是有点迷幻的。</p><h2 id="最有名的元胞自动机"><a href="#最有名的元胞自动机" class="headerlink" title="最有名的元胞自动机"></a>最有名的元胞自动机</h2><p>最有名的元胞自动机是 1970 年由英国数学家约翰·何顿·康威提出的康威生命游戏（Conway’s Game of Life）其规则如下：</p><ul><li>元胞自动机的维度是 2（运行在 2 维平面上）</li><li>状态只有两种，存活和死亡</li><li>当周围存活元胞是 0 个或 1 个时，其会死亡（太孤独了，无聊死了）</li><li>当周围存活元胞是 2 个或 3 个时，保持原样</li><li>当周围存活元胞是 4 个时，该元胞死亡（没饭吃饿死了）</li><li>当周围存活元胞是 3 个，且当前元胞是死亡状态时，该元胞变成存活（模拟繁殖）</li></ul><p>这个游戏按 Wolfram 的分类应该是第四种复杂型。而我们的这个谜题，就是把图输入到这种自动机里，然后跑一下就结束了。</p><h2 id="怎么解题"><a href="#怎么解题" class="headerlink" title="怎么解题"></a>怎么解题</h2><p>模拟它应该是要写个程序的，毕竟手推太麻烦了。Game of Life 的实现大概满世界都是吧。打开 <a href="https://leetcode.com/problems/game-of-life/solution/" target="_blank" rel="noopener">LeetCode</a> 的题解抄下来稍微改改就有了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> collections</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gameOfLifeInfinite</span><span class="params">(live)</span>:</span></span><br><span class="line">  ctr = collections.Counter((I, J)</span><br><span class="line">                            <span class="keyword">for</span> i, j <span class="keyword">in</span> live</span><br><span class="line">                            <span class="keyword">for</span> I <span class="keyword">in</span> range(i<span class="number">-1</span>, i+<span class="number">2</span>)</span><br><span class="line">                            <span class="keyword">for</span> J <span class="keyword">in</span> range(j<span class="number">-1</span>, j+<span class="number">2</span>)</span><br><span class="line">                            <span class="keyword">if</span> I != i <span class="keyword">or</span> J != j)</span><br><span class="line">  <span class="keyword">return</span> &#123;ij</span><br><span class="line">    <span class="keyword">for</span> ij <span class="keyword">in</span> ctr</span><br><span class="line">    <span class="keyword">if</span> ctr[ij] == <span class="number">3</span> <span class="keyword">or</span> ctr[ij] == <span class="number">2</span> <span class="keyword">and</span> ij <span class="keyword">in</span> live&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gameOfLife</span><span class="params">(board)</span>:</span></span><br><span class="line">  live = &#123;(i, j) <span class="keyword">for</span> i, row <span class="keyword">in</span> enumerate(board) <span class="keyword">for</span> j, live <span class="keyword">in</span> enumerate(row) <span class="keyword">if</span> live&#125;</span><br><span class="line">  live = gameOfLifeInfinite(live)</span><br><span class="line">  <span class="keyword">for</span> i, row <span class="keyword">in</span> enumerate(board):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(len(row)):</span><br><span class="line">      row[j] = int((i, j) <span class="keyword">in</span> live)</span><br><span class="line"></span><br><span class="line">board = [[<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>],[<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>],[<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>],[<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>]]</span><br><span class="line">gameOfLife(board)</span><br><span class="line">print(board)</span><br></pre></td></tr></table></figure><p>比较恶心的是，我们怎么去把图片转换成矩阵。据说大多数人都是手弄的。我觉得有点过分了，毕竟也是一个 27 x 27 的超大矩阵，手抄一抄得抄 729 个数字。咱这也不是庙会的抄数字赢钱的摊，咱还是找个自动化的方法来处理吧。</p><p>我们先裁切一下图片，减少一下代码量，变成：</p><p><img src="/static/game-of-life-ingress.png" alt="裁切后图像"></p><p>然后我们写点 OpenCV 的代码来做图像处理和转换，简单来说就是二值化，然后压缩成 27x27（因为像素冗余有够大，直接压大概不会被边框影响到），然后直接除以 255 变成 01 矩阵，跑完打印出来。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> collections</span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gameOfLifeInfinite</span><span class="params">(live)</span>:</span></span><br><span class="line">  ctr = collections.Counter((I, J)</span><br><span class="line">                            <span class="keyword">for</span> i, j <span class="keyword">in</span> live</span><br><span class="line">                            <span class="keyword">for</span> I <span class="keyword">in</span> range(i<span class="number">-1</span>, i+<span class="number">2</span>)</span><br><span class="line">                            <span class="keyword">for</span> J <span class="keyword">in</span> range(j<span class="number">-1</span>, j+<span class="number">2</span>)</span><br><span class="line">                            <span class="keyword">if</span> I != i <span class="keyword">or</span> J != j)</span><br><span class="line">  <span class="keyword">return</span> &#123;ij</span><br><span class="line">    <span class="keyword">for</span> ij <span class="keyword">in</span> ctr</span><br><span class="line">    <span class="keyword">if</span> ctr[ij] == <span class="number">3</span> <span class="keyword">or</span> ctr[ij] == <span class="number">2</span> <span class="keyword">and</span> ij <span class="keyword">in</span> live&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gameOfLife</span><span class="params">(board)</span>:</span></span><br><span class="line">  live = &#123;(i, j) <span class="keyword">for</span> i, row <span class="keyword">in</span> enumerate(board) <span class="keyword">for</span> j, live <span class="keyword">in</span> enumerate(row) <span class="keyword">if</span> live&#125;</span><br><span class="line">  live = gameOfLifeInfinite(live)</span><br><span class="line">  <span class="keyword">for</span> i, row <span class="keyword">in</span> enumerate(board):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(len(row)):</span><br><span class="line">      row[j] = int((i, j) <span class="keyword">in</span> live)</span><br><span class="line"></span><br><span class="line">img = cv2.imread(<span class="string">'/Users/delton/Desktop/game-of-life-ingress.png'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Convert RGB to Binary Image</span></span><br><span class="line">ret, bw_img = cv2.threshold(img, <span class="number">127</span>, <span class="number">255</span>, cv2.THRESH_BINARY)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Convert to 27x27</span></span><br><span class="line"><span class="comment"># 反正像素冗余那么大，直接转换多半不会出问题</span></span><br><span class="line">resized_image = cv2.resize(bw_img, (<span class="number">27</span>, <span class="number">27</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># Pick Channel 0 only</span></span><br><span class="line">board = resized_image[:, :, <span class="number">0</span>] / <span class="number">255</span></span><br><span class="line">gameOfLife(board)</span><br><span class="line">print(board)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Revert Black and White</span></span><br><span class="line">cv2.imshow(<span class="string">"Result"</span>, <span class="number">1.0</span> - board)</span><br><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br><span class="line">cv2.destroyAllWindows()</span><br></pre></td></tr></table></figure><p>结果：</p><p><img src="/static/humanity-result.png" alt="解码结果"></p><p>扫码：</p><p><img src="/static/humanity-scan.jpg" alt="扫码结果"></p><p>结束。</p><h2 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h2><ul><li><p><a href="https://youtu.be/GQNREcMVPHY" target="_blank" rel="noopener">生命游戏：另一种计算机 —— 混乱博物馆</a></p></li><li><p><a href="https://www.youtube.com/watch?v=2lfVFOXzonY" target="_blank" rel="noopener">混沌与分形 —— MommyTalk</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;序&quot;&gt;&lt;a href=&quot;#序&quot; class=&quot;headerlink&quot; title=&quot;序&quot;&gt;&lt;/a&gt;序&lt;/h2&gt;&lt;p&gt;前一晚改论文改睡着了，结果错过了。早上醒来发现题目还挺简单的，来聊一聊谜题的出题思路吧。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://stor
      
    
    </summary>
    
    
      <category term="元胞自动机" scheme="https://coderemixer.com/tags/%E5%85%83%E8%83%9E%E8%87%AA%E5%8A%A8%E6%9C%BA/"/>
    
      <category term="混沌" scheme="https://coderemixer.com/tags/%E6%B7%B7%E6%B2%8C/"/>
    
      <category term="游戏" scheme="https://coderemixer.com/tags/%E6%B8%B8%E6%88%8F/"/>
    
      <category term="设计" scheme="https://coderemixer.com/tags/%E8%AE%BE%E8%AE%A1/"/>
    
      <category term="Ingress" scheme="https://coderemixer.com/tags/Ingress/"/>
    
  </entry>
  
  <entry>
    <title>从 bopomofo 说起 —— 学习注音符号后对拼音系统的一些新体悟</title>
    <link href="https://coderemixer.com/2020/01/10/from-bopomofo/"/>
    <id>https://coderemixer.com/2020/01/10/from-bopomofo/</id>
    <published>2020-01-10T13:06:49.000Z</published>
    <updated>2020-01-10T13:23:43.679Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一些理由"><a href="#一些理由" class="headerlink" title="一些理由"></a>一些理由</h2><p>众所周知，我从小接受的用于标记现代标准汉语的系统是「汉语拼音」。两年前，我决定学习一下「注音符号」。注音符号是以章太炎编创的「纽文」、「韵文」为蓝本，设计的一套汉语拼音方案。其实最早决定去学的原因还是好奇好玩，用一套完全不熟悉的拼读系统来学习自己已经掌握的汉语发音，可以很好从另一个方面来认识汉语的发音系统。最后也证明这样的形式确实帮助我从某种角度重新认识了汉语发音，特别是当这套系统和汉语拼音符号本身产生差异的时候，通过深究差异产生的原因，极大提高了我对汉语发音的理解，可以说是受益良多。下面就来分享一些，我学习过程中遇到的一些有意思的事情。</p><p>先放一个我在 YouTube 上看到的「注音符号歌」，让没有听说过这个系统的人有个大概的印象。</p><iframe width="560" height="315" src="https://www.youtube.com/embed/n0G-cKUkt3c" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe><p>（比较可怕的是这个影片播放完后的推荐影片里都是一些真的不明所以非常奇怪的儿童影片）</p><h2 id="前四个声母"><a href="#前四个声母" class="headerlink" title="前四个声母"></a>前四个声母</h2><p>一个有意思的现象是，虽然「注音符号」的英文叫「Bopomofo Symbols」。但显然，背诵注音符号表的时候，这四个音用的都不是 /o/ 的韵母，而是使用 /ɤ/。「ㄅㄆㄇㄈ」念成 /pɤ/ /pʰɤ/ /mɤ/ /fɤ/。相反，我们在背诵汉语拼音表的时候，倒是真的拼成了 /o/，bo po mo fo /po/ /pʰo/ /mo/ /fo/ 。</p><p>不过突然发现，bo po mo fo 小时候老师教的都是发成闭口呼，也就是 ㄅㄨㄛ buo ㄆㄨㄛ puo ㄇㄨㄛ muo ㄈㄨㄛ fuo。但是无论是查大陆的使用拼音的字典，还是台湾的教育部国语辞典，都不会拼入ㄨ，坚持使用开口呼。而且看一些比较权威的汉语拼音或者注音的教学录音，都是录的开口呼，和学得并不一样。</p><p>查了一下发现，北京音的「波（ㄅㄛ）坡（ㄆㄛ）摸（ㄇㄛ）佛（ㄈㄛ）」一直到新国音还一直开口呼。拼成 bo po mo fo 很好保留了当时的语音。一直到近几十年，才有人开始不区分开口呼和闭口呼，把「菠菜」念成ㄅㄨㄛ ㄘㄞˋ，这不是什么省略 ㄨ (u) 的结果。</p><p>而北京音在晚清到民国早年「多（ㄉㄛ）拖（ㄊㄛ）挪（ㄋㄛ）罗（ㄌㄛ）」虽然也是开口呼，到新国音的时候就已经逐渐转换成闭口呼，也就是 ㄉㄨㄛ ㄊㄨㄛ ㄋㄨㄛ ㄌㄨㄛ，所以汉语拼音也是按 duo tuo nuo luo 拼写。</p><h2 id="e-的奇妙之旅"><a href="#e-的奇妙之旅" class="headerlink" title="e 的奇妙之旅"></a>e 的奇妙之旅</h2><p>另外一个发现就是，汉语拼音里的 e，实际上发的音可太多了，因为注音把所有复合韵母单独设计了符号，所以一下子显得特别明显。整理了一下，至少可以发 /ɤ/ /e/ /ə/ 这三个音，还可能在一些情况下发成 /ɑ/ 或者 /ɐ/ 这种听起来更像 a 的音。在注音符号中，复音韵母使用完全独立的符号，但是在汉语拼音中使用一些单音韵母的符号再进行一些组合，但是复音韵母可能和单音韵母的发音有很大的差异。</p><p>下面给一些例子：</p><p>得 (ㄉㄜˊ, dé) 里的韵母是 /ɤ/</p><p>谁 (ㄕㄟˊ, shéi) 里的韵母是 /ei̯/</p><p>申 (ㄕㄣ, shēn) 里的韵母是 /ən/</p><p>生 (ㄕㄥ, shēng) 里的韵母是 /ɤŋ/</p><p>另外还有个最奇怪的「二」（ㄦˋ, èr），包括我在内的很多人都会念成 /ɐɻ/。我查了下，很多教程上的 IPA 拼音标成了 /ɑɻ/。如果是这么发的话，汉语拼音是不是标成 àr 更好？查了一下，一说是对于是 /ɐɚ/ /ɑɻ/ /ɤɻ/ 还是 /ɚ/ 存在很大争议。20 年代的很多北京话录音中，发得比较接近 /ɚ/ 到 /əɻ/ 中间的感觉，所以这一标记也可能是历史原因产生的。</p><h2 id="尾声"><a href="#尾声" class="headerlink" title="尾声"></a>尾声</h2><p>现代标准汉语是基于北京音设计的，而这里的北京音和现在的北京音还是有很大差异的。要想理解注音符号和汉语拼音的很多特点，确实需要了解那个时空北京下的北京音。我在写这个文章的时候，发现了一个非常有意思的系列视频，最后推荐大家看一看。里面对很多细节的描述也非常清晰，我甚至是看了这个影片后才发现，现代标准汉语里的「你」「娘」「牛」韵母是 /n/ 而不是硬腭化的 /ɲ/ 或者 /ȵ/，给我念错几十年的人生带来了极大的震撼。</p><iframe src="//player.bilibili.com/player.html?aid=62002848&cid=137623039&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe><p><a href="https://www.bilibili.com/video/av62002848/" target="_blank" rel="noopener">影片地址</a></p><p>对于文字不能直接反映读音的语言来说，通常都会引入一个标注发音的方案，从美语的 KK 音标，现代标准汉语的注音、拼音、威妥玛，以及很多方言的像是闽拼、台罗、教罗、上海话钱乃荣方案、耶鲁粤拼、香港教育学院粤拼等一大堆拼音方案。很多方案直接的标注都是互相冲突的，有的时候看到这堆拉丁字母，真的不知道到底要怎么读。但每个方案都有自己设计的时空背景、设计的动机，通过了解这些不同方案设计的背景和动机，可以从不同的角度重新认识语言，让自己对于语音的理解提升更高的层次。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一些理由&quot;&gt;&lt;a href=&quot;#一些理由&quot; class=&quot;headerlink&quot; title=&quot;一些理由&quot;&gt;&lt;/a&gt;一些理由&lt;/h2&gt;&lt;p&gt;众所周知，我从小接受的用于标记现代标准汉语的系统是「汉语拼音」。两年前，我决定学习一下「注音符号」。注音符号是以章太炎编创的
      
    
    </summary>
    
    
      <category term="语言学" scheme="https://coderemixer.com/tags/%E8%AF%AD%E8%A8%80%E5%AD%A6/"/>
    
      <category term="汉语" scheme="https://coderemixer.com/tags/%E6%B1%89%E8%AF%AD/"/>
    
      <category term="官话" scheme="https://coderemixer.com/tags/%E5%AE%98%E8%AF%9D/"/>
    
  </entry>
  
  <entry>
    <title>大猩猩的乐谱有多少错误？—— 13 Archetypes: Listener 解谜翻船记</title>
    <link href="https://coderemixer.com/2020/01/07/archetypes-listener/"/>
    <id>https://coderemixer.com/2020/01/07/archetypes-listener/</id>
    <published>2020-01-07T05:01:14.000Z</published>
    <updated>2020-01-07T05:06:19.978Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>北京时间 2019 年 1 月 6 日夜间开始了 13 Archetypes 解谜的 Listener 篇。游戏一开始还因为文件名里有 Mfb（某脏话的缩写），导致线索没有如期发布。在一番折腾后，终于看到了这次的谜面，一份乐谱。</p><p><img src="/static/archetypes-listener.png" alt="乐谱"></p><p>这次的解法有多狗血暂且不论，这里就来谈谈这简简单单 9 个小节的乐谱犯了多少个错误，以及这些错误是如何把我带进沟里的。</p><h2 id="拍子怎么数？"><a href="#拍子怎么数？" class="headerlink" title="拍子怎么数？"></a>拍子怎么数？</h2><p>五线谱中，我们会看到音符和音符中间会有纵线相隔，这些纵线叫作「小节线」，两条小节线之间叫作「小节」。通常而言，每个小节的节拍数量是固定的。一般在乐谱的开始，或者要变换节拍的时候在小节的一开始写上一个分数，表示之后小节的节拍，这个分数叫作「拍号」。分母表示小节以几分音符为一拍，而分子表示每小节为一拍。比如流行音乐常见的 $ \frac{4}{4} $ 拍，指的就是以四分音符为一拍，一个小节放 4 个四分音符。</p><p>猩猩的这份谱子是 $\frac{2}{4}$ 拍的，也就是说，以四分音符为一拍，一个小节放 2 个四分音符。就算乐谱的开始和结束的节拍数可以有一定例外，那么聪明的你告诉我，高音部的第 4、6、8 小节，低音部的第 2、5、7、8 小节都是一些什么妖魔鬼怪。</p><p>站在事后诸葛亮的角度，我们知道要把两个部的音符直接合在一起看就能产生一个 20 个字符的序列，但问题是，按照这样的写法，这几个小节谁写在前谁写在后是完全不能判断的，除非完全根据图像上的前后关系来写，这对于乐谱来说完全是莫名其妙的。</p><h2 id="十二平均律与调"><a href="#十二平均律与调" class="headerlink" title="十二平均律与调"></a>十二平均律与调</h2><p>钢琴的调律法称为十二平均律。也就是说从一个 C 到下一个八度里的 C 之间隔了 12 个音。音和音之间的频率的倍率是 $\sqrt[12]{\frac{1}{2}}$。我们熟悉的 do re mi fa sol la si 这 7 个音会以某种形式落在 12 个音上，而这种落上去的方法叫作「调」。猩猩的这份乐谱在一开始没有标记任何升降记号，按自然音阶理解就是所谓的 C 大调或者 a 小调，我们以 C 大调为例（a 小调同理）组成音是 C D E F G A B，do 对应 C。没有出现在这 7 个音里的其它音需要用升降记号标记，比如 C# (Db), D# (Eb) 等。</p><p>这份谱妙就妙在出现了一堆不可能出现的音，比如低音部第六小节的第一颗音，就是不存在的 E#，E# 就是 F，除非是在一些特殊功能下需要特别表示这颗 F 是由一颗 E 变过来时才可能在上面写升号。我一度以为这份谱子的调号标错了，尝试把谱子看成 G 大调上的谱子以合理化它，但是结果表明一丁点关系都没有，因为这份谱子还有一个更严重的问题。</p><h2 id="大熊猫和北极熊"><a href="#大熊猫和北极熊" class="headerlink" title="大熊猫和北极熊"></a>大熊猫和北极熊</h2><p>但比起调号的问题，更严重的问题是大猩猩对于升降记号的理解。如我们刚刚所说，升降记号的存在可以标记出所在调中没有的音，也就是在 7 个音上加标记来表示 12 个音。但似乎在大猩猩的理解中，这个世界的钢琴的一个八度不是 12 个音的，而是 7 个音的。因为在解谜过程中，你需要把 C# 看成 D，把 Db 看成 C 才可以正确求出字符串。如果说你是一个七音音阶的什么古乐器也就算了，大猩猩还大言不惭的在左边特意标出了乐器是 Piano 和 Keyboard，一种现代的黑白键十二平均律乐器。</p><p>也就是说，猩猩家的钢琴，只有白键，没有黑键。我想在猩猩的世界里，下面这个动物叫「大熊猫」吧。</p><p><img src="/static/polar-beer.png" alt="大熊猫？是北极熊啦"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>推理小说十诫中有说：「侦探不应把焦点集中在无关案情的线索，避免误导读者。」</p><p>这其实是作为一种智力博弈游戏的一个重要前提。游戏中错误的乐器、调号让我长时间陷入到对这些极具特殊性的线索的思考中。而且非常让人奇怪的是，解谜涉及了要将某两个字母映射到一个数字的这种后处理方法，而却没有把连接线连接在这些确实需要连接的东西上，谱子上所有的连接线都是单纯误导性的。更不要说还有完全没有意义的红色音符。</p><p>也就是说这个谜题的出题者，在完全不懂乐理、缺乏乐谱的基本常识下，打开了打谱软件随便划拉了一下，就把问题交由全世界的解谜者来解谜。这个谜题的名字叫 Listener，我觉得晚年贝多芬都比出题者更配当一个 Listener。</p><p>如果要解出这个谜题，恐怕要把自己的音乐常识降低到和猩猩一样才能做出来吧。</p><p><strong>救救我们的音乐通识教育吧，别＊＊再糟蹋音乐了。</strong> </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;北京时间 2019 年 1 月 6 日夜间开始了 13 Archetypes 解谜的 Listener 篇。游戏一开始还因为文件名里有 Mf
      
    
    </summary>
    
    
      <category term="游戏" scheme="https://coderemixer.com/tags/%E6%B8%B8%E6%88%8F/"/>
    
      <category term="设计" scheme="https://coderemixer.com/tags/%E8%AE%BE%E8%AE%A1/"/>
    
      <category term="Ingress" scheme="https://coderemixer.com/tags/Ingress/"/>
    
  </entry>
  
  <entry>
    <title>真的走不动了！魔蓝 MD 千叶新城徒步制霸记</title>
    <link href="https://coderemixer.com/2019/12/08/chiba-new-town-mission-day/"/>
    <id>https://coderemixer.com/2019/12/08/chiba-new-town-mission-day/</id>
    <published>2019-12-08T04:43:16.000Z</published>
    <updated>2019-12-08T05:12:31.762Z</updated>
    
    <content type="html"><![CDATA[<h2 id="点错了"><a href="#点错了" class="headerlink" title="点错了"></a>点错了</h2><p>人来日本一年多，这一次 Ingress 社区活动都没有参加过，那叫一个惨。这不是 12 月要到了，赶紧上去看一看最近有什么 Events？诶，这不是有千叶 IFS 嘛，不错，坐电车过去跳个广播体操，刷一下经验回家，开心。赶紧报名。点完报名，不对，我刚刚是不是点的不是 IFS？再一确认，我报名的竟然是千叶新城 MD？！</p><p>那么竟然报名了，那就规划一下怎么制霸吧。</p><h2 id="规划一下"><a href="#规划一下" class="headerlink" title="规划一下"></a>规划一下</h2><p>思路是这样，所有的任务大体都围绕在三个车站：千叶新城、牧之原、印旛日本医大周围。千叶新城的南面 1、2、6、5、4 围成了一个圈可以回到车站，但是任务 11 和其它任务都连不起来，需要单独往返一次。</p><p>千叶新城车站北面的 3、9、10 在一条路上，而 7 8 在另一条路上，两个都必须往返跑。但是我提前查了下 Google 地图，说是可以从 10 的终点步行到 8 的终点，全程 3.8km。</p><p>牧之原的 4 个任务几乎都要折返，但是距离都很短。但是其中有一个 BIGHOP 商店的任务，早上 10 点前是不会开门的。</p><p>印旛日本医大车站附近有三个任务，其中任务 18 山田桥必须折返，往返 6.4km。我严重怀疑这是因为这个任务的终点是本次 Ingress 的赞助商之一，一家农产品店。</p><p>于是，我的想法很简单，先在千叶中央新城把所有南面任务做了，夜里上山比较危险，直接坐出租车去印旛日本医大，完成全部任务后，往回坐一站到牧之原，做完后再往回坐一站到千叶新城上山把剩下全部任务做完。具体的规划如图：</p><p><img src="/static/chiba-md-plan.png" alt="规划表"></p><p>于是就这么愉快地开始吧。</p><h2 id="夜间注意？"><a href="#夜间注意？" class="headerlink" title="夜间注意？"></a>夜间注意？</h2><p><img src="/static/chiba-new-town-station.jpg" alt="抵达车站图"></p><p>我在 0:30 分抵达了千叶新城，绕成圈圈的 1、2、6、5、4 里就已经有坑了，任务 6 花と緑の文化館的第一个任务在公园里，那个公园没有灯，却有大量的楼梯，幸好提前带了买了手电筒挂在包上，不然肯定要摔。单独不在圈里的任务 11（结缘寺）被标注了「夜间注意」，一路走过去反而全是路灯，并没有让人觉得有什么要注意的。反而是终点寺庙里，一片漆黑之中，有一大片墓地，有一个墓的旁边有一座男童的雕像，雕像还被人披上了红色的雨衣，这个是真的把我吓了一跳。在完成 11 去 4 的过程中，Google 地图找到了一条「近路」，一条 OpenStreetMap 上没有的路。想要节省时间的我，自然是走了这条路。这条路是彻底没有了路灯，而且还有路两侧农田里突然响起来的「这里是私有地，进入违法」之类的警告。不过这 6 个任务也算简单，我在早上 02:35 完成了车站南面全部 6 个任务，比规划提前了 2 个小时。</p><p>然后我就遇到了规划里没有预想到的问题，叫不到车。</p><p><img src="/static/chiba-japan-taxi-no-cars.jpg" alt="Japan Taxi 没有可用车辆"></p><p>这个时间点是没有电车的，而且巴士也不在这种小站停，只能叫车。不但是车站边上那个叫车点叫不到车，网约车也叫不到。我一直等到了 03:12 才有一辆出租车开到了车站的叫车点。司机也是非常有意思，车上贴着东京 2020 奥运会的标识。我和司机说我日文不太好之后，司机开始使用一种日英混合的皮钦语试图和我聊天。仗着我在 SFC 日渐专精的日式英语水平，还真的和司机聊上了。</p><p><img src="/static/chiba-md-taxi-receipt.jpg" alt="出租车发票"></p><h2 id="有点远"><a href="#有点远" class="headerlink" title="有点远"></a>有点远</h2><p>任务 18 往返 6.4km 的山田桥是真的远，而且图中没有路灯，而且途中开始下小雨了。本来规划在中间的 7-Eleven 休息一下吃点东西，结果竟然那是一家非 24 小时运营的 7-Eleven（这地方到底是有多村啊，以后我再也不敢说我们湘南台是乡下了）。任务 17 松虫寺也标注了「夜间注意」，反而这座寺庙竟然有开灯，而且我在寺庙的时候遇到了好几组 Cargress 过来的绿军，对刷了两三波之后下山了。原先打算在「松虫寺」旁边本次 MD 联动的咖啡馆喝个咖啡提提神，谁知，这家店 10 点才开始营业。</p><p><img src="/static/yamada-nauman.jpg" alt="山田桥终点"></p><p>完成这个车站附近全部 3 个任务是 05:55，追上了打车延误的时间，比预先还是提前了 2 小时。这几个任务最难的地方是：这个车站附近没厕所！最近的厕所在车站里！这对于我这个慢性肾炎患者严重不友好。</p><p>由于如果现在按原计划去牧之原的话，BIGHOP 那个任务依然要强迫我到 10 点后才能继续。当时有几个参加者在群里说，牧之原那里好像有不良青年（？）。于是考虑变更计划，坐车直接回千叶新城完成山上的任务。然而这几个任务，可以说是灾难的开始。</p><h2 id="日本豆腐丝"><a href="#日本豆腐丝" class="headerlink" title="日本豆腐丝"></a>日本豆腐丝</h2><p>爬到石尊阿夫利神社上已经要上一个非常长的坡了，这个坡上除了墓地、工厂、农田就是太阳能农场。而从任务 10 的终点到任务 8 的终点之间全部都是宽度不足三个人的泥地。这时候雨越下越大，我还没有带伞。路上的泥地踩下去都会陷下去，我的鞋在这时候已经不知道变成什么颜色了。</p><p><img src="/static/chiba-md-roads.jpg" alt="泥地"></p><p><img src="/static/chiba-solar-farm.jpg" alt="太阳能农场"></p><p>（泥地与太阳能农场）</p><p>在最后穿过一片树林后终于见到了任务 08 的第一个 portal。我在做 8 的时候遇到几个开车上来的绿军，都在问这里能不能 hack 到观音堂的 portal。刚刚 hack 过的我非常清楚，po 的位置标错了，要想 hack 到，要爬下一个大概 40m 的坡在下面的树林里才能 hack 到。这次主办方选 Po 的水平，不得不说，和豆腐丝有得一拼。</p><p><img src="/static/chiba-map.png" alt="地形图"></p><p>回到车站的我，已经走路非常吃力痛苦了，但这时候，我完成了 14 个任务。放弃是没办法放弃了，在吃了早饭买了伞之后，坐车去牧之原，完成最后几个任务。这几个任务除了往返以外已经没有什么大坑了。</p><p><img src="/static/chiba-md-missions.jpg" alt="mission 合影"></p><p>最后在签退会场还见到了会讲中文的一个蓝军，和五个绿军。（要死，这游戏怎么玩？平衡性做得也太差了吧。）</p><p><img src="/static/chiba-md-checkin.jpg" alt="签退会场"></p><p>最后一起在千叶喊出「ラーババン」吧。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>回去坐电车换车中间随便吃了点东西，困得只想赶紧睡觉。这次 MD 低保完成的难度应该说是极低的。如果当天没有下雨，按 1-2-6-5-4-3 的顺序完成，不但从车站出发，还直接送你到签到会场结束。但是对于制霸玩家，完全是噩梦。截至写稿，我的腿还是走起来一瘸一拐的状态。</p><p><img src="/static/chiba-md-googlefit.jpg" alt="Google Fit 统计"></p><p>全程 44 公里可能对于平时有常徒步 Ingress 的玩家来说不算一件太困难的事。但是大冬天在雨中从泥地里反复的上坡下坡，确实是把人折腾得够要命。我到家倒头就睡，醒来已经是中午了。</p><p><img src="/static/chiba-ingress-cards.jpg" alt="交换卡片"></p><p>结论就是，下次 MD 前把日本的驾照给考了吧。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;点错了&quot;&gt;&lt;a href=&quot;#点错了&quot; class=&quot;headerlink&quot; title=&quot;点错了&quot;&gt;&lt;/a&gt;点错了&lt;/h2&gt;&lt;p&gt;人来日本一年多，这一次 Ingress 社区活动都没有参加过，那叫一个惨。这不是 12 月要到了，赶紧上去看一看最近有什么 Even
      
    
    </summary>
    
    
      <category term="Ingress" scheme="https://coderemixer.com/tags/Ingress/"/>
    
      <category term="Mission Day" scheme="https://coderemixer.com/tags/Mission-Day/"/>
    
  </entry>
  
  <entry>
    <title>量子算命，在线掷筊 —— IBM 量子云计算机使用入门</title>
    <link href="https://coderemixer.com/2019/11/13/quantum-poe/"/>
    <id>https://coderemixer.com/2019/11/13/quantum-poe/</id>
    <published>2019-11-12T17:54:20.000Z</published>
    <updated>2019-11-12T18:06:01.416Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>自古以来算命离不开随机现象。古代人使用龟壳的裂纹来进行占卜，但出于动物保护主义，现代社会使用裂纹之类的自然混沌来预测变得不人道。现代算命会使用洗牌等手段产生随机数，但这样的随机很多时候可以得到人为控制，无法真正体现神明的意思。</p><p>作者在此提出一个方法，利用量子力学现象进行随机数的发生。我们对于一个量子位（qubit），使其通过一个阿达马门（Hadamard gate）。这个门可以将 $$|0\rangle $$ 转换成 $$\frac{ |0\rangle + |1\rangle } {\sqrt{2}} $$，即进行状态叠加。当我们此时测量这一量子的状态，那么其波函数会发生突变，变为其中一个本征态。且在我们所设计的量子电路中，观察到 0 和 1 的概率应该都是 50%。如果我们今天对量子力学的认识是正确的，那么随机性应该是量子物理的内禀性质，所以我们在邀请真正的上帝来为我们掷骰子，能真正表达量子神明的意愿。</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>我们采用 IBM 的量子云计算机 IBM Q 进行实现。IBM 提供了丰富好用的量子程序开发的 SDK，并且可以在设计调试完成后，交给线上真正的云量子计算机进行运算，让你足不出户，不需要亲自前往土地庙，也可以听到神明的解答。</p><p>我们以「掷筊」为例，</p><blockquote><p><a href="https://zh.wikipedia.org/zh-hans/%E6%93%B2%E7%AD%8A" target="_blank" rel="noopener">掷筊</a>是一种道教与民间信仰中问卜的仪式；又称掷筶、掷杯、博杯，普遍流传于华人民间传统社会。「筊杯」是一种占卜工具，是世俗之人所用以与神明指示的工具。</p></blockquote><p>我们同时观测两个处于叠加态的量子。若它们都是 0，那么就是「阴筊」；如果都是 1，那么就是「笑筊」；如果两个状态相反，那么则是「圣筊」。具体的量子电路如下：</p><p><img src="/static/poe-circuit.png" alt="Poe Circuit"></p><p>使用 Qiskit 实现起来非常便利：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Setup Dependencies</span></span><br><span class="line"><span class="keyword">from</span> qiskit <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment"># Setup Poe Dictionaty</span></span><br><span class="line">POES = [<span class="string">'陰筊'</span>, <span class="string">'聖筊'</span>, <span class="string">'聖筊'</span>, <span class="string">'笑筊'</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># Setup Quantum Circuit</span></span><br><span class="line">circ = QuantumCircuit(<span class="number">2</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>):</span><br><span class="line">    circ.h(i)</span><br><span class="line">circ.measure_all()</span><br><span class="line"></span><br><span class="line"><span class="comment"># Use Simulator for Testing</span></span><br><span class="line">backend = Aer.get_backend(<span class="string">'qasm_simulator'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Execute the Result</span></span><br><span class="line">job = execute(circ, backend, shots=<span class="number">1</span>)</span><br><span class="line">result = job.result().get_counts(circ)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Convert results</span></span><br><span class="line">converted = int(list(result.keys())[<span class="number">0</span>], <span class="number">2</span>)</span><br><span class="line">print(POES[converted])</span><br></pre></td></tr></table></figure><p>我们只需要每进行一次这个量子电路的执行，就可以得到一次上天的掷筊结果。在模拟器测试成功后，我们就可以将后端换成真正的 IBM 云量子计算机进行掷筊。（完整样例程序<a href="https://github.com/dsh0416/quantum-i-ching/blob/master/poe.ipynb" target="_blank" rel="noopener">参考这里</a>）</p><h2 id="未来工作"><a href="#未来工作" class="headerlink" title="未来工作"></a>未来工作</h2><p>我们使用了这一技术更有效的让神明为我们解答问题，对于人类社会具有重大意义。再也不需要等妈祖来托梦，人类可以主动去探寻神明的秘密。但是这一方案目前仍存在不足。</p><p>例如如果我们基于易经进行六爻占卜（<a href="https://github.com/dsh0416/quantum-i-ching/blob/master/notebook.ipynb" target="_blank" rel="noopener">程序</a>），一共需要 64 个经典态，即需要 6 个量子。但 6 个量子的量子芯片目前仍十分稀有。但由于我们的占卜过程不需要产生任何纠缠态，只需要 H 门这一种量子门，在此我们提出可以针对这一市场需求设计并行的单量子芯片，从而让量子计算走入千家万户。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;自古以来算命离不开随机现象。古代人使用龟壳的裂纹来进行占卜，但出于动物保护主义，现代社会使用裂纹之类的自然混沌来预测变得不人道。现代算命会使
      
    
    </summary>
    
    
      <category term="量子计算" scheme="https://coderemixer.com/tags/%E9%87%8F%E5%AD%90%E8%AE%A1%E7%AE%97/"/>
    
  </entry>
  
  <entry>
    <title>日本語字形「关」字攷</title>
    <link href="https://coderemixer.com/2019/08/15/japansese-kanji-5173-research/"/>
    <id>https://coderemixer.com/2019/08/15/japansese-kanji-5173-research/</id>
    <published>2019-08-15T10:22:16.000Z</published>
    <updated>2019-08-15T10:58:48.636Z</updated>
    
    <content type="html"><![CDATA[<p>我的手機使用的是英文系統，Android 在漢字 fallback 的時候會優先 fallback 到日文字形上，這使得一些簡體漢字的顯示非常奇怪。其中一個特別突出的就是「关」<code>U+5173</code> 字。「关」在我的理解中一般作「関」<code>U+95A2</code>、「關」<code>U+95DC</code> 或「闗」<code>U+95D7</code> 的簡化字。但是在日文字形中，<code>U+5173</code> 是一個只有一半字寬的奇怪字形，甚至不符合一般漢字的原理、放在文章裏非常奇怪。</p><p><img src="/static/kanjidic-5173.png" alt="kanjidic-5173"></p><p>Weblio 上的 KANJIDIC2 漢字辭典說這是「日本語ではあまり使用されない漢字です。」這顯然不能解答我們的問題。</p><h2 id="字源探究"><a href="#字源探究" class="headerlink" title="字源探究"></a>字源探究</h2><p>正在我一籌莫展的時候，日本的漢字字源網站 <a href="http://jigen.net" target="_blank" rel="noopener">jigen.net</a> 提供了靈感。這個字源字典收錄了<a href="https://jigen.net/kanji/20851" target="_blank" rel="noopener">「关」</a>字，給出的解釋非常有意思「笑の初文」，也就是說「笑」字最早的寫法，但是網站沒有給出任何參攷資料。如果是這樣的話，我們顯然能在漢語的字源資料中找到相應的蛛絲馬跡。</p><p><img src="/static/jigen-5173.png" alt="jigen-5173"></p><p>說起「笑」的異體字，我們第一反應，可能是「咲」字。於是我們以此入手，可以在《康熙字典》中找到：「《集韻》笑古作咲。註詳竹部四畫。或省作𠇄 <code>U+201C4</code>。」這個字今天還是日語的常用字。</p><p>於是我直接去找了《集韻》（四庫全書本）的影印資料，內容比《康熙字典》裏的要詳細很多：</p><p><img src="/static/jiyun-5173.png" alt="jiyun-5173"></p><blockquote><p>笑咲关仙妙切喜也古作笑或省俗作㗛非是文十一</p></blockquote><p>從這裏我們確認，「关」確實在歷史上可以作爲「笑」的意思。</p><p>但是把「关」稱爲「笑」的初文的證據卻不好找。1999 年復旦大學中文系張虹倩、劉斐在《中國文字研究》雜誌上發表了一篇論文。認爲：</p><blockquote><p>“笑”字字形流变中”从艸从犬”早于”从竹从犬”,”从竹从犬”又早于”从竹从夭”。然而”从艸从犬”也非”笑”的最早字形,”艸”是”八”的篆形讹变。</p></blockquote><p>這篇文章的立論建立在《說文》中對於「笑」字的原始記載已經遺失。但是這一說法和之後的出土文物不符。隨着更早的楚系簡牘和帛書的<a href="https://www.zdic.net/zd/zx/cx/%E5%92%B2" target="_blank" rel="noopener">出土</a>，我們可以看到在《說文》以前，「笑」字是「从艸从犬」的𦬦 <code>U+26B25</code> 字，「关」作「笑」字初文並沒有有效的證據。</p><p><img src="/static/jiandu-5173.png" alt="jiandu-5173"></p><p>除了這一解釋，還有一個解釋，認爲「关」是「芖」讹變而來。「芖」在 1920 年代出土東漢《熹平石经》周易殘碑顯示是「笑」的省文。而「咲」是「关」加上「口」字旁的俗字。這一說法在邏輯上講得通，而且也可以解釋爲什麼日本語的「关」字形使用了一半的字寬，因爲把這個字視作「咲」的一部分。但這一說法沒有實際的證據證實，所以也只能作爲一個推測來看。</p><h2 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h2><p>其實深入研究到後半段就發現，無論原因是什麼，日文字形裏的「关」和簡化字的「关」完全就是兩個字。</p><p>根本不知道爲什麼 Unicode 分配到了同一個編碼上。</p><p>雖然 Unicode 的實作很髒，但是它確實構成了我們每天生活的必需。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;我的手機使用的是英文系統，Android 在漢字 fallback 的時候會優先 fallback 到日文字形上，這使得一些簡體漢字的顯示非常奇怪。其中一個特別突出的就是「关」&lt;code&gt;U+5173&lt;/code&gt; 字。「关」在我的理解中一般作「関」&lt;code&gt;U+95A2
      
    
    </summary>
    
    
      <category term="语言学" scheme="https://coderemixer.com/tags/%E8%AF%AD%E8%A8%80%E5%AD%A6/"/>
    
      <category term="日语" scheme="https://coderemixer.com/tags/%E6%97%A5%E8%AF%AD/"/>
    
  </entry>
  
  <entry>
    <title>休闲魔蓝玩家的湘南单人四重蓝笋</title>
    <link href="https://coderemixer.com/2019/08/12/ingress-resistance-shonan-homogeneous-field/"/>
    <id>https://coderemixer.com/2019/08/12/ingress-resistance-shonan-homogeneous-field/</id>
    <published>2019-08-12T12:29:28.000Z</published>
    <updated>2019-08-12T13:10:00.693Z</updated>
    
    <content type="html"><![CDATA[<p>作为一个蓝笋教徒，上一次也是唯一一次做蓝笋就是 <span style="color: rgb(0, 112, 192);">@ngiamzsjit</span> 设计的复旦单人完全四重任务。</p><p>那个任务我做了两次，第一次做到一半，被突然出现的绿军炸了。而且那个绿军确实是无心的，一边上课一边随手甩了两个炸。由于那个炸同时涉及一类点和二类点。让修复工作变得异常困难，最后随便连了一通就回家了。</p><p>第二次是在夜里做的，当时复旦内部正在施工，有好几个 po 非常难摸，但是做到凌晨还是顺利完工，只不过出校门的时候被复旦的保安问了半天。</p><p><img src="/static/ingress-homo-badge.png" alt="ingress-homo-badge"></p><p>然后我就咸鱼了一年。本来以为到了日本 portal 密度变高应该可以多玩玩，结果一年下来连家门口 50 米远的 IFS 都没去。于是就考虑在暑假趁着做个单人四重竹笋把学校盖了。</p><h2 id="规划"><a href="#规划" class="headerlink" title="规划"></a>规划</h2><p>我大概一个月前开始规划。我们庆应大学湘南藤泽校区在山上，又是休校时间，上山的唯一公共交通工具是公交车，最近的车站分别是 30 分钟车程的湘南台站和辻堂站。这意味着行动一旦开始，绿军就算要来阻挡，至少也需要大概半个小时的机动时间。</p><p>校区很小，校区内大约有 20 个左右的 portal，密度很高，理论上应该会好做，但是实际情况形状不够好，在这些 portal 中找不到可能的四重解。最后考虑引入大学在坡下入口处的纪念碑和学校后门几个神社，最后找到了一组解。</p><p><img src="/static/ingress-homo-plan.png" alt="ingress-homo-plan"></p><p>我一开始使用的是 <span style="color: rgb(0, 112, 192);">@NanoApe</span> 开发的 <a href="https://github.com/Konano/Ingress-Field-Design/" target="_blank" rel="noopener">Konano/Ingress-Field-Design</a> 工具进行规划在。运行过程中发现两个问题，一个是这个项目一开始设计给 Windows 执行的，程序完全由 GB2312 编码编写和编译。实际运行后发现由于我的 portal 名中有日语字符，直接 crash 了整个程序。最后我把编码都换成了 UTF-8 重新编译，输出了四重规划。</p><p>然后是输出单人四重的路径，<a href="https://github.com/Konano/Ingress-Field-Design/" target="_blank" rel="noopener">Konano/Ingress-Field-Design</a> 希望用户手动上传一个经过所有 portal 的路径。而我嫌麻烦，用 Mathematica 随手写了个脚本随手写了个枚举所有点 Dijkstra 找最短路的程序，算法时间复杂度是 O(N^2)。结果就被自己写的程序坑了，因为选定的好几组 portal 在两个坡上，这使得我之后行动时不停上坡下坡。</p><h2 id="行动开始"><a href="#行动开始" class="headerlink" title="行动开始"></a>行动开始</h2><p>在行动开始前有个好消息就是学校的整个区域被一条从农舍间的 portal 射出来的多个蓝色 field 盖场。这使得学校内 portal 在行动开始前完全是没有 link 的状态，这是完美的行动条件。</p><p>但不如人意的是我从 7 号开始感冒发烧，于是行动一直被推迟 <del>（反正画过就是做过）</del>。一直到 10 号 JST 6:00 在双倍经验结束前几个小时，我实在睡不着，想出去散步清醒一下，于是当即决定开始行动。</p><p>首先我坐巴士上到山一半的远藤。在一片杂草中见到那个用来盖场的 portal，插八然后毒，接下来徒步上山。</p><p><img src="/static/ingress-grass.png" alt="ingress-grass"></p><h2 id="插曲-1"><a href="#插曲-1" class="headerlink" title="插曲 1"></a>插曲 1</h2><p>然而行动刚刚开始一小时，我刚把第一个支点的 key 摸全，开始连线就被绿军 <span style="color: rgb(0, 176, 80);">@sicksQ </span> 打了。</p><p><img src="/static/ingress-comm-1.png" alt="ingress-comm-1"></p><p>这直接把我原来的计划打乱。于是我和 Intel 组正在帮我截图的 <span style="color: rgb(0, 112, 192);">@DarkKowalski</span> 开始用工地日语向对方询问。</p><p><img src="/static/ingress-comm-2.png" alt="ingress-comm-2"></p><p>对方随后表示接受，并且让我当心中暑，行动得以继续。但是 key 缺了几把，于是又不得不回去重新摸。根据攻击的范围判断，对方可能就是住在学校附近的住民，万万没想到千算万算在这里失算了。</p><p><img src="/static/ingress-comm-3.png" alt="ingress-comm-3"></p><p>一直到大约 9 点，问题 portal 基本修复完毕。而我因为这个感冒头昏脑胀，学校因为休校，关闭了自动贩卖机，我差点脱水。趁着修复的过程下山买了几瓶运动饮料灌下去又坐了一会，可以继续行动。</p><h2 id="插曲-2"><a href="#插曲-2" class="headerlink" title="插曲 2"></a>插曲 2</h2><p>行动进行到大约 9:30 发现 Ingress Prime 有一个很麻烦的 bug。在 link 完成后，默认提示的下一个 link portal，经常图片没有刷新但是文字没有刷新。这使得我不小心连接错了一个 portal，还好是四类点影响不大，毒了重新摸，再重新连。</p><p>但是当我到最后一个 portal 的时候发现自己忘记带 SoftBank Ultra Link 了。一共要往外射 9 条 link。而我当时已经把支点连接完毕了。</p><p>当时 Intel 组的 <span style="color: rgb(0, 112, 192);">@DarkKowalski</span> 当即表示他有一个 pack 没有兑换，里面有 SoftBank Ultra Link 可以合法空投。这个 pack 放在 <span style="color: rgb(0, 112, 192);">@alexanderjunyin</span> 那里。在连续电话、微信电话、Telegram 电话各两通后，我确认，这人 <strong>睡着 </strong> 了。</p><p><img src="/static/telegram-sleep.png" alt="telegram-sleep"></p><p>于是不得不毒了打掉。从坡下的另一个支点连过来。毒的过程中 8 个 key 只掉了 2 把，库存里还有 2 把，又绕学校一圈重新摸了 4 把。</p><p>最终终于完成了完全四重。</p><p><img src="https://imgur.com/OyAIiox.gif" alt=""></p><p><img src="/static/ingress-homo-result.png" alt="ingress-homo-result"></p><h2 id="感想"><a href="#感想" class="headerlink" title="感想"></a>感想</h2><p>虽然最后没有在双倍经验结束前做完，但还是坚持做完了这个非常酷的完全四重。不过我下次再也不想在生病的时候去做这种大任务了，感觉真的要死。另外那位放我一马的重生绿军大佬 <span style="color: rgb(0, 176, 80);"> @sicksQ </span> 觉得这个 CF 很好看，一直到晚上都没有来打。</p><p>这里不愧是乡下，做了一个完全四重 COMM 里完全寂静，而且也没有人约饭。最后只好去便利店买了两个三明治，再去药店买了一盒感冒药回家了。</p><p>不过下个月就要回国，原本考虑做超级大坑清明上河图，但似乎里面有好几个任务没有办法摸到。于是考虑一下是不是有可能去做个单人五重。之前虽然做过 <span style="color: rgb(0, 112, 192);">@ngiamzsjit</span> 的教程，但是觉得对于多重的理解并不是很深刻，在这次自己把自己差点坑死后，感觉自己对完全多重的理解进步很大。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>地面组：<span style="color: rgb(0, 112, 192);">@DELTOND</span></p><p>清障组：<span style="color: rgb(0, 112, 192);">@DELTOND</span></p><p>提供 Key：<span style="color: rgb(0, 112, 192);">@DELTOND</span></p><p>规划程序协力：<span style="color: rgb(0, 112, 192);">@NanoApe</span></p><p>Intel &amp; 截图：<span style="color: rgb(0, 112, 192);">@DarkKowalski</span></p><p>感谢绿军：<span style="color: rgb(0, 176, 80);">@sicksQ </span></p><p>睡觉组：<span style="color: rgb(0, 112, 192);">@alexanderjunyin</span></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;作为一个蓝笋教徒，上一次也是唯一一次做蓝笋就是 &lt;span style=&quot;color: rgb(0, 112, 192);&quot;&gt;@ngiamzsjit&lt;/span&gt; 设计的复旦单人完全四重任务。&lt;/p&gt;
&lt;p&gt;那个任务我做了两次，第一次做到一半，被突然出现的绿军炸了。而且那个
      
    
    </summary>
    
    
      <category term="Ingress" scheme="https://coderemixer.com/tags/Ingress/"/>
    
      <category term="完全四重" scheme="https://coderemixer.com/tags/%E5%AE%8C%E5%85%A8%E5%9B%9B%E9%87%8D/"/>
    
  </entry>
  
  <entry>
    <title>晦涩难懂的码农段子（连载中）</title>
    <link href="https://coderemixer.com/2019/05/06/programming-jokes-that-hard-to-be-understood/"/>
    <id>https://coderemixer.com/2019/05/06/programming-jokes-that-hard-to-be-understood/</id>
    <published>2019-05-06T13:34:36.000Z</published>
    <updated>2019-05-06T14:53:08.120Z</updated>
    
    <content type="html"><![CDATA[<h2 id="序"><a href="#序" class="headerlink" title="序"></a>序</h2><p>《晦涩难懂的码农段子》是我从今年三月的一天突发奇想开始写的一些零散的段子集。通常是首发在微博上，并且添加 <code>#晦涩难懂的码农段子</code> 作为 Tag。然后如果字数允许，转发到 Twitter 上。这个系列的段子，是不是真的晦涩难懂，其实不尽然；那有是不是只和码农有关，其实有些也只是擦边球。这个系列的最初想法是我在读了很多喜剧作品，特别是很多 Stand-up Comedy 后，进行的一些分析，试图理解喜剧所需要的剧情冲突究竟如何体现。所谓冲突，即在一个自洽的舞台说明下，发展出矛盾。把这一舞台设定在程序员的世界中，实际上本质是设置在我所熟悉的当下社会里。而有时候，笑话本身也可以产生一种讽刺。而这个则是利用喜剧将观众引入更令人思考的方向了。</p><p>由于微博帐号莫名其妙被封号，我决定在这篇文章里，将发过的内容整理修正一下，如有遗漏，请多多谅解。</p><p>这个系列的段子就目前来看，主要有几个常见的类型。</p><p>一个最常见的是通过一系列比较，先让观众在大脑中建立某一领域的思维定式，再在最后一句话中打破它。这一类型是启发自 Stand-up Comedy 里一种前半段很正经地讲新闻，然后突然改用戏虐的口气调侃事件，从而产生一个巨大的反差感。在写的过程中，逐渐固定了一些人物的形象，比如说，如果需要有人风评被害，那么优先是小李；如果梗有二次发展，那么还可以有老李。</p><p>一个是老梗新说，很多时候其实是一些大家已经见过的老梗，而这里的关键就是如何在老梗上做进一步地发展。比如为老梗增加铺垫，或者突然改变老梗的结局或者背景。写这一些段子的时候，我的主要想法是，写一些比较长的段子的时候，需要利用到类似的通过铺垫渐进，中间又不能让笑点断开太久。而利用已知去制造冲突，利用梗制造梗，则是一个非常有趣的选择。</p><p>最后则是一些一句话段子。虽然字数短，但是信息量不会少。句子中还需要通过被故意颠倒的语法或者添加一些无意义的虚词，来使得观众需要在听完句子后进行一些思考，再对笑话做出反应。这一类则是利用人思考本身的特征来创造喜剧冲突。</p><p>说实话，「晦涩难懂」四个字，其实一开始，只是为我的笑话难笑而找的借口。就像虽然我喜欢看「純靠北工程師」，但是被卖掉，天天发废文的「靠北工程師」似乎更受到大众的欢迎。如果做大是工程师讲段子给大家听，那么我希望能够把段子将给工程师听。而这就是这个系列存在的核心想法。</p><h2 id="段子一览（从新到旧）"><a href="#段子一览（从新到旧）" class="headerlink" title="段子一览（从新到旧）"></a>段子一览（从新到旧）</h2><p><strong>2019-05-03</strong></p><p>你怎么写出这种烂代码的？你是没学过设计模式吗？<br>（一个月后）<br>幹！你怎么在一份 codebase 里同时写十几种设计模式的？</p><p>结论：一个月前这人在写 Vanilla JS，一个月后改写 React 了。</p><p><strong>2019-05-02</strong></p><p>小王是一名 C++ 工程师，他其实只会写 C，但用 C++ 编译器编译。<br>小张是一名 C++ 工程师，他会往 C 语言里加一些 class 和 template 关键字。<br>小李是一名 C++ 工程师，他熟读标准，精通标准库，他的代码大量使用了 C++ 近 10 年来引入的新特性。</p><p>老李写的是谭++。</p><p><strong>2019-05-01</strong></p><p>小王喜欢用 null 表示空，词源是拉丁语 nūllus (not any)。<br>小张觉得直接用拉丁语 nil 更好，更短也表达了 nothing 的意思。<br>小周觉得用英语 None 不更便于理解？<br>小李觉得他们都有道理，于是同时引入了 nil null None 和 Nothing。</p><p>老李觉得，应该再引入一个 NSNull。</p><p><strong>2019-04-26</strong></p><p>现有的尝试去除 GC 又希望内存安全的语言，trade-off 其实都挺大的。我觉得每个拿 Rust 实现过大型项目的人，都对它爱恨交织。虽然现在 GC 技术已经发展得如此先进，但是大家还是迫切地想去除它，我觉得主要原因是编译器作者很难和人解释清楚自己在某 top 公司做垃圾回收的工作。</p><p><strong>2019-04-26</strong></p><p>A: 刚有新闻说澳大利亚的垃圾回收系统崩溃了？</p><p>B: 啊，什么虚拟机出 bug 了？</p><p><strong>2019-04-24</strong></p><p>我的西班牙语知识主要来自于 macOS 的 codename。</p><p><strong>2019-04-24</strong></p><p>结论：谦谦从 B 站离职去了日本，<br>B 站和日本的平均英语水平都下降了。</p><p><strong>2019-04-15</strong></p><p>表面：我是全栈工程师。<br>其实：我能写点 JavaScript。</p><p>表面：我写过 Ruby。<br>其实：我用 Rails 脚手架生成好代码后，往里面随便填点东西。</p><p>表面：我会用 Git。<br>其实：我有个 GitHub 账号。 </p><p>表面：我关心开源社区发展。<br>其实：我常看○○峰博客。</p><p><strong>2019-04-10</strong></p><p>在日本，<br>租房需要手机号和银行卡；<br>办手机需要住址和银行卡；<br>而银行需要手机号和住址。</p><p>结论，引用计数法需要引入弱指针才能避免循环引用导致的内存泄漏。</p><p><strong>2019-04-07</strong></p><p>小王的高中数学成绩很好，他大学报考了数学系，挂科了无数门，毕业后他决定放弃数学转业成为了一名优秀的软件工程师。</p><p>小张听说 21 世纪是生命科学的世纪，他大学报考了生物系，延毕了两年，毕业后他决定放弃生物转业成为了一名优秀的软件工程师。</p><p>小李很喜欢打电子游戏，他大学报考了计算机科学，天天在宿舍玩游戏，毕业后没找到工作，回老家搬砖去了。</p><p><strong>2019-04-07</strong></p><p>小王是前端工程师，能熟练处理 IE6 的 3px 漂移和 margin 会突然翻倍的 bug。<br>小张是前端工程师，熟读了 ES6 标准，使用 webpack 来打包他的前端项目。<br>小明是前端工程师，拿框架脚手架生成代码后，依葫芦画瓢也能写出一个前端项目。</p><p>小李培训班毕业后，难以独立完成项目。但是他读了一些文章后，认为自己写的语言和 Haskell 是近亲，他是优雅的函数式程序员，天天上网和人约架。</p><p><strong>2019-04-06</strong></p><p>调校模型 ✅️<br>调教模型 ❎️</p><p>调教的话，不感觉有点色情吗…<br>仿生人会和电子羊玩 SM 吗？</p><p><strong>2019-04-05</strong></p><p>小王精通数理逻辑，他是一名大数据工程师。<br>小张熟悉线性代数，他是一名大数据工程师。<br>小明会用神经网络框架，他是一名大数据工程师。</p><p>小李会用 Excel，有两块 4TB 硬盘，他声称自己是大数据工程师。小李拿到了融资，雇小王小张小明实现。「这公司第一行代码是我写的」小李说。</p><p><strong>2019-03-28</strong></p><p>我幼儿园的时候只会写一些垃圾 BASIC，一直到小学五年级才算好好掌握了一下 VB。感觉学得太晚，而且太不系统。我如果当时学的是 Lisp，</p><p>恐怕现在穿女装会更可爱一点吧。</p><p><strong>2019-03-28</strong></p><p>声明式编程：大杯豆奶三份抹茶粉三泵糖。</p><p>命令式编程：大杯抹茶拿铁去牛奶换豆奶，多加两 shot 抹茶粉去一半糖。</p><p>虽然命令式点单很麻烦，但仔细一想，如果星巴克采用声明式点单的话，水不收钱，美式就不能卖得比浓缩贵了。</p><p><strong>2019-03-27</strong></p><p>小王写代码前会仔细思考，如果一个方法会被复用或对性能有很大影响，他会提前设计好架构，然后简洁优雅地实现出来。</p><p>小张会事后思考，擅长分析性能瓶颈，根据工程规模进行重构，代码仓库保持得很干净。</p><p>小李想到哪里写到哪里。</p><p>但因为 git commit 数量比较多，小李被升职了。</p><p><strong>2019-03-27</strong></p><p>小王是一个大型项目下的 C++ 工程师，今天他上班 trigger 了一个全量编译便回家了，明天再来。</p><p>小张是一个深度神经网络的 Python 工程师，今天他上班改了一个参数开始训练便回家了，三天后再来。</p><p>小李是一名资深的 Rust 工程师，今天他上班只花了一小时就完成了需求的开发。</p><p>然后连续加班了三个晚上才使得编译通过。</p><p><strong>2019-03-27</strong></p><p>小王是星星大户，他在简历写上自己的 GitHub ID 希望公司知道他是个开源狂热者。</p><p>小张以前公司仓库在 GitHub 上，他写上自己的 GitHub ID 希望公司看到自己勤奋的贡献表。</p><p>小李不想成为程序员，但他家人逼他。他在简历上下自己全白的 GitHub 账号好让面试官尽早淘汰他。</p><p><strong>2019-03-27</strong></p><p>小王是一个大型项目下的 C++ 工程师，今天他上班 trigger 了一个全量编译便回家了，明天再来。</p><p>小张是一个深度神经网络的 Python 工程师，今天他上班改了一个参数看是训练便回家了，三天后再来。</p><p>小李是一名资深的 Rust 工程师，今天他上班只花了一小时就完成了需求的开发。</p><p>然后连续加班了三个晚上才使得编译通过。</p><p><strong>2019-03-26</strong></p><p>今天晚上小王在度假很快乐，想打开手机看看朋友圈。结果小王刚打开微信就看到，产品经理在找他修 bug，小王马上把微信关起来。</p><p>「假的！」<br>「哎呀，我的眼睛业障重啊。」</p><p>请问那个 bug 是真的还是假的？暂时的。但是如果你当真的，那你就会很生气很急，想赶紧去看日志，最后发现基本上都是鸡毛蒜皮的问题。你不修也有别人修，说不定重启重启自己就好了，大不了老板和客户糊弄两下就过去了。</p><p><strong>2019-03-26</strong></p><p>小王学习了 Rust 语言，<br>小王不敢用 nightly 上生产，<br>但人人都拿 nightly 上生产，<br>而且总有需要的特性在 nightly 里。</p><p>最后小王悟到了「nightly 不异 stable，stable 不异 nightly；nightly 即是 stable，stable 即是 nightly」的道理。</p><p><strong>2019-03-25</strong></p><p>小王自从学习了 Swift 和 Kotlin 语言后，<br>性格变得多疑和激动了很多。</p><p><strong>2019-03-25</strong></p><p>小王的自我学习能力很强。最近，他在工作之余，又学习了单片机知识。看完教材，他感触很深，决定给自己做的项目添加跑马灯和利用蜂鸣器放音乐的功能。</p><p><strong>2019-03-24</strong></p><p>曲艺界有句行话说：「一天不练，自己知道；两天不练，同行知道；三天不练，观众知道。」其实这句话放在二十一世纪的程序行业也是非常受用的。</p><p>一天不写代码，<br>打开你的 GitHub Profile 全知道了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;序&quot;&gt;&lt;a href=&quot;#序&quot; class=&quot;headerlink&quot; title=&quot;序&quot;&gt;&lt;/a&gt;序&lt;/h2&gt;&lt;p&gt;《晦涩难懂的码农段子》是我从今年三月的一天突发奇想开始写的一些零散的段子集。通常是首发在微博上，并且添加 &lt;code&gt;#晦涩难懂的码农段子&lt;/cod
      
    
    </summary>
    
    
      <category term="编程" scheme="https://coderemixer.com/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="笑话" scheme="https://coderemixer.com/tags/%E7%AC%91%E8%AF%9D/"/>
    
      <category term="段子" scheme="https://coderemixer.com/tags/%E6%AE%B5%E5%AD%90/"/>
    
  </entry>
  
  <entry>
    <title>微信红包背后的赌博游戏</title>
    <link href="https://coderemixer.com/2019/03/26/wechat-red-envelope-analyze/"/>
    <id>https://coderemixer.com/2019/03/26/wechat-red-envelope-analyze/</id>
    <published>2019-03-26T14:15:09.000Z</published>
    <updated>2019-03-26T15:20:09.172Z</updated>
    
    <content type="html"><![CDATA[<h2 id="序"><a href="#序" class="headerlink" title="序"></a>序</h2><p>今天坐车的时候，看到司机的微信在玩一个叫「红包接龙」的游戏，让我提起了兴趣。游戏的规则很简单：群里有 100 个人，首先群主发一个 100 元的红包，然后大家去抢。抢到最多钱的那个人（手气最佳）必须再发一个 100 元的红包，依次类推。乍一听，如果每个人都遵守规矩，那么这就是一个零和游戏。但仔细品品感觉并不那么简单。在这个情况下，是不是资产很容易两极分化，然后其中一些人破产呢？又或者，存不存在一种玩法，使得可以必胜呢？于是我想来好好讨论一下这个问题。</p><h2 id="随机算法"><a href="#随机算法" class="headerlink" title="随机算法"></a>随机算法</h2><p>要想探讨这个游戏，首先我们需要知道微信红包是怎么进行随机算法的。根据这个<a href="https://www.zhihu.com/question/22625187/answer/85530416" target="_blank" rel="noopener">知乎回答</a>，答主给出了一个微信红包的算法。由于具体的算法是一个黑盒，那么我们就先建立在这个算法下进行好了，也就是：</p><blockquote><p>每个人随机从 0.01 和剩余平均值两倍之间取一个值，最后一个人拿走剩余全部。</p></blockquote><p>我写了一个小 Ruby 脚本来实现这个功能：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">require</span> <span class="string">'descriptive_statistics'</span></span><br><span class="line"><span class="keyword">require</span> <span class="string">'securerandom'</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RedEnvelope</span></span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">initialize</span><span class="params">(money, size)</span></span></span><br><span class="line">    @size = size</span><br><span class="line">    @money = money</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">draw</span></span></span><br><span class="line">    raise <span class="string">'Empty Envelope'</span> <span class="keyword">if</span> @size &lt; <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> @size == <span class="number">1</span></span><br><span class="line">      @size -= <span class="number">1</span></span><br><span class="line">      <span class="keyword">return</span> @money</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    max = @money / @size * <span class="number">2</span></span><br><span class="line">    aquired = SecureRandom.random_number(max - <span class="number">1</span>) + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    @size -= <span class="number">1</span></span><br><span class="line">    @money -= aquired</span><br><span class="line">    aquired</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">empty?</span></span></span><br><span class="line">    @size == <span class="number">0</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span></span></span><br><span class="line">  <span class="keyword">attr_reader</span> <span class="symbol">:name</span>, <span class="symbol">:money</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">initialize</span><span class="params">(name, money)</span></span></span><br><span class="line">    @name = name</span><br><span class="line">    @money = money</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">generate</span><span class="params">(money, size)</span></span></span><br><span class="line">    raise <span class="string">"<span class="subst">#&#123;@name&#125;</span> Go Bankrupt"</span> <span class="keyword">if</span> money &gt; @money</span><br><span class="line">    @money -= money</span><br><span class="line">    RedEnvelope.new(money, size)</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">fetch</span><span class="params">(envelope)</span></span></span><br><span class="line">    fetched = envelope.draw</span><br><span class="line">    @money += fetched</span><br><span class="line">    fetched</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Game</span></span></span><br><span class="line">  <span class="keyword">attr_accessor</span> <span class="symbol">:users</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">initialize</span><span class="params">(bet, users)</span></span></span><br><span class="line">    @bet = bet</span><br><span class="line">    @users = users</span><br><span class="line">    @round = <span class="number">0</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">play</span><span class="params">(user)</span></span></span><br><span class="line">    @round += <span class="number">1</span></span><br><span class="line">    order = @users.shuffle</span><br><span class="line">    largest_amount = <span class="number">0</span></span><br><span class="line">    largest_user = <span class="literal">nil</span></span><br><span class="line">    envelope = user.generate(@bet, @users.size)</span><br><span class="line">    order.each <span class="keyword">do</span> <span class="params">|user|</span></span><br><span class="line">      amount = user.fetch(envelope)</span><br><span class="line">      <span class="keyword">if</span> amount &gt; largest_amount</span><br><span class="line">        largest_amount = amount</span><br><span class="line">        largest_user = user</span><br><span class="line">      <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    print <span class="string">"Round <span class="subst">#&#123;@round&#125;</span>: "</span></span><br><span class="line">    puts @users.map &#123; <span class="params">|u|</span> u.money / <span class="number">100.0</span> &#125;.standard_deviation</span><br><span class="line">    largest_user</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h2 id="标准差与破产探索"><a href="#标准差与破产探索" class="headerlink" title="标准差与破产探索"></a>标准差与破产探索</h2><p>我们先假设有 10 个玩家，每个人有 5000 元开局，每一把玩 200 元好了。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">users = []</span><br><span class="line"><span class="number">10</span>.times <span class="keyword">do</span> <span class="params">|i|</span></span><br><span class="line">  users &lt;&lt; User.new(<span class="string">"User <span class="subst">#&#123;i&#125;</span>"</span>, <span class="number">5_000_00</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">game = Game.new(<span class="number">200_00</span>, users)</span><br><span class="line"></span><br><span class="line">user = users.first</span><br><span class="line">loop <span class="keyword">do</span></span><br><span class="line">  user = game.play(user)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>进行了一次模拟，在游戏进行到第 2399 轮时，2 号玩家破产。玩家间余额的标准差随游戏轮数的关系如下：</p><p><img src="/static/std-env.jpg" alt="std-env"></p><p>多进行几次模拟，修改初始金额或每次的赌资，情况几乎不变。也就是随着游戏轮数的进行，玩家间余额的标准差（贫富差距）在变得越来越大，直到某一玩家破产，游戏结束。</p><p>这一结论是显然的，因为实际上这个游戏是一个典型的「无偏随机游走」问题，标准差与时间成正比。随着游戏进行，必然一些人变得极度有钱，而越来越多人会破产。</p><h2 id="随机算法的不随机之处"><a href="#随机算法的不随机之处" class="headerlink" title="随机算法的不随机之处"></a>随机算法的不随机之处</h2><p>但财富不单单是聚集的问题，如果我们仔细回头看这个随机算法，就会发现它是有规律的。</p><p>虽然均值一样，但是越早抽到红包，方差越小，越不可能遇到需要发红包的情况。越后抽越容易出现手气最佳，从而产生负收益的情况。在均值一致的情况下，只要减少发红包的次数就行了。于是，庄家如果有机器辅助的话，就可以把自己的期望变为正数。</p><p>但是，这时我就产生了一个疑问：「如果同时也有其它机器人一起参与抢单呢？」</p><p>我于是问了问司机，这群有人用抢红包工具吗？司机非常自信地告诉我：「不可能。群主会先收取押金，如果你被发现作弊，会直接把你踢出群。」</p><p>原来如此，原来只要把连着几把第一个抽的直接踢出群没收押金即可。</p><p>完美。</p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>十赌九输，</p><p>赌博前请先学数学。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;序&quot;&gt;&lt;a href=&quot;#序&quot; class=&quot;headerlink&quot; title=&quot;序&quot;&gt;&lt;/a&gt;序&lt;/h2&gt;&lt;p&gt;今天坐车的时候，看到司机的微信在玩一个叫「红包接龙」的游戏，让我提起了兴趣。游戏的规则很简单：群里有 100 个人，首先群主发一个 100 元的红包
      
    
    </summary>
    
    
      <category term="Ruby" scheme="https://coderemixer.com/tags/Ruby/"/>
    
      <category term="微信" scheme="https://coderemixer.com/tags/%E5%BE%AE%E4%BF%A1/"/>
    
      <category term="数学" scheme="https://coderemixer.com/tags/%E6%95%B0%E5%AD%A6/"/>
    
      <category term="赌博" scheme="https://coderemixer.com/tags/%E8%B5%8C%E5%8D%9A/"/>
    
  </entry>
  
  <entry>
    <title>挖一个关于 IM 工具的新坑</title>
    <link href="https://coderemixer.com/2019/03/05/project-nyan-chat/"/>
    <id>https://coderemixer.com/2019/03/05/project-nyan-chat/</id>
    <published>2019-03-04T19:15:08.000Z</published>
    <updated>2019-03-10T08:55:06.081Z</updated>
    
    <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>我考虑重新设计一个即时通讯工具的想法已经很久了，但一直没有付诸于事实。有几个理由让我不得不设计一个新的 IM。我对于我目前正在使用的 IM 工具都不能感到满意。我基本可以把我正在使用的 IM 分成几类：</p><ul><li>由运营商直接提供的通讯系统（电话、短信）</li><li>社交属性重的通讯工具（微信、Line、Facebook Messenger）</li><li>具有一定安全性设计的通讯系统（iMessage、Telegram、Keybase、Signal）</li></ul><h2 id="产品调研"><a href="#产品调研" class="headerlink" title="产品调研"></a>产品调研</h2><p>第一类工具是同时缺乏产品性和安全性的，它们的功能基础而单一，随便一点更新都很难推进，连 VoLTE 都是一个普及了好几年都很少有人在用的情况。而像是可以进行多人群聊的语音会议或是群发短信操作都非常复杂，资费同时也非常高。更严重的问题是，这些产品对于安全性是几乎没有保护的，你的聊天内容对于运营商不但是明文的，随便给你来个 GSM 伪基站配合降级攻击很容易就能让不法分子有可乘之机。</p><p>第二类工具的产品性非常强，功能迭代速度很快，你想要的东西它都有。但同时你泄漏的用户资料更多，你甚至无法判断这到底是一个社交应用还是一个聊天应用。人在公开场合聊天和私下聊天的目的明显是不同的。另外，一旦这些厂商可以通过利用你的个人隐私来盈利时，它们很难不这么做，这是资本的力量。据小道消息称，微信的开发团队来自于原邮箱团队，设计上很大参考了邮箱的设计，一直到前几年通过引入了 MMTLS 协议来提供了安全性上的保障。但由于微信不是一个开源工具，其安全性无法通过白盒测试的方法进行验证，如果存在后门，用户是无法预防的。而一旦通过黑盒方法找到漏洞的靠着这个赚钱都来不及，就更不要说能及时得到修复了。</p><p>第三类有安全性设计的系统例如带有 E2E 加密设计的 iMessage Telegram Keybase 和 Signal。iMessage 的安全情况我个人是高度怀疑的，尤其在 AppleID 安全事故频发的情况下。Telegram 虽然支持 E2E 模式，但并不是默认开启的，对多客户端的支持也有问题。桌面端的一些实现甚至不支持 E2E 模式，同时也不支持群聊加密。Telegram 和 Signal 基于手机号码的形式有很大的被嗅探的风险，这也是我不选择的一个原因。至于 Keybase 基于的 GPG 系统按理说是安全的，但 Keybase 是一个半开源的状态，我非常不放心这样的设计。更大的问题是，Keybase 在尝试把这个隐私优先的 IM 工具做成一个非常社交化的系统，每个人都能很自由地查询到用户的各个设备具体公钥的元信息，在隐私上造成了很大的困扰。</p><h2 id="产品设计"><a href="#产品设计" class="headerlink" title="产品设计"></a>产品设计</h2><blockquote><p>任何人的私生活、家庭、住宅和通信不得任意干涉，他的荣誉和名誉不得加以攻击。人人有权享受法律保护，以免受这种干涉或攻击。——《世界人权宣言》第十二条</p></blockquote><p>如果一个系统是通讯系统，那么隐私是这个系统的第一要务。一个没有良好隐私设计的通讯系统如同乔治奥威尔的小说<a href="https://zh.wikipedia.org/zh/%E4%B8%80%E4%B9%9D%E5%85%AB%E5%9B%9B" target="_blank" rel="noopener">《1984》</a>中无处不在的 <a href="https://zh.wikipedia.org/wiki/%E7%94%B5%E5%B9%95" target="_blank" rel="noopener">电幕（Telescreen）</a> 一样。更可怕的是，电幕本身的设计也许也很不良，以至于能观看到你隐私的不止有老大哥，还有可能是黑色产业链下的其他人。如果一个系统有后门，你不能保证知道这个后门的只有你自己。</p><p>这个系统同样必须要是毫无保留开源的，只有把安全问题曝光在太阳之下，才能及时解决这些问题。我希望这是一个自由软件（客户端基于 GPL，服务端基于 AGPL），这有助于每个人更好改进它，或者改造成适合在公司内使用的内部聊天工具。</p><p>基于这点之下，我重新设计了账户系统、聊天系统和群组系统。并期待能在隐私的大前提下去建立一个合适的聊天工具应有的样子。</p><h3 id="账户体系"><a href="#账户体系" class="headerlink" title="账户体系"></a>账户体系</h3><p>账户体系是围绕 GnuPG 设计的，服务器只存储你的公钥信息。如果你丢失了你的私钥或者保护私钥的密码，那么你的账户是完全不可找回的。当你的 key 发生泄漏的情况下，你可以通过吊销证书彻底摧毁掉这个帐号，不提供任何恢复的选项。这个过程直接粗暴，不会有所谓客服介入，以减少社会工程学攻击的可能。吊销前你可以通过没有丢失的设备导出好友列表，但之后依然需要在新帐号重新添加。</p><p>当用户在新设备上登录时，用户会生成一组设备密钥对，并用账户私钥加密存储。之后每次登录则是需要验证账户私钥然后将设备密钥对加载至内存中，关机即销毁。当你登录后，你会和服务器建立连接。当你的好友试图与你通讯时，需要获取你全部登录设备的公钥，将一条信息用自己的私钥签名并用你的全部公钥加密后发送到服务器上，服务器转发给你。这个过程中，服务器除了知道发送者和接收者分别是谁，除此之外的全部信息都无法知晓，以实现点对点加密。</p><p>你除了用户名和头像以外的全部个人信息，包括你的公钥列表都必须在好友添加验证通过后才会被其他人看到，以尽可能减少元信息的泄漏。用户可以在应用中通过便捷的方式导出全部公钥的二维码图像，以便于通过其它信道与发送者检查是否存在 MITM 攻击。</p><h3 id="群组设计"><a href="#群组设计" class="headerlink" title="群组设计"></a>群组设计</h3><p>不同于 Telegram，这个系统的群组聊天同样提供有效的点对点加密，只是实现的机理不太一样。进入群组后，每个人会产生一个群组密钥对，利用其它群员的设备公钥将自己的公钥加密并传输给其它人。每次发送消息时用自己的群组私钥加密并发送出去，其它人用之前收到的公钥进行解密。</p><p>这个过程对于服务器来说同样也是无法知晓的，服务器只负责转发信息。需要注意的一点是，一旦有群组成员被踢出群组，那么这个密钥交换过程必须重置，以避免有问题的服务器将信息继续发送给已经被踢出群的群员后，其依然可以解密的风险。</p><h3 id="守护服务（Daemon-Service）"><a href="#守护服务（Daemon-Service）" class="headerlink" title="守护服务（Daemon Service）"></a>守护服务（Daemon Service）</h3><p>这个设计的一个弊端是你无法同一个没有在线的用户聊天。这是显然的，服务器没有保存你的私钥，发送者也不知道你会用哪个设备查看这条消息。真的是「辛辛苦苦 30 年，一朝回到解放前」，给你一种在使用 NetMeeting 的感觉。</p><p>不过我能想到的一个解决方案是提供一个无头的客户端，允许用户挂在到服务器上 24h 运行以代收消息，其它客户端可以与这个无头客户端同步消息以达到不丢数据的目的。帮助非极客用户提供部署守护服务可以作为官方的一个增值服务以弥补服务器的开支。</p><h2 id="技术栈与开源协议选型"><a href="#技术栈与开源协议选型" class="headerlink" title="技术栈与开源协议选型"></a>技术栈与开源协议选型</h2><p>暂时把这个项目定名字叫 Nyan Chat（猫聊（暂定））</p><p><a href="https://github.com/nyan-chat" target="_blank" rel="noopener">GitHub Organization</a></p><ul><li><a href="https://github.com/nyan-chat/nyan-core" target="_blank" rel="noopener">nyan-core</a> GPLv3 协议。加密的核心实现，Rust 开发，以库的形式加载给其它组件。</li><li><a href="https://github.com/nyan-chat/nyan-api" target="_blank" rel="noopener">nyan-api</a> AGPLv3 协议。API 实现，Ruby 开发，基于 Sinatra、Sequel 和 Ohm，提供一下元信息的交互，以 Redis 作数据交换为主，Postgres 为辅，可水平扩展。</li><li><a href="https://github.com/nyan-chat/nyan-node" target="_blank" rel="noopener">nyan-node</a> AGPL v3 协议。服务端通讯节点实现，Elixir 开发。提供与用户终端的 Socket 连接，与 Redis 通讯快速验证一些元信息。节点间自由通讯，可水平扩展。</li><li><a href="https://github.com/nyan-chat/nyan-desktop" target="_blank" rel="noopener">nyan-desktop</a> GPLv3 协议。目前优先开发的桌面客户端实现，使用 TypeScript 和 Electron。</li><li><a href="https://github.com/nyan-chat/nyan-daemon" target="_blank" rel="noopener">nyan-daemon</a> AGPLv3 协议。Go 语言开发的守护服务。</li></ul><p>开发时间表另定。欢迎有兴趣的人留言讨论具体细节。</p><p>最后分享一个我最近发现的 2016 年在卡杜甘音乐厅演出的《文明 4》主题曲 Baba Yetu 的 Live，非常震撼。</p><iframe width="560" height="315" src="https://www.youtube-nocookie.com/embed/noneMROp_E8" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h2&gt;&lt;p&gt;我考虑重新设计一个即时通讯工具的想法已经很久了，但一直没有付诸于事实。有几个理由让我不得不设计一个新的 IM。我对于我目前正在使用的 IM 
      
    
    </summary>
    
    
      <category term="编程" scheme="https://coderemixer.com/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="开源" scheme="https://coderemixer.com/tags/%E5%BC%80%E6%BA%90/"/>
    
      <category term="猫聊" scheme="https://coderemixer.com/tags/%E7%8C%AB%E8%81%8A/"/>
    
  </entry>
  
  <entry>
    <title>推广方言正字的意义</title>
    <link href="https://coderemixer.com/2019/02/07/chinese-dialect-orthography/"/>
    <id>https://coderemixer.com/2019/02/07/chinese-dialect-orthography/</id>
    <published>2019-02-06T16:26:09.000Z</published>
    <updated>2019-02-06T17:34:09.001Z</updated>
    
    <content type="html"><![CDATA[<h2 id="序"><a href="#序" class="headerlink" title="序"></a>序</h2><p>正字，也就是「正体字」，从正俗的角度来看，与「异体字」相对。虽然台湾的繁体中文常被标榜成「正体中文」，但实际上日常的使用中充斥了各种俗字。比如「群」字「《五經文字》羣，俗作群。」，其实是「羣」的异体字。对于繁体中文的正字化有很多人推动。但我今天有觉得，面对我们使用的方言，比如吴语、粤语、闽南话等正字化的推动是一个更重要的问题。为什么我认为推广方言正字比起官话更重要，我想从我熟悉的一个吴语俗字说起。</p><h2 id="从一个吴语俗字说起"><a href="#从一个吴语俗字说起" class="headerlink" title="从一个吴语俗字说起"></a>从一个吴语俗字说起</h2><p>吴语中有一个词叫「劜闹猛」：</p><table><thead><tr><th>词语</th><th>钱乃荣式上海话拼音方案</th><th>IPA</th></tr></thead><tbody><tr><td>劜闹猛</td><td>ghak nok mang</td><td>/gɐʔ noʔ mᴀ̃/</td></tr></tbody></table><p>是「凑热闹」的意思。</p><p>无论是电视媒体，还是平时使用，都常常被写成「轧闹忙」。这个字和「劜」的读音是一致的，但从意思上来说不太对。根据《康熙字典》：「《廣韻》於黠切《韻會》《正韻》乙黠切，𠀤音扎。《說文》車輾也。《六書故》車載重，蹍軋有聲也。」这里的热闹，怎么想，都和车辗过好像没有什么关系吧。</p><p>一般来说，认为这个正字是「劜」，「《玉篇》勜劜，屈强也。」这个解释就很符合凑热闹的特性。《吴下方言考》卷十一：「吴中以人众不得出而用力挤排为『劜』。」则更是确认了这一观点。然而也并不是没有这么用的，比如用苏白写成的《海上花列传》第 021 回：「俄延多時，翠鳳忽說道：『耐自家算算看，幾花年紀哉。再要去軋姘頭，阿要面孔！』」中的「軋姘頭」就使用了「軋」字。</p><h2 id="使用俗字带来的问题"><a href="#使用俗字带来的问题" class="headerlink" title="使用俗字带来的问题"></a>使用俗字带来的问题</h2><p><img src="/static/hokhang.png" alt="hokhang"></p><p>我们知道杰哥的房里有一些「好康」的。这个「好康」到底指的是什么？如果很多没有接触过闽南语的人甚至会误以为是「好看」的意思。然而这里的「好康」指的是「有好处的」，比如一些特卖资讯也常被叫作「好康资讯」。之所以会有这样的误解，很大程度上就是这里的「康」是个除了读音以外完全无关的俗字。其正确写法是「好空」。</p><table><thead><tr><th>词语</th><th>方音符号</th><th>台罗拼音</th></tr></thead><tbody><tr><td>好空</td><td>ㄏㄜˋㄎㄤ</td><td>hó‑khang</td></tr><tr><td>歹空</td><td>歹ㄆㆮˋㄎㄤ</td><td>pháinn‑khang</td></tr></tbody></table><p>空，细缝。好空，就是基于词的衍生义，有好处的。相应地，歹空就是有坏处的。</p><p>汉字是同时具有意义和读音的，俗字往往只是借用了读音，而失去了汉字本身的意义。这在很多时候也许问题没有那么大，但对于现在各个岌岌可危的方言保护来说，则变得非常严重。</p><p>如果我们的方言只剩下音，而没有了文字本身的意义，那么本质上就是汉语的拉丁化，如果我们还承认那是方块字的话，那其实也只是汉语的「谚文化」而已。在使用谚文的韩语中，「고사」可以指代「故事」、「古寺」、「告祀」、「枯死」等等，在缺乏上下文的情况下，无法理解单词的意思。换句话说，几乎所有反对汉语拉丁化的理由都可以应用于此来反对方言不使用正字上。</p><h2 id="使用正字带来的好处"><a href="#使用正字带来的好处" class="headerlink" title="使用正字带来的好处"></a>使用正字带来的好处</h2><p>事实上，一旦使用正字，我们对方言的理解会变得简单很多。下面是一些闽南话的例子：</p><table><thead><tr><th>词语</th><th>俗字</th><th>方音符号</th><th>台罗拼音</th></tr></thead><tbody><tr><td>練痟話</td><td>練肖話</td><td>ㄌㄧㄢ˫ㄒㄧㄠˋㄨㆤ˫</td><td>liān‑siáu‑uē</td></tr><tr><td>哭爸</td><td>靠北</td><td>ㄎㄠ˪ㄅㆤ˫</td><td>khàu‑pē</td></tr></tbody></table><p>像是「練肖話」听到后，你可能很难反应过来练的到底是什么话，如果望文生义，可能还以为是什么好话。但「痟」是病字头的，指「疯病」。例如「痟人」就是「疯人」，那么「練痟話」毋庸质疑是「练疯话」的意思。</p><p>再比如「靠北」，正字写法是「哭爸」。什么场合下会哭？这里指代的自然是「丧父」的场合。所以非常显而易见，这就是一个以丧父为比喻的骂人语。</p><p>同样的理论，在其它方言中也很适用。比如粤语中，你知毋知道乜係「唔知」呀？（你知道「唔知」是什么吗？）但如果写成本字，「唔」其实是「毋」。</p><table><thead><tr><th>本字</th><th>借字</th><th>粤拼</th><th>IPA</th></tr></thead><tbody><tr><td>毋</td><td>唔</td><td>m⁴</td><td>m̩˩</td></tr></tbody></table><p>自然也就是「不知道」的意思了。</p><p>现在各个地方的方言往往是四十岁以下乱读，四十岁以上乱写。方言正在一步步走进博物馆，而不是走进日常的生活。想比于官话，虽然我们也在使用大量的俗字，但大体上，汉字还是能表达含义的。而方言中单纯标音的俗字已经被极大滥用，甚至脱离读音整句句子都变得没有意义。使用正字可以有效让语言变得更合理，对于使用语言也可以变得更规范，让这些方言从「音」回归到「形」上。</p><h2 id="推广方言正字的难点"><a href="#推广方言正字的难点" class="headerlink" title="推广方言正字的难点"></a>推广方言正字的难点</h2><p>那么听起来推广方言正字那么好，为什么我们很难做这件事呢？这就取决于其正字这件事本身的难度了。事实上，由于年代久远，我们对于什么字是本字是一件很难推断的事。再加上很多方言留下的文字资料很少，甚至一度被认为某些语言是无法书写的。而即使有留下的文字资料，对于文字的不同解读、训诂都会对我们的推断造成很大的影响。有时甚至还会落入循环论证的怪圈里。</p><p>另外有些字年代久远，在现代汉语中用得很少，本字表达也未必清楚。有时也不得不跟从大家的习惯，香港电视台的许多粤语字幕也常常是本字俗字混夹的。</p><p>我的观点上来看，虽然要想完全正确使用方言正字是一件操作上不可能的事情。但是，对于对于正字的探索过程，哪怕是始终悬着一颗要写正字方言的心，确实对于使用、保护方言的工作还是有很大帮助的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;序&quot;&gt;&lt;a href=&quot;#序&quot; class=&quot;headerlink&quot; title=&quot;序&quot;&gt;&lt;/a&gt;序&lt;/h2&gt;&lt;p&gt;正字，也就是「正体字」，从正俗的角度来看，与「异体字」相对。虽然台湾的繁体中文常被标榜成「正体中文」，但实际上日常的使用中充斥了各种俗字。比如「群」
      
    
    </summary>
    
    
      <category term="语言学" scheme="https://coderemixer.com/tags/%E8%AF%AD%E8%A8%80%E5%AD%A6/"/>
    
      <category term="方言" scheme="https://coderemixer.com/tags/%E6%96%B9%E8%A8%80/"/>
    
      <category term="汉语" scheme="https://coderemixer.com/tags/%E6%B1%89%E8%AF%AD/"/>
    
      <category term="吴语" scheme="https://coderemixer.com/tags/%E5%90%B4%E8%AF%AD/"/>
    
      <category term="闽南话" scheme="https://coderemixer.com/tags/%E9%97%BD%E5%8D%97%E8%AF%9D/"/>
    
      <category term="粤语" scheme="https://coderemixer.com/tags/%E7%B2%A4%E8%AF%AD/"/>
    
  </entry>
  
  <entry>
    <title>「为什么我把『は』都听成『わ』了？」</title>
    <link href="https://coderemixer.com/2019/01/19/why-i-hear-all-ha-into-wa/"/>
    <id>https://coderemixer.com/2019/01/19/why-i-hear-all-ha-into-wa/</id>
    <published>2019-01-18T15:07:02.000Z</published>
    <updated>2019-01-19T03:02:26.278Z</updated>
    
    <content type="html"><![CDATA[<p>萌娘百科的<a href="https://zh.moegirl.org/君日本语本当上手" target="_blank" rel="noopener">「君日本语本当上手」</a>里有这么一段描述：</p><blockquote><p>现在该语句常见于目标对象的日语水平不足而引发的低级错误产生笑料时讽刺目标语言能力不足的情况。</p><p>…</p><ul><li>个人日语知识缺乏的情况下发表高谈阔论<ul><li>…</li><li>为什么我把は都听成わ了？</li></ul></li></ul></blockquote><p>「は」做助词时念作「わ」似乎是每个日语学习者遇到的第一个「特例」。似乎每个老师都这么教，读错了别人会笑你，但如果反问其原因，多半只能得到一个形如「约定俗成」这样循环论证的话。</p><p>另外假名的「ハ段」本身听起来就怪怪的，ハヒヘホ发的都是清喉擦音 /h/ 的音，唯独フ却是接近 /ɸ/ 的清双唇擦音。</p><p>然而这个「は」字的来头其实并不小，小小一个字实际上是日语从「上古日语」「中古日语」再到「中世日语」的语音大变革的见证者。</p><h2 id="万叶假名与反切"><a href="#万叶假名与反切" class="headerlink" title="万叶假名与反切"></a>万叶假名与反切</h2><p>有一句话叫「研究语法多看古代日语，学习词汇多看现代日语」，这一句话在这里非常适用，要想了解「は」特殊语法含义时的特殊语音现象，我们却是需要多看一些古代日语。我们翻一下《万葉集 巻第十》二一四五（759 年）</p><p><img src="/static/genryaku-manyoushuu.jpg" alt="genryaku-manyoushuu"><br><strong>Shot By ReijiYamashina. CC 3.0 BY-SA</strong></p><blockquote><p>[原文]秋芽子之 戀裳不盡者 左&lt;壮&gt;鹿之 聲伊續伊継 戀許増益焉 </p><p>[訓読]秋萩の恋も尽きねばさを鹿の声い継ぎい継ぎ恋こそまされ </p><p>[仮名]あきはぎの こひもつきねば さをしかの こゑいつぎいつぎ こひこそまされ </p></blockquote><p>这里的「恋」并没有读成我们熟悉的「こい」而是读成了「こひ」。如果我们查「ひ」的万叶假名（万葉仮名），我们会得到</p><table><thead><tr><th>甲类</th><th>乙类</th></tr></thead><tbody><tr><td>比必卑賓日氷飯負嬪臂避匱</td><td>非悲斐火肥飛樋干乾彼被秘</td></tr></tbody></table><p>我们知道万叶假名是利用汉字的音读和训读来标记日文读音的，那么大致来说，引入时这些汉字的读音应该是和需要读的日文发音是接近的。虽然万叶假名的时间比隋唐更早，但更早我们很难找到相关中文语音资料，我们在这里查这些字在《廣韻》《正韻》等书中的反切读法。</p><table><thead><tr><th>类别</th><th>汉字</th><th>《廣韻》反切</th><th>拟音（王力）</th></tr></thead><tbody><tr><td>甲类</td><td>比</td><td>卑履</td><td>pi</td></tr><tr><td></td><td>必</td><td>卑吉</td><td>pĭĕt</td></tr><tr><td>乙类</td><td>非</td><td>甫微</td><td>pĭwəi</td></tr><tr><td></td><td>悲</td><td>府眉</td><td>pi</td></tr></tbody></table><p>我们发现无论是哪一类，声母在几种常见的拟音中几乎都是发 /p/。上古日语的拟音，是通过同时期古汉语和古琉球语的语音作比较的，所以目前一般也认为上古日语中，「ハ行」发的是 /p/ 这个辅音。</p><h2 id="从塞音到擦音"><a href="#从塞音到擦音" class="headerlink" title="从塞音到擦音"></a>从塞音到擦音</h2><p>然而「ハ行」的发音在公元 9 世纪后的中古日语中发生了巨变。一般认为，在这个过程中，发音的部位没有太大变化，依然是双唇音。但是发音的方式发生了变化，从塞音（爆破音）变成了擦音 /ɸ/。这个音比起 /p/，听起来明显更像唇齿擦音的清音 /f/。也就是说，这个时代的「フ」已经几乎发成现在这个样子了。</p><p>我们之前举的例子「恋」，在这个时期的发音，就已经从 /kopi/ 发成了 /koɸi/。然而这并没有结束。至少在十一世纪时期以前，在词首以外的位置的「ハ行」发音进一步变成了「ワ行」（ハ行転呼）。也就是从擦音变成了双唇近音 /β̞/， /koɸi/ 也就进一步变成了「こゐ」  /koβ̞i/。</p><p>在现代日语中，「ワ行」从双唇近音进一步变成了圆唇化软颚近音 /w/ [ɰʷ]，但这一点变化没有那么大。更大的是，现代日语中，将「ゐ」「ゑ」这两个假名简化掉了，于是「恋（こひ、こゐ）」简化成了今天的样子「こい」。</p><h2 id="は、へ-与现代假名遣（現代仮名遣い）"><a href="#は、へ-与现代假名遣（現代仮名遣い）" class="headerlink" title="は、へ 与现代假名遣（現代仮名遣い）"></a>は、へ 与现代假名遣（現代仮名遣い）</h2><p><img src="/static/gendaikanazukai.jpg" alt="gendaikanazukai"></p><p>从刚刚的发展过程中我们知道，所有原先的「ハ行」都在历史的发展中转化成了「ワ行」或者「ア行」。现在所有「ハ行」的词几乎（合成语除外），均为自镰仓时代以来形成的词。并且读音也变得更接近于 /h/ 的读音。以前发「ハ行」的词都已经不复存在。</p><p>为了规范读音，日本政府于 1946 年和 1986 年提出和修订了称之为<a href="http://www.mext.go.jp/b_menu/hakusho/nc/k19860701001/k19860701001.html" target="_blank" rel="noopener">「現代仮名遣い」</a>的内阁告示。其中的一个原则就是「按照现代的音韵来书写假名」。于是像是「川」「恋」也分别从「かは」「こひ」正式变成了我们熟悉的「かわ」「こい」的形式。</p><p><strong>但是，有一些例外！</strong></p><p>助词「は」「へ」「を」虽然读音已经发生了改变，但写法保持不变。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这也就是今天我们学习日语「ハ行」的「フ」发成了 /ɸ/，因为它保留了「ハ行」之前的读音。而「は」「へ」读成「わ」「え」则是ハ行转呼（ハ行転呼）的影响。</p><p>「为什么我把『は』都听成『わ』了？」</p><p>这看起来非常愚蠢的问题，不但揭示了语言的例外产生的各种巧合，也展示了日语语音在几百年来的发展历程。这问题深奥得很。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;萌娘百科的&lt;a href=&quot;https://zh.moegirl.org/君日本语本当上手&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;「君日本语本当上手」&lt;/a&gt;里有这么一段描述：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;现在该语句常见于目标对象的日语
      
    
    </summary>
    
    
      <category term="语言学" scheme="https://coderemixer.com/tags/%E8%AF%AD%E8%A8%80%E5%AD%A6/"/>
    
      <category term="日语" scheme="https://coderemixer.com/tags/%E6%97%A5%E8%AF%AD/"/>
    
  </entry>
  
  <entry>
    <title>平成最后的烂尾游戏——东京地下铁 2018 解谜游戏设计分析</title>
    <link href="https://coderemixer.com/2019/01/10/heisei-last-unfinished-game/"/>
    <id>https://coderemixer.com/2019/01/10/heisei-last-unfinished-game/</id>
    <published>2019-01-10T11:58:25.000Z</published>
    <updated>2019-01-10T12:09:09.717Z</updated>
    
    <content type="html"><![CDATA[<h2 id="序"><a href="#序" class="headerlink" title="序"></a>序</h2><p>这个几年来久闻东京地下铁解谜游戏的大名，一支没有完整地体验一下这个游戏。终于在去年年底的时候尝试了一下这款游戏。体验下来的感觉褒贬不一，所以我打算从游戏设计的角度，系统地来聊一聊这款游戏。</p><p><img src="/static/tokyo-metro-2018.jpg" alt="tokyo-metro-2018"></p><h2 id="游戏简介"><a href="#游戏简介" class="headerlink" title="游戏简介"></a>游戏简介</h2><p>游戏的基本流程就是在你购买完游戏套件（Kit）后，从你所在的车站开始，利用套件里提供的道具与车站及附近的现实场景进行交互，从而获得线索一步一步解开谜题。</p><p>游戏的设计公司是「SCRAP」，这家公司设计了大量类似的现实解谜游戏<a href="http://realdgame.jp/" target="_blank" rel="noopener">「リアル脱出ゲーム」</a>。游戏的监督是毕业于京都大学的<a href="https://www.facebook.com/hikaru.sakaidani" target="_blank" rel="noopener">「堺谷 光」</a>，在查阅资料的过程中找到了他的一篇游戏设计<a href="https://arxiv.org/pdf/1306.4884.pdf" target="_blank" rel="noopener">论文</a>，这篇论文对简单的 Tic Tac Toe 游戏进行发展，实现了一个策略复杂的棋类游戏，并对游戏数值进行了建模和演算。在游戏过程中，我感到了一种非常类似的<a href="https://zh.wikipedia.org/zh/%E6%A8%A1%E8%BF%9B" target="_blank" rel="noopener">「模进（Sequentia）」</a>发展的感觉，游戏设计了一些最基本的谜题思路（动机），通过在重复、变换和组合实现一个非常激动人心的游戏体验。</p><h2 id="分支与引导设计"><a href="#分支与引导设计" class="headerlink" title="分支与引导设计"></a>分支与引导设计</h2><p>游戏的一个 Puzzle 是一个基于鬼脚图（阿弥陀籤）变化的游戏。和鬼脚图不同的地方是，每个连接处都有一个图形。而游戏提示有一个图形不能被通过，而这时就引入了游戏中的第一个引导设计。在游戏的描述中希望你在 MINITIA 糖上找到一个黑色的图形，而这个图形就是那个不能被通过的图形。游戏的第二个谜题则是和网站上的<a href="http://realdgame.jp/chikanazo/5/renshu/index.html" target="_blank" rel="noopener">「練習問題」</a>类似的设计，通过メトロ的站名与编号之间的转换来解开谜题。</p><p>这里给出了游戏第一个设计上的巧思。第一、因为这个 MINITIA 糖就出现在了游戏提供的套件中，隐含了游戏的第一个要点「你需要巧妙使用套件里的东西」。第二、游戏套件封面上有站点的地图，并标出了游戏所有可能发生的车站站名，查询车站编号时无疑这里查起来更快。然而，对于鬼脚图谜题实际上一共只有 4 个图形，试一下就做出来了；而车站名谜题 Google 一下也有了。于是这两处引导显得非常不必需，而一旦错过，却在之后会非常痛苦。</p><p>经过了第一、第二个谜题，游戏进入了分支路线。玩家可以从三对地点中选择自己的分支。由于我从新宿站出发，我选择的是四谷和千駄木。这一点很好照顾了不同出发地点的玩家。与其说是分支，不如说是聚合，把不同地方开始的玩家，通过不同的引导方式，最终指引到唯一的地方去。这种设计非常值得 Ingress Mission Day 设计，Ingress 目前的线下活动，要么是线性的，要么就是无顺序的，使得游戏体验很难在乐趣和多元间达到平衡，而这处分支引导，则是一个非常柔性却非常有效的多路线设计。</p><h2 id="i18n-设计"><a href="#i18n-设计" class="headerlink" title="i18n 设计"></a>i18n 设计</h2><p>需要提到的是，这个游戏设计了双语的版本，提供了日本语和英语两个游戏选项。我手上的谜题是英文版的。游戏的设计者试图在抹平这两者的差异，但实际上两者的游戏难度却有很大的不同。这一点从我面临的第三、第四个难题（Mission 1）中有很大的体现。游戏设计者在此处大量设计了字谜，而日语字谜和英语字谜的原理有很大的不同。</p><p>日语的每个字母（仮名）都是一个音节，而英语的每个音节长短不一，且字母到音位并不是一个严格的映射关系。（P.S 谁真的严格按照 <a href="https://ai.googleblog.com/2017/12/tacotron-2-generating-human-like-speech.html" target="_blank" rel="noopener">Google Tacotron 2 论文</a>里描述的方法去训练 TTS AI 的，都尝过苦头吧）这使得凡是涉及字谜的部分，英文都变得简单很多。因为你非常容易通过排列组合上的尝试排除掉大量的选项。</p><p>这个问题最严重的地方就在于 Mission 2，直接把一个现实游戏变成了一款「云游戏」。虽然我知道我要去「京橋駅」解这个谜题，然而只需简单排列组合一下，我就直接解开了这个谜题。这一点在最终谜题（Final Mission）时也会得到体现。这一点我会在之后进一步提及。</p><h2 id="渐强设计"><a href="#渐强设计" class="headerlink" title="渐强设计"></a>渐强设计</h2><p>随着解开 Mission 2，游戏会通过一个过渡任务将你引向一个非常综合性的挑战。这个过渡任务是个纸笔游戏，并且介绍了游戏中纸张与笔的妙用（这一点在之后会被进一步用到）。在完成过渡游戏后，游戏会把你带到「渋谷」。</p><p>然后，在涩谷地下大迷宫里大暴走的可怕时间就到来了。然而一上来就给我玩了一处高级的，由于渋谷マークシティ正在进行促销活动，巨幅海报遮挡住了游戏正常流程中的必备道具，只在旁边放上一个很小的告示牌。涩谷的这个谜题非常综合，几乎要用到套件里的所有道具。这似乎是一个劝退点，如果不能解出这个谜题，几乎无法进行更后面的挑战，可以直接选择放弃。（于是在某个挑战进行的自動販売機前挤满了各种试图寻找答案的人（完全是迷惑行为吧））</p><p>这个谜题的体验非常好，几乎是这个游戏中让人觉得最巧妙的地方。</p><h2 id="Final-Mission-难度分支"><a href="#Final-Mission-难度分支" class="headerlink" title="Final Mission 难度分支"></a>Final Mission 难度分支</h2><p><img src="/static/tokyo-metro-final-project.jpg" alt="tokyo-metro-final-project"></p><p>在完成上述挑战后，游戏会给你一个过渡字谜游戏。这个字谜游戏我认为是这个游戏非常好的设计，却是非常糟糕的实践。这个谜题根据你前往终极问题的路上每站一个小字谜的解题表现，来决定你终极问题的难度。作为一个解谜游戏，又要做成一款阖家欢乐的游戏是非常难的，很难同时讨好解谜硬核玩家和休闲玩家。从想法上来说非常好。实践上糟糕的地方在于，题目描述得有问题，很多人甚至都没有看懂题目。而这个题目的糟糕之处更在于，在没看懂题目的情况下你竟然还可以正常做完。</p><p>但无论如何，这个谜题很好维持了完成综合性谜题后通往终极问题的紧张感。让你知道前方会有一个非常激动人心的挑战。</p><p>Final Mission 谜题的第一步被设计成一个迷你数独，虽然我没有严格证明一下，但大致可以确定是一个 NP Complete 问题。而根据 S、A、B 难度不同，谜题的已知部分不一样。我完成的是 S Rank 的 Final Mission 挑战，按理说应该很难，而且通过人来解一个很难的 NPC 问题，应该会耗费很大的精力。但这时候就要提到游戏刚刚那个 i18n 的败笔。我单纯排列组合一下，就直接找到了 Final Mission 的答案。</p><p>在提交答案后，游戏最后对你手上的手册提出最后的谜题，在一系列纸币的综合挑战后，游戏就正式完成，给你播放通关动画。而这又带来了游戏的第二个大败笔，所谓的难度分支根本就形同虚设，无论你选择什么难度，在通关过程中没有任何差别。这使得游戏渐强然后慢慢达到解谜的高潮的感觉完全违背，突然而来的结局，就好像小说写不下去突然把所有人都写死一样让人崩溃。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><img src="/static/tokyo-metro-2018-time.jpg" alt="tokyo-metro-2018-time"></p><p>从游戏开始的 10 点到最后通关的下午 5 点，整个游戏流程不满 7 个小时，期间看了三次的 Hint。游戏难度设计上我认为还是适中的，但也不是人人可以通关的难度。游戏的整体流程设计和铺垫可圈可点。但是由于游戏设计的重心失衡，和 i18n 设计上的严重失误，使得游戏体验并不算很完美。</p><p>通过这个游戏，我觉得我可以关注一下 SCRAP 其它的<a href="http://realdgame.jp/" target="_blank" rel="noopener">「リアル脱出ゲーム」</a>，至少这个游戏的形式设计得还是不错的。如果剧本能够更平衡一些，或者引入一些主线剧情想必会更好。另外就是，如果可以，我希望明年体验一下日文版的游戏，说不定会有更好的体验。</p><p>另外就是，我们神奈川乡下人进一次城真不容易。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;序&quot;&gt;&lt;a href=&quot;#序&quot; class=&quot;headerlink&quot; title=&quot;序&quot;&gt;&lt;/a&gt;序&lt;/h2&gt;&lt;p&gt;这个几年来久闻东京地下铁解谜游戏的大名，一支没有完整地体验一下这个游戏。终于在去年年底的时候尝试了一下这款游戏。体验下来的感觉褒贬不一，所以我打算从
      
    
    </summary>
    
    
      <category term="游戏" scheme="https://coderemixer.com/tags/%E6%B8%B8%E6%88%8F/"/>
    
      <category term="设计" scheme="https://coderemixer.com/tags/%E8%AE%BE%E8%AE%A1/"/>
    
      <category term="混合现实" scheme="https://coderemixer.com/tags/%E6%B7%B7%E5%90%88%E7%8E%B0%E5%AE%9E/"/>
    
  </entry>
  
  <entry>
    <title>Ant Design 错了吗？</title>
    <link href="https://coderemixer.com/2018/12/25/is-antd-wrong/"/>
    <id>https://coderemixer.com/2018/12/25/is-antd-wrong/</id>
    <published>2018-12-25T13:43:54.000Z</published>
    <updated>2018-12-25T14:01:50.354Z</updated>
    
    <content type="html"><![CDATA[<h2 id="引"><a href="#引" class="headerlink" title="引"></a>引</h2><p>Ant Design 今天的<a href="https://github.com/ant-design/ant-design/issues/13848" target="_blank" rel="noopener">圣诞门</a>闹得沸沸扬扬，Ant Design 内建的圣诞彩蛋在各个使用 antd 的产品中被「强制」弹出，令许多人措手不及，造成了很大的社会影响。但事实上，Ant Design 使用的是 MIT LICENSE，完全是一个使用者「后果自负」的协议。然而，Issue 里哭天喊地要开发者「负责」的舆论却又一面倒。</p><p>在此，我要问一个问题：「Ant Design 错了吗？」</p><p>​<img src="/static/is-ali-wrong.jpg" alt="is-ali-wront"></p><p>就我来看，毋庸置疑，错了。</p><p>但这篇文章讨论的是以下几点：</p><ul><li>Ant Design 犯了什么错？</li><li>开源的权利与责任的界限在哪里？</li><li>我们应当怎么从这个事件中获取教训？</li></ul><h2 id="Ant-Design-犯了什么错？"><a href="#Ant-Design-犯了什么错？" class="headerlink" title="Ant Design 犯了什么错？"></a>Ant Design 犯了什么错？</h2><p>从产品的角度来看，这个彩蛋，连彩蛋的定义都不符合。彩蛋（Easter Eggs）是一个隐藏在程序中的信息，而不是突然糊在你脸上的定时炸弹。所以从想出这个问题的那个人就已经不太对劲了。但我们抛开这个产品的问题，从实现上，这个 <code>Santa.jsx</code> 文件也同样是非常糟糕。作为一个组件级项目，很多人会对组件样式做二次开发，这一坨硬编码（Hardcoded）并没有起到它彩蛋的作用，相反还把很多网站弄得一团糟。如果你试图阅读过 Ruby 的代码，你往往会发现 Ruby 有那么多错误命名的 C API 为什么一直不把它改对呢？因为这种语言级别的东西，你无法确定用户是怎么使用的时候，就必须保持最低限度的兼容。Ant Design 也是如此。</p><p>然而「人主之患在莫之应，故曰：一手独拍，虽疾无声。」导致 Ant Design 问题的，不单单是彩蛋本身的错，更大的是 Ant Design 开源社区开发流程的问题。或者换一句话说：是软件工程的问题。</p><p>如果我们现在要往一个开源项目中加入一个不合适的东西，其实并不那么容易。Ant Design 有基于 GitHub Pull Request 系统的 Code Review 机制。一个并非紧急的代码，为什么可以直接跳过 Code Review 直接推上去？Ant Design 作为一个组件级的基础项目，到底应该怎么设计测试？</p><p>这个 <a href="https://github.com/ant-design/ant-design/commit/f706e2554f706b4e47f0c0cb3bcada1fe24dc32d" target="_blank" rel="noopener">2017 年 12 月 25 日</a> 写下的代码，写入到发作的这一年中，暴露的并不是谁的错，而是这个项目本身就是一个错误。</p><h2 id="如何运行一个开源项目？"><a href="#如何运行一个开源项目？" class="headerlink" title="如何运行一个开源项目？"></a>如何运行一个开源项目？</h2><p>Ant Design 错了，需要检讨，需要反省，需要道歉。但另一方面，在 Issue 下大骂「要阿里负责，要阿里赔偿」的则是走向了另一个极端。今天的开源项目，在使用常见的 Copyleft 许可证的情况下，大多数（包含且不止包含 MIT、BSD、GPLv2、GPLv3、AGPLv3、LGPLv3、MPL 2.0、Apache License 2.0、The Unlicensed）都在许可证中明确写了，不包括任何保修的条款，使用者自行负责。这让很多人听起来匪夷所思，觉得 Ant Design 一个阿里的产品，怎么也是阿里在背书。然而事实上，可能除了信誉，没有规定任何东西是实质的背书。前几天有人在 Ruby China 上开了个<a href="https://ruby-china.org/topics/37902" target="_blank" rel="noopener">帖子</a>问：</p><blockquote><p>到某某网站上浏览时，发现上面说，以上版本均需获取商业授权，方可做商业运营使用，既然是开源的，咋还涉及到商业授权啊，不理解，请指教。谢谢！</p></blockquote><p>然而版权的实际情况却恰恰相反。源代码放出来只是让你看，并不能让你用。就像别人放在那里的芒果，你不能寻思是别人不要了吧。代码是不是开源，需要取决于使用什么授权协议。哪怕是 GPL 的 RedHat 也有卖商业服务的。如果人家没有设定任何授权协议的话，那就只能默认是 Copyright 私有了。而只有签了具体包含保修责任的条款的协议后，对方才有保修的义务。不然，我自己写着玩开源出来，你用的时候也已经同意免责了。你用出问题了为什么要来找我呢？有问题你自己 fork 了改不就好了？</p><p>这就牵扯到了另一个问题：开源的社会价值。当一个开源产品，比如 Ant Design，有大量的用户在使用的时候，对于这个开源社区的期待是完全不同的。这也是为什么世界上大多数的大型开源项目，都有一个庞大的组织在维护着。其目的很大程度上，就是要维护代码的可靠性，担负起其社会价值。<del>你觉得阿里价值观能担负起社会价值吗？</del></p><p>有人在我微博下呛：</p><blockquote><p>照右边这个逻辑的话，广大 MIT 框架作者应该纷纷往自己代码加挖矿，这世界不需要开源，人与人也不需要信任。别人写好的高级语言也别用啊，一起汇编起来。</p></blockquote><p>然而事实上，如果你愿意找一下，GitHub 上许多 MIT 项目是有暗藏挖矿的，甚至还有暗藏后门的。至于「别人写好的高级语言也别用啊」也是如此，UNIX 创始人 Ken Thompson 在 30 年前获得图灵奖的获奖演说中，就有提到这种类似的暗藏在 C 语言编译器中的手段实现攻击。这也是为什么一方面 C 语言编译器也有一套复杂的自举发布流程，像 gcc 还会有严格的代码审查机制来避免这种问题的发生。然而甚至硬件本身，也不是 100% 可信的。这不是「人与人的信任」问题，相反，就算 100% 相信别人不去做坏事，但是由于人都会犯错，总会做出错误的东西，我们需要的是通过机制来避免它发生。</p><p>在以前一个非常有名的 NVIDIA 开源驱动的维护项目 <a href="https://github.com/MrMEEE/bumblebee-Old-and-abbandoned/issues/123" target="_blank" rel="noopener">bumblebee</a> 中就有出现过开发者疏失，导致更新的用户直接把所有的 <code>/usr</code> 用户文件不小心删了个精光。甚至<a href="https://www.omgubuntu.co.uk/2013/11/nsa-ask-linus-torvalds-include-backdoors-linux-father-says-yes" target="_blank" rel="noopener">有人</a>曾试图通过给 Linux 项目提交 patch 的形式，将后门埋入操作系统中。并且这些看起来不经意的错误，甚至会使得一些人为的 Code Review 失效，所以 Linux 还有复杂的安全性和回归测试来保证其可靠性。</p><p>如果这不是无意的行为，而是有意的。那么对于开源世界，我们有个更简单的方法：fork。我们只要分叉一个自己的版本，自己维护自己负责就可以了。MySQL 被 Oracle 收购后，虽然 Oracle 暂时还没有做什么坏事，大家为了谨防这种情况发生，就有一些开发者 fork 出了 MariaDB。</p><p>但是，我也反过来问一句：你 fork 后的项目，你真的能维护得更好吗？</p><p>软件工程是一个复杂而庞大的东西，把七个积木搭在一起，和把七千万块积木堆在一起是完全不同的系统工程问题。开源软件的管理看起来松散，于是更需要设计合理的制度防范于未然。在挑选开源项目的时候，并不只是挑一个能用的就行了，对于其质量、维护能力、开源协议都必须是评估的内容。我不是在说「用开源的东西不审查代码，出了问题活该」，但是什么都不看，不出问题才奇怪吧？</p><h2 id="教训"><a href="#教训" class="headerlink" title="教训"></a>教训</h2><p>为什么包括谷歌微软在内的大公司，在使用别人的开源项目时，都要经过内部审查。虽然不至于精确到每行代码，但也要大致确认一下这个项目的状况。这也是为什么，Facebook 之前内部许可证事件沸沸扬扬，因为这真的很重要。就好像，警察在努力阻止盗窃案的发生，但我们自身平时就要做好防范，而不能大门敞开，出了事去骂警察吧。</p><p>然而现实的情况却是，用 Ant Design 的本来就是一群想用个组件库草草了事的人，根本没有可能去参与到开源项目的审查中。而 Ant Design 目前草率的开发流程，确实也无法承担如此大的社会责任。如果今天不是「偏右」的圣诞节代码出了问题，明天后天一样会出别的问题。如果今天是「偏右」辞退就来平息风波，那么明天后天 Ant Design 还是会继续出问题（<del>毕竟是阿里嘛</del>）。</p><p>​<img src="/static/judge.png" alt="judge"></p><p>今天 Ant Design 的问题是一个典型的软件工程问题，让任何一个个人来负责，都只是息事宁人的策略，并不能从根本上解决问题。对于一个「开发公司 HR 工具的离职谈话功能推到开发者头上；匿名表达对老员工，特别是对彭姓员工不满，大老板可能含沙射影地让你滚；用脚本在公司网站抢月饼，可能违反价值观」的公司，你指望它在软件工程上有秩序吗？</p><p>我觉得你在做梦。</p><p>总结一下：</p><ul><li>开源项目本身并没有所谓的「责任」的概念，你要有自己评估其可靠性的能力，并承担风险。</li><li>评估可靠性不在于其背后是多大的公司，更在于其是否有健全的开发流程，因为人为疏失不可避免。</li><li>越是底层、组件级的项目对于可靠性的要求越高。</li><li>只要不是主观上故意犯错误，我们更应该检讨我们的系统工程，而不单单是检讨个人。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;引&quot;&gt;&lt;a href=&quot;#引&quot; class=&quot;headerlink&quot; title=&quot;引&quot;&gt;&lt;/a&gt;引&lt;/h2&gt;&lt;p&gt;Ant Design 今天的&lt;a href=&quot;https://github.com/ant-design/ant-design/issues/138
      
    
    </summary>
    
    
      <category term="阿里巴巴" scheme="https://coderemixer.com/tags/%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B4/"/>
    
      <category term="前端" scheme="https://coderemixer.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="开源" scheme="https://coderemixer.com/tags/%E5%BC%80%E6%BA%90/"/>
    
  </entry>
  
  <entry>
    <title>[Ruby Quiz] Base32 字母表 —— 加密猫基因解码</title>
    <link href="https://coderemixer.com/2018/12/08/ruby-quiz-base32/"/>
    <id>https://coderemixer.com/2018/12/08/ruby-quiz-base32/</id>
    <published>2018-12-08T01:54:43.000Z</published>
    <updated>2018-12-08T01:58:48.756Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/static/cryptokitties.png" alt="Crypto Kitties"></p><p>刚刚在 ruby-talk 的邮件列表读到一个很有意思的 Ruby Quiz，题目可以<a href="https://github.com/planetruby/quiz/tree/master/008" target="_blank" rel="noopener">见此</a>。想到好久没有看到 Ruby Quiz 了，就做了并翻译了一下。</p><h2 id="题目翻译"><a href="#题目翻译" class="headerlink" title="题目翻译"></a>题目翻译</h2><p>庆祝 CryptoKitties 一周年 —— 区块链上诞生了超过 100 万只可爱的小猫！</p><p>我们来尝试转换 “sekretoooo” 加密猫的基因，一个 240 位的整数，以每 5 位进行分割，再通过 base32 (2^5=32) 进行转换，转至 kai 标注。</p><p>Q: 什么是 kai 标注？</p><p>Kai 标注（因为 <a href="https://medium.com/@kaigani/the-cryptokitties-genome-project-on-dominance-inheritance-and-mutation-b73059dcd0a4" target="_blank" rel="noopener">Kai Turner</a> 解码了加密猫的基因而命名）是一种针对 240 位整数分割成 5 位块的 base58 的变种（子集）。每个 5 位块含有 32 种可能性，240 位基因可以给分割成 12 组，每组 4 (x 5 位）基因。</p><p>举例：</p><table><thead><tr><th>Kai</th><th>Binary</th><th>Num</th><th>Kai</th><th>Binary</th><th>Num</th><th>Kai</th><th>Binary</th><th>Num</th><th>Kai</th><th>Binary</th><th>Num</th></tr></thead><tbody><tr><td><strong>1</strong></td><td>00000</td><td>00</td><td><strong>9</strong></td><td>01000</td><td>08</td><td><strong>h</strong></td><td>10000</td><td>16</td><td><strong>q</strong></td><td>11000</td><td>24</td></tr><tr><td><strong>2</strong></td><td>00001</td><td>01</td><td><strong>a</strong></td><td>01001</td><td>09</td><td><strong>i</strong></td><td>10001</td><td>17</td><td><strong>r</strong></td><td>11001</td><td>25</td></tr><tr><td><strong>3</strong></td><td>00010</td><td>02</td><td><strong>b</strong></td><td>01010</td><td>10</td><td><strong>j</strong></td><td>10010</td><td>18</td><td><strong>s</strong></td><td>11010</td><td>26</td></tr><tr><td><strong>4</strong></td><td>00011</td><td>03</td><td><strong>c</strong></td><td>01011</td><td>11</td><td><strong>k</strong></td><td>10011</td><td>19</td><td><strong>t</strong></td><td>11011</td><td>27</td></tr><tr><td><strong>5</strong></td><td>00100</td><td>04</td><td><strong>d</strong></td><td>01100</td><td>12</td><td><strong>m</strong></td><td>10100</td><td>20</td><td><strong>u</strong></td><td>11100</td><td>28</td></tr><tr><td><strong>6</strong></td><td>00101</td><td>05</td><td><strong>e</strong></td><td>01101</td><td>13</td><td><strong>n</strong></td><td>10101</td><td>21</td><td><strong>v</strong></td><td>11101</td><td>29</td></tr><tr><td><strong>7</strong></td><td>00110</td><td>06</td><td><strong>f</strong></td><td>01110</td><td>14</td><td><strong>o</strong></td><td>10110</td><td>22</td><td><strong>w</strong></td><td>11110</td><td>30</td></tr><tr><td><strong>8</strong></td><td>00111</td><td>07</td><td><strong>g</strong></td><td>01111</td><td>15</td><td><strong>p</strong></td><td>10111</td><td>23</td><td><strong>x</strong></td><td>11111</td><td>31</td></tr></tbody></table><p><strong>注意：数字 0 和字母 l 不会在 kai 中被使用。</strong></p><p>我们开始编程吧！举例来说：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># A 240-bit super "sekretoooo" integer genome</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># hexadecimal (base 16)</span></span><br><span class="line">genome = <span class="number">0x4a52931ce4085c14bdce014a0318846a0c808c60294a6314a34a1295b9ce</span></span><br><span class="line"><span class="comment"># decimal (base 10)</span></span><br><span class="line">genome = <span class="number">512955438081049600613224346938352058409509756310147795204209859701881294</span></span><br><span class="line"><span class="comment"># binary (base 2)</span></span><br><span class="line">genome = 0b01001010010100101001001100011100111001000000100001011100000101001011110111001110000000010100101000000011000110001000010<span class="number">0</span>\</span><br><span class="line">           <span class="number">011010100000110010000000100011000110000000101001010010100110001100010100101000110100101000010010100101011011100111001110</span></span><br></pre></td></tr></table></figure><p>我们可以把 10 进制数转换成 16 进制或 2 进制数：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">p genome    <span class="comment"># printed as decimal (base 10) by default</span></span><br><span class="line"><span class="comment"># =&gt; 512955438081049600613224346938352058409509756310147795204209859701881294</span></span><br><span class="line"></span><br><span class="line">p genome.to_s(<span class="number">16</span>)</span><br><span class="line"><span class="comment"># =&gt; "4a52931ce4085c14bdce014a0318846a0c808c60294a6314a34a1295b9ce"</span></span><br><span class="line"></span><br><span class="line">p genome.to_s(<span class="number">2</span>)</span><br><span class="line"><span class="comment"># =&gt; "10010100101001010010011000111001110010000001000010111000001010010111101110011100000000101001010000000110001100010000100\</span></span><br><span class="line"><span class="comment">#     011010100000110010000000100011000110000000101001010010100110001100010100101000110100101000010010100101011011100111001110"</span></span><br><span class="line"></span><br><span class="line">bin = <span class="string">'%0240b'</span> % genome     <span class="comment"># note: adds leading zeros - to_s(2) does not</span></span><br><span class="line">p bin.size</span><br><span class="line"><span class="comment"># =&gt; 240</span></span><br><span class="line">p bin</span><br><span class="line"><span class="comment"># =&gt; "010010100101001010010011000111001110010000001000010111000001010010111101110011100000000101001010000000110001100010000100\</span></span><br><span class="line"><span class="comment">#     011010100000110010000000100011000110000000101001010010100110001100010100101000110100101000010010100101011011100111001110"</span></span><br><span class="line"></span><br><span class="line">hex = <span class="string">'%060x'</span> % genome     <span class="comment"># note: adds leading zeros - to_s(16) does not</span></span><br><span class="line">p hex.size</span><br><span class="line"><span class="comment"># =&gt; 60</span></span><br><span class="line">p hex</span><br><span class="line"><span class="comment"># =&gt; 60</span></span><br><span class="line"><span class="comment"># =&gt; "4a52931ce4085c14bdce014a0318846a0c808c60294a6314a34a1295b9ce"</span></span><br></pre></td></tr></table></figure><p>最终要得到的效果是：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">kai = kai_encode( genome )   <span class="comment">## number to base32 kai notation</span></span><br><span class="line">p kai</span><br><span class="line"><span class="comment"># =&gt; "aaaa788522f2agff16617755e979244166677664a9aacfff"</span></span><br></pre></td></tr></table></figure><p>挑战：创建 <code>kai_encode</code> 方法并通过 RubyQuizTest :-).</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">kai_encode</span><span class="params">( num )</span></span></span><br><span class="line">  <span class="comment"># ...</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>对于 Level 1 挑战，你需要把 240 位整数转换成 Base 32 的 Kai 标注。<br>对于 Level 2 挑战，你要把结果 4 个 4 个进行分组，将</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"aaaa788522f2agff16617755e979244166677664a9aacfff"</span></span><br></pre></td></tr></table></figure><p>转换成</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"aaaa 7885 22f2 agff 1661 7755 e979 2441 6667 7664 a9aa cfff"</span></span><br></pre></td></tr></table></figure><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">kai_fmt</span><span class="params">( kai )</span></span></span><br><span class="line">  <span class="comment"># ...</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>你可以从头开始编码，也可以使用任何你想用的库 / gem。你需要通过如下的测试：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">require</span> <span class="string">'minitest/autorun'</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RubyQuizTest</span> &lt; MiniTest::Test</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">################################</span></span><br><span class="line">  <span class="comment"># test data</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">genomes</span></span></span><br><span class="line">     [</span><br><span class="line">       [<span class="number">0x00004a52931ce4085c14bdce014a0318846a0c808c60294a6314a34a1295b9ce</span>,</span><br><span class="line">        <span class="string">"aaaa 7885 22f2 agff 1661 7755 e979 2441 6667 7664 a9aa cfff"</span>]</span><br><span class="line">     ]  </span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">#############</span></span><br><span class="line">  <span class="comment"># tests</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">test_kai_encode</span></span></span><br><span class="line">    genomes.each <span class="keyword">do</span> <span class="params">|pair|</span></span><br><span class="line">      num       = pair[<span class="number">0</span>]</span><br><span class="line">      exp_value = pair[<span class="number">1</span>].gsub(<span class="string">' '</span>,<span class="string">''</span>)   <span class="comment"># note: remove spaces</span></span><br><span class="line"></span><br><span class="line">      assert_equal exp_value, kai_encode( num )</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">end</span> <span class="comment"># method test_kai_encode</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">test_kai_fmt</span></span></span><br><span class="line">    genomes.each <span class="keyword">do</span> <span class="params">|pair|</span></span><br><span class="line">      kai       = pair[<span class="number">1</span>].gsub(<span class="string">' '</span>,<span class="string">''</span>) <span class="comment"># remove spaces</span></span><br><span class="line">      exp_value = pair[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">      assert_equal exp_value, kai_fmt( kai )</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">end</span> <span class="comment"># method test_kai_fmt</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span> <span class="comment"># class RubyQuizTest</span></span><br></pre></td></tr></table></figure><p>注：对于解码后与基因的对应关系表实在太长了，而且和题目无关。如果想看可以查<a href="https://github.com/planetruby/quiz/blob/master/008/README.md" target="_blank" rel="noopener">原文</a>。</p><h2 id="剧透时间"><a href="#剧透时间" class="headerlink" title="剧透时间"></a>剧透时间</h2><p>我想出来的使用 Ruby 的一行解：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">kai_encode</span><span class="params">(num)</span></span></span><br><span class="line">  num.to_s(<span class="number">2</span>).rjust(<span class="number">240</span>, <span class="string">'0'</span>).scan(<span class="regexp">/.&#123;5&#125;/</span>).map &#123;<span class="params">|n|</span> <span class="string">'123456789abcdefghijkmnopqrstuvwx'</span>[n.to_i(<span class="number">2</span>)]&#125;.join</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">kai_fmt</span><span class="params">(kai)</span></span></span><br><span class="line">  kai.scan(<span class="regexp">/.&#123;4&#125;/</span>).join(<span class="string">' '</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">kai_encode(<span class="number">0x00004a52931ce4085c14bdce014a0318846a0c808c60294a6314a34a1295b9ce</span>) <span class="comment"># =&gt; "aaaa788522f2agff16617755e979244166677664a9aacfff"</span></span><br><span class="line">kai_fmt(kai_encode(genome)) <span class="comment"># =&gt; "aaaa 7885 22f2 agff 1661 7755 e979 2441 6667 7664 a9aa cfff"</span></span><br></pre></td></tr></table></figure><p>好在 Ruby 的 <code>rjust</code> 方法是内建的，而不需要 import 一个叫 <code>left-pad</code> 的包，一旦被删除了就天下大乱了（逃</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/static/cryptokitties.png&quot; alt=&quot;Crypto Kitties&quot;&gt;&lt;/p&gt;
&lt;p&gt;刚刚在 ruby-talk 的邮件列表读到一个很有意思的 Ruby Quiz，题目可以&lt;a href=&quot;https://github.com/
      
    
    </summary>
    
    
      <category term="Ruby" scheme="https://coderemixer.com/tags/Ruby/"/>
    
      <category term="Ruby Quiz" scheme="https://coderemixer.com/tags/Ruby-Quiz/"/>
    
  </entry>
  
  <entry>
    <title>十分钟速通 Y Combinator</title>
    <link href="https://coderemixer.com/2018/12/07/y-combinator-in-ten-minutes/"/>
    <id>https://coderemixer.com/2018/12/07/y-combinator-in-ten-minutes/</id>
    <published>2018-12-07T07:44:33.000Z</published>
    <updated>2019-01-19T03:34:13.175Z</updated>
    
    <content type="html"><![CDATA[<h2 id="引"><a href="#引" class="headerlink" title="引"></a>引</h2><p>这学期在学校选了一门讲可计算性（Computability）的计算机科学基础课程。过程中也把很多概念给自己重新复习了一下，不过从这课课堂的反馈来看，可以说同学都听得非常吃力。我想到几年前我有尝试写过一篇通过 Y 组合子来讨论 Lambda 演算的文章，考虑到当时写得很不完善，我打算拿出来重新炒一下冷饭。顺便改使用傻子都能看懂的 JavaScript 来描述这个问题。顺便调试一下我博客系统 Markdown 引入 $\LaTeX$ 后会遇到的坑。</p><h2 id="循环-gt-递归"><a href="#循环-gt-递归" class="headerlink" title="循环 -&gt; 递归"></a>循环 -&gt; 递归</h2><p>我们还是从下面这个简单的循环问题开始探讨。通过写一个循环（不使用等差数列的情况下），求自然数列 1 到 n 的和（即 $1+2+3+…+n$）。一个最容易想到的实现可能如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> result = <span class="number">0</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    result += i</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sum(<span class="number">10</span>) <span class="comment">// =&gt; 55</span></span><br></pre></td></tr></table></figure><p>我们现在对这个问题稍作变形，如果在这个程序中不得使用 <code>for</code> 循环，我们还能实现这个程序吗？显然这也是非常简单的，因为我们还可以用 <code>while</code> 循环。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> result = <span class="number">0</span></span><br><span class="line">  <span class="keyword">let</span> counter = <span class="number">1</span></span><br><span class="line">  <span class="keyword">while</span> (counter &lt;= n) &#123;</span><br><span class="line">    result += counter</span><br><span class="line">    counter++</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sum(<span class="number">10</span>) <span class="comment">// =&gt; 55</span></span><br></pre></td></tr></table></figure><p>或者进一步地，我们可以写成：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> result = <span class="number">0</span></span><br><span class="line">  <span class="keyword">let</span> counter = <span class="number">1</span></span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (counter &gt; n) <span class="keyword">break</span></span><br><span class="line">    result += counter</span><br><span class="line">    counter++</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sum(<span class="number">10</span>) <span class="comment">// =&gt; 55</span></span><br></pre></td></tr></table></figure><p>抽象地来看，我们这里使用到的 <code>counter</code> 变量，既可以看成是循环变量，更可以看成是一个程序计数器。也就是从一个状态转移到下一个状态的过程，而 <code>break</code> 则是指出了终止状态发生的位置。我们现在对这个题目进行进一步地变形，如果我们不允许在这里使用包括 <code>while</code> 在内的任何循环，我们还能实现这个程序吗？</p><p>我们不但能，而且程序写起来更简单了。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (n === <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">  <span class="keyword">return</span> sum(n - <span class="number">1</span>) + n</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sum(<span class="number">10</span>) <span class="comment">// =&gt; 55</span></span><br></pre></td></tr></table></figure><p>这个写法可以优雅地由数学形式表示：</p><p>$$<br>sum(x)=<br>\begin{cases}<br>  0 &amp;x = 0 \cr<br>  sum(x-1) + x &amp;otherwise<br>\end{cases}<br>$$</p><p>也就是我们只需要定义 $sum(0) = 0$，然后无论求什么的和，都是其之前所有数的和加上当前这个数。计算机会一次一次向下找，直到找到 0 为止，最后把找到的数全部加起来。解决！当然你可能会觉得这么做的效率很低，计算机不停递归会影响性能，我们会在之后讨论这个问题，我们目前暂时先只讨论「可计算性」上的等价。</p><h2 id="匿名函数化"><a href="#匿名函数化" class="headerlink" title="匿名函数化"></a>匿名函数化</h2><p>「$\lambda$ 演算」和我们刚刚那个例子很接近，但是又稍有不同。我们先抛开「$\lambda$ 演算」本身复杂的定义，从其性质入手，就可以简单对「$\lambda$ 演算」有直观的认识。</p><ul><li>如果有这么一个式子 $\lambda x.x$，那么 <code>x</code> 就是一个变量。对于一个变量，我们可以任意更换其名字，比如可以从 <code>x</code> 改成 <code>y</code>，得到 $\lambda y.y$，这一步称作「$\alpha$ 等价」。</li><li>如果有形如一个式子 $(\lambda x.x+1)(1)$，我们可以把后面的 <code>1</code> 替代掉前面的 <code>x</code>，即 $(\lambda x.x+1)(1) = 1+1 = 2$，这一步称作「$\beta$ 规约」。</li></ul><p>如果你对符号不敏感，可能看到这里有点晕。但如果你敏感一点的话，就会发现这里其实只不过是换了一个说法的「匿名函数」而已。像我们之前的例子里，我们定义函数都要起一个函数名。但如果我们一次性使用这个函数，我们完全可以不命名，定义完接受的参数和运算方法直接执行即可，这就是所谓的「匿名函数」。用 JavaScript 的语言来描述的话如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// alpha 等价</span></span><br><span class="line">(x) =&gt; x</span><br><span class="line">(y) =&gt; y</span><br><span class="line"><span class="comment">// 这两个东西是等价的</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// beta 规约</span></span><br><span class="line">(<span class="function">(<span class="params">x</span>) =&gt;</span> x + <span class="number">1</span>)(<span class="number">1</span>) <span class="comment">// =&gt; 1 + 1 =&gt; 2</span></span><br></pre></td></tr></table></figure><p>如果你不熟悉 ES6 的箭头函数，用 ES5 写的话如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// alpha 等价</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> (<span class="params">x</span>) </span>&#123; <span class="keyword">return</span> x &#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> (<span class="params">y</span>) </span>&#123; <span class="keyword">return</span> y &#125;</span><br><span class="line"><span class="comment">// 这两个东西是等价的</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// beta 规约</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">x</span>) </span>&#123; <span class="keyword">return</span> x + <span class="number">1</span> &#125;)(<span class="number">1</span>) <span class="comment">// =&gt; 1 + 1 =&gt; 2</span></span><br></pre></td></tr></table></figure><p>换句话说，也就是说「$\alpha$ 等价」说明了匿名函数中的变量名不会影响运算结果，而「$\beta$ 规约」就是去执行这个匿名函数而已。</p><h2 id="为什么？"><a href="#为什么？" class="headerlink" title="为什么？"></a>为什么？</h2><p>我们之前讨论了一个递归和循环的例子，这和「匿名函数」有什么关系呢？我们可以看到，我们现在的匿名函数看起来很方便，但是实际上用来实现递归和循环听起来就很奇怪。首先，纯「$\lambda$ 演算」并没有像是 <code>while</code> 或 <code>for</code> 这样的循环命令。不过好在我们刚刚发现，所有的循环都可以被我们转换成递归</p><p>递归听起来就和函数更相关一些，不过我们又产生了一个新问题：递归时，我们需要具名地指定我们递归调用那个函数。而我们现在的函数，没有名字。我们还能实现递归吗？</p><h3 id="尝试"><a href="#尝试" class="headerlink" title="尝试"></a>尝试</h3><p>我们先大致写一个类似递归的匿名函数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function">(<span class="params">n</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (n === <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">  <span class="keyword">return</span> n + <span class="comment">// 我不知道这里要加什么东西</span></span><br><span class="line">&#125;)(<span class="number">10</span>) <span class="comment">// 应该要输出 55</span></span><br></pre></td></tr></table></figure><p>不过既然递归要调用一个函数，我们先假设我们存在这个函数，将其命名为 <code>f</code>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function">(<span class="params">n</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (n === <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">  <span class="keyword">return</span> n + f(n - <span class="number">1</span>)</span><br><span class="line">&#125;)(<span class="number">10</span>) <span class="comment">// 应该要输出 55</span></span><br></pre></td></tr></table></figure><p>我们可以想象，对于匿名函数，如果没有全局变量，那么其获取数据的来源是唯一的，那就是参数。那我们为什么不把我们想要的函数 <code>f</code> 作为参数呢？</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function">(<span class="params">f, n</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (n === <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">  <span class="keyword">return</span> n + f(n - <span class="number">1</span>)</span><br><span class="line">&#125;)(<span class="number">10</span>) <span class="comment">// 应该要输出 55</span></span><br></pre></td></tr></table></figure><p>这样似乎已经快到我们想要的结果了，既然我们加了一个参数 <code>f</code>，那么在执行的时候，这个 <code>f</code> 又是多少呢？答案很简单，就是这个匿名函数自己。匿名函数不能起名字，但其本身还是可以作为参数传递啊，于是我们得到了：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function">(<span class="params">f, n</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (n === <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">  <span class="keyword">return</span> n + f(f, n - <span class="number">1</span>)</span><br><span class="line">&#125;)(<span class="function">(<span class="params">(f, n</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (n === <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">  <span class="keyword">return</span> n + f(f, n - <span class="number">1</span>)</span><br><span class="line">&#125;), <span class="number">10</span>) <span class="comment">// # =&gt; 55</span></span><br></pre></td></tr></table></figure><p>解决！我们使用了纯匿名函数解决了这个问题。</p><h3 id="Y-组合子"><a href="#Y-组合子" class="headerlink" title="Y 组合子"></a>Y 组合子</h3><p>那什么是 Y 组合子（Y Combinator）呢？Y 组合子不过是解决这一类问题的通用方案而已。Y 组合子的定义是</p><p>$$<br>Y := \lambda f.(\lambda x.(f (x\ x)) \lambda x.(f (x\ x)))<br>$$</p><p>听起来挺搞脑子的，不过如果我们代入任何一个东西算一下的话，就会发现其实很简单。如果我们存在一个函数 <code>g</code>，那么：</p><p>$$<br>\begin{align}<br>  Y\ g &amp; = \lambda f.(\lambda x.(f (x\ x)) \lambda x.(f (x\ x))) g \\<br>  &amp; = \lambda x.(g (x\ x)) \lambda x.(g (x\ x)) \\<br>  &amp; = \lambda y.(g (y\ y)) \lambda x.(g (x\ x)) \\<br>  &amp; = (g (\lambda x.(g (x\ x)) \lambda x.(g (x\ x)))) \\<br>\end{align}<br>$$</p><p>而同时：</p><p>$$<br>\begin{align}<br>  g (Y\ g) &amp; = g (\lambda f.(\lambda x.(f (x\ x)) \lambda x.(f (x\ x))) g) \\<br>  &amp; = (g (\lambda x.(g (x\ x)) \lambda x.(g (x\ x)))) \\<br>\end{align}<br>$$</p><p>故 $Y g = g (Y\ g) = g (g (Y\ g)) = g (g (g (Y\ g))) $，也就是对于任意函数都能实现递归。</p><p>这里我们再使用 JavaScript 来实现一下 Y 组合子版的自然数列 1 到 n 的和：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// \lambda f.(\lambda x.(f (x x)) \lambda x.(f (x x)))</span></span><br><span class="line"><span class="keyword">const</span> Y = <span class="function"><span class="params">fn</span> =&gt;</span> (<span class="function"><span class="params">f</span> =&gt;</span> fn(<span class="function"><span class="params">x</span> =&gt;</span> f(f)(x)))(<span class="function"><span class="params">f</span> =&gt;</span> fn(<span class="function"><span class="params">x</span> =&gt;</span> f(f)(x)))</span><br><span class="line"></span><br><span class="line">g = <span class="function"><span class="params">f</span> =&gt;</span> n =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (n === <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">  <span class="keyword">return</span> n + f(n - <span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Y(g)(<span class="number">10</span>) <span class="comment">// =&gt; 55</span></span><br></pre></td></tr></table></figure><h3 id="不动点组合子"><a href="#不动点组合子" class="headerlink" title="不动点组合子"></a>不动点组合子</h3><p>你也许听过 Y 组合子是一类不动点组合子。不动点组合子究竟是什么意思呢？组合子是一种消除变量的函数。在 Y 组合子中你可以看到并没有用任何 <code>let</code> <code>var</code> <code>const</code> 之类的变量定义，而是通过一系列参数传递消除了这一过程。而至于不动点，你可能在初中的代数课本上学习过「不动点」的概念，这在这里几乎是一样的。通常我们眼中的不动点，即在函数 $f(x) = y$ 上找到一个值 <code>x</code> 使得 $x = f(x)$。比如对于函数 $f(x) = x^2 - 1$，不动点是 1 和 -1。</p><p>但是初中的代数中的这个不动点的定义其实是一个简化版本。事实上所谓找到一个「值」<code>x</code>，也可以被表述成「找到一个『函数』」<code>g(x)</code>，使得 $g(x) = f(g(x))$。而值 <code>x</code> 是这个 <code>g(x)</code> 的一个特例，即常值函数 <code>g(x) = c</code>（c 是一个常数）。</p><p>这样我们就不难理解不动点组合子的意义了。我们找到一个函数 <code>Y</code>，使得 $Y\ g = g(Y\ g)$。这就是所谓的不动点组合子。</p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>费了那么大劲到底干什么？因为图灵机、递归和 $\lambda$ 演算被证明在可计算性上是等价的，如果存在一个问题（比如递归或者循环）在其中一种可计算，在另一种不可计算。这是有悖于数学原理的。而更重要的是，我们基于 Y 组合子这个例子，可以一次性将图灵机、递归和 $\lambda$ 演算的知识一次性串联起来，建立一个对可计算性的直观系统的理解。</p><p>岂不是很好吗？</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;引&quot;&gt;&lt;a href=&quot;#引&quot; class=&quot;headerlink&quot; title=&quot;引&quot;&gt;&lt;/a&gt;引&lt;/h2&gt;&lt;p&gt;这学期在学校选了一门讲可计算性（Computability）的计算机科学基础课程。过程中也把很多概念给自己重新复习了一下，不过从这课课堂的反馈来看，
      
    
    </summary>
    
    
      <category term="JavaScript" scheme="https://coderemixer.com/tags/JavaScript/"/>
    
      <category term="Lambda 演算" scheme="https://coderemixer.com/tags/Lambda-%E6%BC%94%E7%AE%97/"/>
    
  </entry>
  
  <entry>
    <title>部署家中网络的流水帐</title>
    <link href="https://coderemixer.com/2018/11/26/home-network-fujisawa/"/>
    <id>https://coderemixer.com/2018/11/26/home-network-fujisawa/</id>
    <published>2018-11-26T10:37:47.000Z</published>
    <updated>2018-11-26T11:58:45.682Z</updated>
    
    <content type="html"><![CDATA[<h2 id="引"><a href="#引" class="headerlink" title="引"></a>引</h2><p>我今年 9 月搬家到了藤泽，签了一个非常恶心人的 Softbank 的网络合约之后，花了大半个月才搞清楚这个网络的状况。于是就基于自己的需求，在家中部署了多项服务。今天写这篇文章就是来分享一下部署过程中遇到的困难以及解决的方案。</p><h2 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h2><ol><li>能够有稳定的有线、无线网络</li><li>每个设备都有 IPv6 支持</li><li>访问学校资源时自动通过 VPN 连接学校内网</li><li>在局域网内提供 NAS 服务</li><li>在局域网内提供私有 git 服务来维护代码</li><li>支持通过 VPN 访问家中网络</li><li>对外提供 Web 网络服务</li></ol><p>之所以定成这样有几个理由。一个是我从来不相信所谓的云网盘，一定要自己存文件才是安全的。其次是经过测试，我的网络基于 IPv6 的传输速度比 IPv4 快不少，上下行都能稳定在 600Mbps 左右。这也使得家中不止要有无线网络，千兆有线网络对于压榨性能也是必不可少的。</p><p>为了达成这个网络部署，前后也是经历了两三个月时间细心打磨方案，下面就是具体的过程。</p><h2 id="网络拓扑"><a href="#网络拓扑" class="headerlink" title="网络拓扑"></a>网络拓扑</h2><p><img src="/static/home-network.jpg" alt="Home Network"></p><p>光纤自 NTT 的 GPON 接入 Softbank 的路由。之所以要接入 Softbank 的路由而不是直接接在自己的路由上，是因为 Softbank 使用了一个非常诡异的 IPoE + IPv6 的网络分配形式。其 IPv4 的地址是基于 IPoE 下发的，而其鉴权过程写死在了其定制的路由器中。如果使用 PPPoE 进行拨号，没有办法达到最高的网速，经过实测，PPPoE 只能达到 30Mbps 上下行对等的速度。</p><h2 id="路由系统"><a href="#路由系统" class="headerlink" title="路由系统"></a>路由系统</h2><p>路由进来后就需要考虑自己的路由系统了，由于这个 Softbank 富士康路由器能调的选项实在是太少，有必要弄一个自己的路由器。考虑到我还打算部署服务，于是就决定弄一个服务器，通过虚拟化的方式来实现。既然说到虚拟化，那么面向个人免费的 ESXi 就是个不错的选择，挑一个对 ESXi 兼容性比较好的，适合放在家里的服务器就可以。</p><p>我最终的选择是 HP MicroServer Gen8，</p><ol><li>首先 HP 这款设备虽然有点老，但是性能还是勉强够用，在二手市场上价格非常便宜。新版本甚至不支持 iLO，算什么服务器？</li><li>其次就是 HP 对这款设备在其官网上就有 ESXi 的配套驱动，不需要担心兼容性的问题</li><li>再者由于存储了文件，需要有 RAID 支持来保障文件的可靠性，而这款设备有原生的 RAID 1 支持</li><li>然后就是自带了三个网口，去掉一个 iLO 管理口，剩下两个还能做上下行，满足我们对路由设备的需求</li><li>最后就是这款机器定位家庭服务器、小型公司服务器，所以是静音且不需要机柜的，这可太适合我们这个项目了</li></ol><p><img src="/static/hp-microserver.jpg" alt="HP MicroServer"></p><p>最终，我在 Yahoo 拍卖上以 35,000 日元（折合人民币 2200 元）的价格买到了一台 Xeon CPU E3-1220L V2 2.3GHz CPU，8GB 内存，没有硬盘的设备。然后单独购买了两块 4TB 的硬盘做 RAID 1。</p><p>在 BIOS 中配置好 RAID 选项，直接从 HP 官网上下载相应的 ESXi 镜像，通过 iLO 连接远程安装系统，这一过程非常轻松。另一个网口自然就是要来接交换机的，我在日本亚马逊上以 3,180 日元（折合人民币 200 元）买了一台 NETGEAR GS308-100JPS 的交换机，一共 8 个千兆口，基本够家里使用了。</p><p>操作系统选了 OpenWRT 18.06.1，直接 img 拉下来转成 vmdk 塞进 ESXi 里，就可以直接运行了。在 ESXi 中虚拟两个交换机 vSwtich0 接路由器虚拟机、外网网口、管理网；vSwitch1 接路由器、交换机网口以及之后的各种服务。</p><p>启动后把外网 IPv4 做成 DHCP，IPv6 做成接力模式。配置内网的 DNS 服务为 ESXi 和 OpenWRT 设置好便于访问的别名，第一阶段完工。</p><h2 id="外网服务"><a href="#外网服务" class="headerlink" title="外网服务"></a>外网服务</h2><p>接下来来说这个外网服务的问题，这个问题是导致这个项目的网络拓扑变得如此复杂的直接原因。尽管 Softbank 宣称只要打开 DMZ 和防火墙，就可以从公网 IP 访问到设备。经过我将近一个星期的调试，我只想讲一句 fnndp。</p><p>在网上找了半天，找到一篇 <a href="https://nashippe.blog/network/rtx/ipv6-hybrid/" target="_blank" rel="noopener">博客</a>，讲了它是通过开启路由的 PPPoE 穿透，在内网拨号，从而让家中上网走 IPoE + IPv6 的快速网络，而提供服务走的是 PPPoE 的较慢的网络。于是我也打算按照这个方法实施。</p><p>我在 ESXi 上安装了一个新的 Debian 虚拟机，也同时接入 vSwitch0 和 vSwitch1 两个虚拟交换机。在 vSwitch0 上进行 PPPoE 拨号，同时从 vSwitch1 上做 DHCP 客户端。然后通过手写 ip rules 的方法实现路由分流。从而让这台设备成为网关 (gateway) 设备，其它服务可以通过这台的端口代理完成部署。</p><p>接下来就是比较简单的，配置 StrongSwan 做了一个 IKEv2 的 VPN；安装 GitLab 做了一个私有的 Git 服务。为了方便更多的 Web 服务部署，我使用了 OpenResty，并在上面运行 <a href="https://github.com/GUI/lua-resty-auto-ssl" target="_blank" rel="noopener">lua-resty-auto-ssl</a> 的方式自动签发 HTTPS 证书。有关安全的 HTTPS 配置，可以使用 <a href="https://mozilla.github.io/server-side-tls/ssl-config-generator/" target="_blank" rel="noopener">Mozilla SSL Configuration Generator</a> 生成。</p><h2 id="内网服务"><a href="#内网服务" class="headerlink" title="内网服务"></a>内网服务</h2><p>一个单独拿出来讲的是 NAS。我的选型是 OpenMediaVault。这个系统开源，而且基于 Debian，非常稳定。之所以没有选 FreeNAS，因为我一共只有 8GB 内存，跑 ZFS 还是太吃力了一些。我在 ESXi 上单独虚拟了一个 OpenMediaVault，需要虚拟两块硬盘出来，一块系统盘，一块存储盘，这样管理起来比较容易。</p><p>WiFi 的部分是个坑，我一开始觉得这个 Softbank 富士康自带的 WiFi 质量还挺好的，5GHz 能跑上 300Mbps。但后来发现一个严重问题，就是会莫名其妙断流，这个在比如联机玩个马里奥赛车的时候会抓狂。</p><p><img src="/static/cisco-ap.jpg" alt="Cisco AP"></p><p>这时候某好友送了我一台 Cisco CAP-3502i。虽然这设备 5GHz 连 802.11ac 都不支持，只支持 n。但是却非常稳定。可惜这玩意使用 PoE 供电，如果换成 PoE 的交换机的话，实在是太浪费钱了。于是我就趁着回国间隙从京东买了一个 TP-LINK TL-POE150S PoE 供电模块（99 元）。TP-LINK 这设备又便宜又稳定，<strong>但是</strong>  赠品的 RJ45 网线还不如不送，送的竟然是 CAT-5 规格的线。我到现在都没搞清，在藤泽，扔网线属于哪一类垃圾，怎么才能扔出去。</p><h2 id="杂项"><a href="#杂项" class="headerlink" title="杂项"></a>杂项</h2><p>除了上面说到这些，还做了一些小的东西。首先有一个台风天的晚上，我的房间断电了 1 秒不到，我感受到是因为我的服务器重启了。为了应对这种情况，我花了 5,980 日元（折合人民币 366 元）买了一台 255W 的 <a href="https://www.amazon.co.jp/gp/product/B01MY53XVO/ref=oh_aui_detailpage_o05_s00?ie=UTF8&amp;psc=1" target="_blank" rel="noopener">家用 UPS</a> 以应对突发情况。（长时间的断电我也不防了，毕竟是家用。）</p><p><img src="/static/switch-desktop.jpg" alt="Switch Desktop"></p><p>另外我给我的桌面上单独配了 Type-C 到以太网的网口，和电源一起接在适配器上，随时把 Macbook Pro 插上去就可以比较好地工作。另外给 Nintendo Switch 也单独配了网线和 USB 网口。<strong>千万</strong> 不要买任天堂官方的 USB 网口，那玩意甚至是 USB 2.0 的。随便在 Amazon 上都可以买到，比官方的又便宜，速度又快的网口转接器。</p><p>最后就是为了访问方便，还是搞一个 DDNS 服务来为家里配一个固定的域名。虽然这 Namecheap 的官方 Guidelines 里讲的花里胡哨的，结果连个 Debian 的例子都没有。我用的是 ddclient 客户端，反正配置还挺简单的。</p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><ol><li>别签 Softbank</li><li>我不确定这套玩意跑两年加上电费和云主机哪个便宜</li><li>要是来个地震直接把硬盘砸穿了啥 RAID 都没用</li><li>手写过 iptables 和 ip rules，才知道里面有多少坑</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;引&quot;&gt;&lt;a href=&quot;#引&quot; class=&quot;headerlink&quot; title=&quot;引&quot;&gt;&lt;/a&gt;引&lt;/h2&gt;&lt;p&gt;我今年 9 月搬家到了藤泽，签了一个非常恶心人的 Softbank 的网络合约之后，花了大半个月才搞清楚这个网络的状况。于是就基于自己的需求，在家中
      
    
    </summary>
    
    
      <category term="生活" scheme="https://coderemixer.com/tags/%E7%94%9F%E6%B4%BB/"/>
    
      <category term="网络" scheme="https://coderemixer.com/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>使用字体，怎样不惹官司</title>
    <link href="https://coderemixer.com/2018/11/24/how-to-use-fonts/"/>
    <id>https://coderemixer.com/2018/11/24/how-to-use-fonts/</id>
    <published>2018-11-24T01:48:02.000Z</published>
    <updated>2018-11-25T02:35:01.752Z</updated>
    
    <content type="html"><![CDATA[<h2 id="引"><a href="#引" class="headerlink" title="引"></a>引</h2><p>近来，知名 up 主敖厂长因为在视频中使用了「造字工房」家的某些字体，使得惹上了官司，被求偿十多万的赔偿费用。在字体行业内，其实这样的事情屡见不鲜。从 2011 年方正诉保洁的「飘柔」商标字体案，到 2015 年造字工房诉湖南卫视《歌手3》节目字体侵权案，字体公司的名字似乎和侵权官司脱不开关系。那么今天我们就来聊一聊中文字体行业的发展现状，以及作为一个用户，怎样使用字体，不容易惹上官司。</p><h2 id="字体行业现状"><a href="#字体行业现状" class="headerlink" title="字体行业现状"></a>字体行业现状</h2><p>字体行业的生存相当困难，目前国内其实混得比较好的字体公司只有那么几家。大家熟悉的简体字的字型逃不开北大方正、常州华文，还有台湾的威锋数位（也就是之前的华康字体）、文鼎字体和蒙纳字体这几家公司的设计。这些品牌几乎都是伴随中国计算机发展从无到有的几十年过程中的重要见证。而这次的主角造字工房，虽然也是一家成立了十年的老公司了，但比起这些公司，还算是比较年轻的。</p><p>首先设计中文字体的过程，不得不说是比较艰辛的。一个完整的西文字体通常需要拉丁字母、希腊字母、西里尔字母以及常见的符号，这样就已经有近千个字型需要设计了。而中文字形则更多，根据中国 GB2312-80 中华人民共和国国家标准简体中文字符集规范，包括 6763 个汉字（其中一级汉字 3755 个，二级汉字 3008 个）。而即使这样，也只能覆盖中国大陆 99.75% 的使用频率。一旦使用到一些偏僻字，我们还有 GB18030 国家标准来涵盖偏僻字，其收录汉字 70,244 个。像是政府公文喜欢用的仿宋、楷体，都有对应的 GB18030 标准实现，来保证尽可能地不会缺字。这还不算上各种 hinting、ligature 之类细节调教所需要的工时，甚至还要面向不同操作系统使用的不同渲染方式进行微调。</p><p>而在这种情况下，付出了大量的设计师成本后，字体公司的盈利模式又是如何的呢？</p><p>我们可以大致把常见的字体公司盈利模式，分成下述几类：</p><ul><li>研发授权</li><li>字体定制</li><li>字体销售</li><li>诉讼收入</li></ul><p>像是微软雅黑就是微软委托给方正和蒙纳设计的；而 Adobe 和 Google 合作研发的思源黑体的中文部分，是委托给常州华文设计的；而像苹果新的 iOS 和 macOS 中内置的苹方字体则是委托威锋数位设计的。这是字体公司盈利的很大来源，这些国际大厂有着广泛的字体设计的评价标准，属于比较懂事的甲方。以微软雅黑为例，据坊间传闻，微软雅黑的平均每个汉字的价格是 100 美元，也就是说一个 2 万个汉字的字体，微软付出了 200 万美元的合作价格，以获取微软雅黑能在 Windows 操作系统下使用的授权。</p><p>除了整个字库整个字库的研发，另一种更便宜的作法就是字体定制。比如根据你的品牌形象，专门定制一个 Logo 用的字体，让别人能从字体一眼认出你的品牌也是一个常见的盈利模式。而对于普通用户，正规的字体获取渠道，也就是字体销售，实际情况是比较惨淡的。中国早年的软件销售就饱受盗版问题的影响，自己辛辛苦苦设计出来的字体人人都在用，自己却一分钱都没有收到，放到是谁好像也不能接受。于是，很快我们就发展出了一个全新的被各大字体公司广泛使用的盈利模式：</p><p><strong>诉讼！</strong></p><p>简单说，就是字体公司会请一个庞大的法务部门，天天上网找那些非法使用字体的公司，然后一个个起诉他们。起诉小公司，通常付出的成本和回报不符，所以也会专挑知名的公司或个人下手。虽然通常不会走到对簿公堂的最后一步，大多问题都能通过协商和庭外和解解决。但这种先上车，后补票的方式，一方面让人感觉很奇怪，而另一方面则让没钱维护法务关系的小字体公司很难生存。这也不难解释为什么说到字体公司，脑海中浮现的就只有这么几家了。</p><h2 id="什么是商业使用"><a href="#什么是商业使用" class="headerlink" title="什么是商业使用"></a>什么是商业使用</h2><p>这次敖厂长的事件一个争议点就是「商业使用」，因为造字工房有说对于个人非商业使用，可以不收费。「我是个人做视频，怎么就算商业使用了呢？」这是很多人的第一个想法。虽然不同公司的具体授权协议有所不同，像方正就会比较严格一些。但实际情况是，商业使用的界限在于字体公司本身怎么设计的授权协议，使用者是没有讨价还价的余地的。你只有在使用前向字体公司确认自己的使用是不是合法，是不是可以免费使用。等到对方来起诉你的时候，这一点几乎是毋庸置疑的了。</p><p>通常对商业使用的界定就是以 <strong>获得经济收益</strong> 为界限的。个人制作的视频虽然是免费的，但平台方的广告收入、观众的捐款、赞助，都可以被划到商业使用的界限中。所以不止是海报、电视节目等传统用途，各位 up 主在使用字体时也必须要格外的小心。</p><h2 id="怎么做？"><a href="#怎么做？" class="headerlink" title="怎么做？"></a>怎么做？</h2><p>世间大多数问题的可以用「喜欢就买 不行就分 多喝热水 重启试试」这四个真理解决。而字体就属于「喜欢就买」这个范畴的。如果你想用一个字体，而又有钱，那就买啊。大多数的字体商业使用的一年授权费也就在几干元人民币左右，你发一个月设计师薪水都不够，为什么非要省下这个钱呢？顺便一提，使用字体的被授权方应该是字体的实际使用者。比如对于一个设计师接了一个案子，那应该是你的甲方去买字体，你买字体通常并不能解决问题。</p><p>那对于一些新人创作者，还没有多少收入，又想要规避掉潜在的法律风险，万一以后红了被告了多麻烦。这时候又有什么选择呢？我在此给一些推荐。</p><p>我们可以把字体大致分为几种授权情况：开源协议、非商用授权、商用授权和无法授权。我会根据使用情况来对这几种授权方式进行说明。</p><p>我们先讲最奇葩的情形：无法授权。这一类的典型代表就是「康熙字典体」。由于这款字体被卖断，已经不再提供任何销售了，请务必不要使用这一字体。推荐的替代品有「喜鹊古字典体」（个人可商用 99 元）和「方正清刻本悦宋」（个人不可商用 2 元、商用授权 7000 元）。</p><p>开源协议的字体主要有两种类型，一种是 OFL (SIL) 协议，典型的代表有思源黑体、思源宋体。其要求是你不能卖这个字体本身，但搭配这个字体使用的商业活动可以销售。这是对于商业活动最宽松的字体，而且是免费的。在此强烈推荐最近刚更新的思源黑体 2.0，不但字型很全，对于大量生僻字支持很好，甚至支持了超出 GB18030 的生僻字，还针对简体、台湾繁体、香港繁体、韩国汉字、日文汉字的不同写法单独做了优化。</p><p>但不是所有开源协议都是安全的，像著名的在 Linux 系统下常见到的文泉驿开源字体。文泉驿微米黑的授权为 Apache 2.0 和 GPL v3 双授权，而文泉驿点阵宋体、正黑和 unibit 则是 GPL 单授权。对于 Apache 2.0 授权的字体可以在附上原始字体的协议、商标、专利声明自由商用，而对于 GPL 授权的字体，虽然可以商用，但使用的产品，必须也按照 GPL 协议开源发布，这一点则非常复杂了。</p><p>非商用授权的字体主要有造字工房的个人字体和方正的个人授权。造字工房的字体当你个人非商用时是免费的，而方正 2 元一个的个人授权，也是不得用于商业用途的。这两家的商业用途字体需要单独购买，这点要特别注意。</p><p>商用授权的部分同样也有不少选项。一个是对于个人用户，喜鹊造字家的字体都是可以以 99 元的价格进行商用的。方正字体中方正黑体、方正书宋（注意不是新书宋）、方正仿宋、方正楷体这四款字体，针对「商业发布」这种使用方式免费。还有一个很特别的情况，一位网友曾给苹果发邮件询问 Mac 自带的字体可否商用，得到了肯定的回答。「Mac 内置字体，直接在苹果电脑上操作并输出为商用是没有问题的。」那么 Windows 呢？答案是，我不知道。由于微软和几家厂商的授权非常复杂，使用前请务必询问各个厂商得到具体答复。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>说到底还是几个问题。</p><ol><li>守法</li><li>搞不清授权情况要联系版权方</li><li>有能力请多支持正版字体</li></ol><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="https://www.foundertype.com/index.php/About/userAuth.html" target="_blank" rel="noopener">方正字库 商业授权</a></li><li><a href="https://github.com/adobe-fonts/source-han-sans/blob/master/LICENSE.txt" target="_blank" rel="noopener">思源黑体 License</a></li><li><a href="http://wenq.org/wqy2/index.cgi?Download" target="_blank" rel="noopener">文泉驿授权</a></li><li><a href="https://h.bilibili.com/9615827" target="_blank" rel="noopener">敖厂长事件相关帖文</a></li><li><a href="https://www.facebook.com/groups/enjoyfonts/permalink/841583915996485/" target="_blank" rel="noopener">关于 Mac 内置字体商用的讨论</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;引&quot;&gt;&lt;a href=&quot;#引&quot; class=&quot;headerlink&quot; title=&quot;引&quot;&gt;&lt;/a&gt;引&lt;/h2&gt;&lt;p&gt;近来，知名 up 主敖厂长因为在视频中使用了「造字工房」家的某些字体，使得惹上了官司，被求偿十多万的赔偿费用。在字体行业内，其实这样的事情屡见不鲜。
      
    
    </summary>
    
    
      <category term="字体" scheme="https://coderemixer.com/tags/%E5%AD%97%E4%BD%93/"/>
    
      <category term="法律" scheme="https://coderemixer.com/tags/%E6%B3%95%E5%BE%8B/"/>
    
  </entry>
  
  <entry>
    <title>从前几天收到的竞选广告说起</title>
    <link href="https://coderemixer.com/2018/10/22/waki-reiko/"/>
    <id>https://coderemixer.com/2018/10/22/waki-reiko/</id>
    <published>2018-10-22T09:19:36.000Z</published>
    <updated>2018-10-22T12:18:31.405Z</updated>
    
    <content type="html"><![CDATA[<h2 id="引"><a href="#引" class="headerlink" title="引"></a>引</h2><p>10 月 18 日那天信箱里收到了日本左翼政党立宪民主党藤泽女性市议员参选人脇 れい子的竞选广告。立宪民主党是之前民进党拆伙后独立的政党，右翼部分和希望党合并成立了国民党。看了下这位市议员的竞选广告，Slogan 是「人が生きる町」，竞选主轴围绕藤泽市大量的老年人口的照顾问题，然而这议题占了整个广告页的 1/12 不到。</p><p>花了 1/4 篇幅讲了要推动「候补者均等法案」的实行，查了一下这个法案的具体内容。是在地方和国会选举中要求男女候补者人数均等的法案。此议案在今年 5 月参院全票通过。1/4 的篇幅是和各个其它政客的合照，意义不明。然后 1/4 篇幅列举了自己的求学、工作简历。1/4 要求进行「性暴力被害者支援法」立法。还有一些细碎的其它政见。</p><p>我看完后的感受是——一头雾水。首先，「性暴力被害者支援法」立法工作是立宪民主党的政见，而市议员又不是两院的议员，选不选上都无关。候补者均等法案感觉也很怪，不去讨论解决女性参政者少的背后原因，去立法平衡人数这不是变相的性别歧视吗？也不知道这法案怎么就如此朝野一致地通过了。内容多而杂，很多和竞选内容无直接关系，看完了完全没有对这个议员留下什么好印象。</p><p>如果不是特意细读了一下，恐怕大多数人看完这广告连候选人名字都记不住吧。感觉很失败。</p><h2 id="政治人物的自我修养"><a href="#政治人物的自我修养" class="headerlink" title="政治人物的自我修养"></a>政治人物的自我修养</h2><p>作为一个政治人物，一个最核心的思考方式就是「选民要什么？」和「自己能干什么？」。如果连基本的自我定位都做不好，要么无法获得选民的认可，要么心有余而力不足，不能为选民做好服务。</p><p>在这则广告里，候选人同时犯了这两个错误。</p><p>第一个错误就是弄不清选民要什么。先不说「候补者均等法案」能不能真正推动性别平权，「推动『候补者均等法案』」的这个动作的本身，直接受益者是不是女性呢？答案其实很明显，就算是，也不会是女性的主体。日本地方议员定数是每 100 万人口 500 人，也就是万分之五的比例。如果女性议员不得小于 40%，那就是有万分之二的人口得到了直接受益。间接的受益者则很难计算，即使是女性议员在议会中，也并不代表会为女性直接发声，更何况其仍处于相对的少数。藤泽市人口根据 2015 年联合国数据，是 42.39 万，这样的竞选目标，能不能催出 1000 张选票都成问题，以至于这样的宣传成本和受益是极大不匹配的。</p><p>第二个错误就是对「性暴力被害者支援法」立法工作的推动。「性暴力被害者支援法」自然是个有必要立法的法案。但市议员并不能参与国会的立法，最多只能参与地区的立法，而立法的范围也非常有限。「性暴力被害者支援法」是候选人所在立宪民主党的政见，而市议员又不是两院的议员，选不选上都无关。这样的议题，如果真的被选上了，这位市议员又如何推动立法的执行呢？最后不只能变成一句大话空话吗？会不让人民失望吗？</p><h2 id="利益、政党、财团"><a href="#利益、政党、财团" class="headerlink" title="利益、政党、财团"></a>利益、政党、财团</h2><p>然而问题是，只要一个候选人不是西瓜，受过基本的政治学教育，那么都应该理解上面的道理。但事实上，为什么无论在哪里的选举，这样的事情却屡见不鲜呢？</p><p>这不免和我们现行的民主制度是直接相关的。为使选举资源利用效率最大化，集团化党派化是最便利的形式；而财团和党派长期的良好关系又是运作党派最便利的形式。虽然是民众一票一票投出来来的政治人物，但一个人物，在成为政治人物之前，就已经接受了财团、政党巨大的恩惠了，是为选民直接负责，还是也要为财团、政党服务就成了问题。这在大多数时候不会显得太过矛盾，但一旦财团与人民的利益起冲突时，事情就会起微妙的变化。</p><p>2017 年的台湾政坛的一个重要事件就是<a href="https://zh.wikipedia.org/wiki/2017%E5%B9%B4%E5%8F%B0%E7%81%A3%E5%8B%9E%E5%8B%95%E5%9F%BA%E6%BA%96%E6%B3%95%E4%BF%AE%E6%AD%A3%E7%88%AD%E8%AD%B0" target="_blank" rel="noopener">「台湾劳动基准法修正争议」事件</a>。在这个事件中，我们看到了无数换位置换脑袋的现象。蔡英文选前之夜说「人民的声音，不管怎么大声，到了凯道就停住了」，而 2017 年，蔡英文就把劳基法的抗议民众赶出了凯道。选前和民进党关系极为密切的劳工朋友，竟然他们的声音在凯道前就被停住。那么问题来了，如果是国民党执政，他们就不会伤害劳工朋友吗？</p><p>答案当然是否定的。如果今天是 Hillary 当美国总统，她会为沙特被杀害的记者发声吗？我想也是不会的。要想在选举中浮上台面，需要大量的资源，这些资源可以以钱的形式，也可以不是。而拿了资源自然要为提供资源的人负责。选民能决定的东西，从一开始就是有限的。</p><p>某种意义上这就像纳什均衡一样，用人民的手投出并不最大化人民利益的结果。不只是美国，也不限于总统制，这确实是个很难例外的事，因为也很难想到更好的方式。</p><h2 id="民主政治的科技革命"><a href="#民主政治的科技革命" class="headerlink" title="民主政治的科技革命"></a>民主政治的科技革命</h2><p>选举需要资源，最大的目的是要能让选民接触到被选举人。以美国选举为例，2016 年美国人口 3.234 亿人，2016 年大选投出了 1.37 亿张选票。我们先不考虑美国特殊的选举人团制度，如果是简单多数决，只有两个主要候选人的情况下，至少也要 45% 的得票率，那就是 6100 万张选票。这 6100 万张选票的背后是 6100 万分布在美国各州各县各市，如何把自己的声音传给这 6100 万人就是一个极难解决的问题。所以候选人要控制媒体，从以前的控制报纸，到后来的控制电视，再到现在控制网络，都是一样的理由。控制媒体需要极高的成本，这时候政党和支持政党的财团就变得极为便利。这个世界上不存在一个绝对中立的个人，也不存在一个绝对中立的媒体。今天 Trump 觉得 New York Times 是 Fake News，我很大程度上同意，NYT 的专栏动不动就打自己的脸，要说其很很中立、仔细考证我是不信的。但 Fox News 就不是了吗？每个媒体都在制造 Fake News，但谁当局，谁就可以指定什么是 Fake News。每个人的精力是有限的，能接触到的信息亦是有限的。所谓的「同温层效应」就是人们往往会选择与自己观念相近的信息，而排斥立场相反的信息。</p><p>在这种情况下，有两个政治事件是我感到很惊讶的。一个是 <a href="https://zh.wikipedia.org/wiki/%E5%A4%AA%E9%99%BD%E8%8A%B1%E5%AD%B8%E9%81%8B" target="_blank" rel="noopener">2014 年台湾 318 学运</a> 中 <a href="https://zh.wikipedia.org/wiki/G0v%E9%9B%B6%E6%99%82%E6%94%BF%E5%BA%9C" target="_blank" rel="noopener">g0v 零时政府</a> 扮演的角色。g0v 通过网络，以更低的成本开放政府资料让政府透明，人民更容易做主。虽然我依然相信，和控制报纸和电视一样，拥有更多资源的选举人，只要对网络认识充分，方法妥当，依然有着更大可能性控制网络的舆论。但大多数旧时的选举人仍是迂腐的，所谓「肉食者鄙，未能远谋」。能不能利用网络的优势，以更低的成本来产生更能为人民服务好的政客，来摆脱人民被财团支配的命运？这个问题在我心中还是一个问号，且持悲观态度的。</p><p>但黑暗中的点点星光，还是能让人感受到丁点的希望的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;引&quot;&gt;&lt;a href=&quot;#引&quot; class=&quot;headerlink&quot; title=&quot;引&quot;&gt;&lt;/a&gt;引&lt;/h2&gt;&lt;p&gt;10 月 18 日那天信箱里收到了日本左翼政党立宪民主党藤泽女性市议员参选人脇 れい子的竞选广告。立宪民主党是之前民进党拆伙后独立的政党，右翼部分和
      
    
    </summary>
    
    
      <category term="政治观察" scheme="https://coderemixer.com/tags/%E6%94%BF%E6%B2%BB%E8%A7%82%E5%AF%9F/"/>
    
      <category term="日本" scheme="https://coderemixer.com/tags/%E6%97%A5%E6%9C%AC/"/>
    
  </entry>
  
  <entry>
    <title>Ruby 原生扩展开发指北</title>
    <link href="https://coderemixer.com/2018/10/21/ruby-native-ext-compass/"/>
    <id>https://coderemixer.com/2018/10/21/ruby-native-ext-compass/</id>
    <published>2018-10-21T13:44:43.000Z</published>
    <updated>2018-10-22T12:18:06.367Z</updated>
    
    <content type="html"><![CDATA[<h2 id="选题"><a href="#选题" class="headerlink" title="选题"></a>选题</h2><p>这个题目是我在 <a href="https://rubysummit.cn/" target="_blank" rel="noopener">RubySummit China</a> 2018 上的演讲题目。当时时间也比较紧，没有讲得特别深入；听众感觉大多数都还没有做过相关的开发，当场反馈也不是很好。回来后读了几篇新媒体稿件，把我读傻了。一路下来的感觉就是：</p><blockquote><p>我不是，我没有，我没讲过，我不是这个意思。</p></blockquote><p>既然如此，我也借此机会重新整理了一下。希望给听到或没有听到的各位重新梳理一下我对 Ruby 原生扩展开发的看法和建议。</p><h2 id="引"><a href="#引" class="headerlink" title="引"></a>引</h2><p>我从郑州东站出来后，打车去的会场。专车司机打电话给我用河南话一个劲地说：「在停车场 <strong>西南角</strong> <strong>西南角</strong>！」虽然河南话属于中原官话，听起来没困难，但关键是我根本分不清哪里是西南角，找了整整十五分钟才找到车。</p><p>写 Ruby 的原生扩展也是如此。</p><p>当你灵光乍现，感觉是不是应该写一个 Ruby 原生扩展的时候，脑海中可能会浮现如下的想法：</p><ul><li>写原生扩展能解决我的问题吗？</li><li>怎么写原生扩展？</li><li>我该选型哪一种原生扩展的开发方式？</li></ul><p>而我希望通过接下来的内容，在大家想到原生扩展时能打消掉上述的顾虑，清晰的知道自己要什么？怎么做。</p><h2 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h2><p>说到用开发 Ruby 的原生扩展，第一个反应就是提升性能。我们能提升多少性能？</p><p>（待续）</p><!-- 如果我们是单纯来提高性能的，我们为什么不直接写那些语言本身呢？比如我们刚刚提到的堆排序问题。谁会在生产中使用 Ruby 单独解决一个堆排序问题呢？## 插曲 -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;选题&quot;&gt;&lt;a href=&quot;#选题&quot; class=&quot;headerlink&quot; title=&quot;选题&quot;&gt;&lt;/a&gt;选题&lt;/h2&gt;&lt;p&gt;这个题目是我在 &lt;a href=&quot;https://rubysummit.cn/&quot; target=&quot;_blank&quot; rel=&quot;noopener
      
    
    </summary>
    
    
      <category term="编程" scheme="https://coderemixer.com/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="Ruby" scheme="https://coderemixer.com/tags/Ruby/"/>
    
  </entry>
  
</feed>
