<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>代码混音师</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://coderemixer.com/"/>
  <updated>2019-01-10T12:00:16.098Z</updated>
  <id>https://coderemixer.com/</id>
  
  <author>
    <name>CodeRemixer</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>平成最后的烂尾游戏——东京地下铁 2018 解谜游戏设计分析</title>
    <link href="https://coderemixer.com/2019/01/10/heisei-last-unfinished-game/"/>
    <id>https://coderemixer.com/2019/01/10/heisei-last-unfinished-game/</id>
    <published>2019-01-10T11:58:25.000Z</published>
    <updated>2019-01-10T12:00:16.098Z</updated>
    
    <content type="html"><![CDATA[<h2 id="序"><a href="#序" class="headerlink" title="序"></a>序</h2><p>这个几年来久闻东京地下铁解谜游戏的大名，一支没有完整地体验一下这个游戏。终于在去年年底的时候尝试了一下这款游戏。体验下来的感觉褒贬不一，所以我打算从游戏设计的角度，系统地来聊一聊这款游戏。</p><h2 id="游戏简介"><a href="#游戏简介" class="headerlink" title="游戏简介"></a>游戏简介</h2><p>游戏的基本流程就是在你购买完游戏套件（Kit）后，从你所在的车站开始，利用套件里提供的道具与车站及附近的现实场景进行交互，从而获得线索一步一步解开谜题。</p><p>游戏的设计公司是「SCRAP」，这家公司设计了大量类似的现实解谜游戏<a href="http://realdgame.jp/" target="_blank" rel="noopener">「リアル脱出ゲーム」</a>。游戏的监督是毕业于京都大学的<a href="https://www.facebook.com/hikaru.sakaidani" target="_blank" rel="noopener">「堺谷 光」</a>，在查阅资料的过程中找到了他的一篇游戏设计<a href="https://arxiv.org/pdf/1306.4884.pdf" target="_blank" rel="noopener">论文</a>，这篇论文对简单的 Tic Tac Toe 游戏进行发展，实现了一个策略复杂的棋类游戏，并对游戏数值进行了建模和演算。在游戏过程中，我感到了一种非常类似的<a href="https://zh.wikipedia.org/zh/%E6%A8%A1%E8%BF%9B" target="_blank" rel="noopener">「模进（Sequentia）」</a>发展的感觉，游戏设计了一些最基本的谜题思路（动机），通过在重复、变换和组合实现一个非常激动人心的游戏体验。</p><h2 id="分支与引导设计"><a href="#分支与引导设计" class="headerlink" title="分支与引导设计"></a>分支与引导设计</h2><p>游戏的一个 Puzzle 是一个基于鬼脚图（阿弥陀籤）变化的游戏。和鬼脚图不同的地方是，每个连接处都有一个图形。而游戏提示有一个图形不能被通过，而这时就引入了游戏中的第一个引导设计。在游戏的描述中希望你在 MINITIA 糖上找到一个黑色的图形，而这个图形就是那个不能被通过的图形。游戏的第二个谜题则是和网站上的<a href="http://realdgame.jp/chikanazo/5/renshu/index.html" target="_blank" rel="noopener">「練習問題」</a>类似的设计，通过メトロ的站名与编号之间的转换来解开谜题。</p><p>这里给出了游戏第一个设计上的巧思。第一、因为这个 MINITIA 糖就出现在了游戏提供的套件中，隐含了游戏的第一个要点「你需要巧妙使用套件里的东西」。第二、游戏套件封面上有站点的地图，并标出了游戏所有可能发生的车站站名，查询车站编号时无疑这里查起来更快。然而，对于鬼脚图谜题实际上一共只有 4 个图形，试一下就做出来了；而车站名谜题 Google 一下也有了。于是这两处引导显得非常不必需，而一旦错过，却在之后会非常痛苦。</p><p>经过了第一、第二个谜题，游戏进入了分支路线。玩家可以从三对地点中选择自己的分支。由于我从新宿站出发，我选择的是四谷和千駄木。这一点很好照顾了不同出发地点的玩家。与其说是分支，不如说是聚合，把不同地方开始的玩家，通过不同的引导方式，最终指引到唯一的地方去。这种设计非常值得 Ingress Mission Day 设计，Ingress 目前的线下活动，要么是线性的，要么就是无顺序的，使得游戏体验很难在乐趣和多元间达到平衡，而这处分支引导，则是一个非常柔性却非常有效的多路线设计。</p><h2 id="i18n-设计"><a href="#i18n-设计" class="headerlink" title="i18n 设计"></a>i18n 设计</h2><p>需要提到的是，这个游戏设计了双语的版本，提供了日本语和英语两个游戏选项。我手上的谜题是英文版的。游戏的设计者试图在抹平这两者的差异，但实际上两者的游戏难度却有很大的不同。这一点从我面临的第三、第四个难题（Mission 1）中有很大的体现。游戏设计者在此处大量设计了字谜，而日语字谜和英语字谜的原理有很大的不同。</p><p>日语的每个字母（仮名）都是一个音节，而英语的每个音节长短不一，且字母到音位并不是一个严格的映射关系。（P.S 谁真的严格按照 <a href="https://ai.googleblog.com/2017/12/tacotron-2-generating-human-like-speech.html" target="_blank" rel="noopener">Google Tacotron 2 论文</a>里描述的方法去训练 TTS AI 的，都尝过苦头吧）这使得凡是涉及字谜的部分，英文都变得简单很多。因为你非常容易通过排列组合上的尝试排除掉大量的选项。</p><p>这个问题最严重的地方就在于 Mission 2，直接把一个现实游戏变成了一款「云游戏」。虽然我知道我要去「京橋駅」解这个谜题，然而只需简单排列组合一下，我就直接解开了这个谜题。这一点在最终谜题（Final Mission）时也会得到体现。这一点我会在之后进一步提及。</p><h2 id="渐强设计"><a href="#渐强设计" class="headerlink" title="渐强设计"></a>渐强设计</h2><p>随着解开 Mission 2，游戏会通过一个过渡任务将你引向一个非常综合性的挑战。这个过渡任务是个纸笔游戏，并且介绍了游戏中纸张与笔的妙用（这一点在之后会被进一步用到）。在完成过渡游戏后，游戏会把你带到「渋谷」。</p><p>然后，在涩谷地下大迷宫里大暴走的可怕时间就到来了。然而一上来就给我玩了一处高级的，由于渋谷マークシティ正在进行促销活动，巨幅海报遮挡住了游戏正常流程中的必备道具，只在旁边放上一个很小的告示牌。涩谷的这个谜题非常综合，几乎要用到套件里的所有道具。这似乎是一个劝退点，如果不能解出这个谜题，几乎无法进行更后面的挑战，可以直接选择放弃。（于是在某个挑战进行的自動販売機前挤满了各种试图寻找答案的人（完全是迷惑行为吧））</p><p>这个谜题的体验非常好，几乎是这个游戏中让人觉得最巧妙的地方。</p><h2 id="Final-Mission-难度分支"><a href="#Final-Mission-难度分支" class="headerlink" title="Final Mission 难度分支"></a>Final Mission 难度分支</h2><p>在完成上述挑战后，游戏会给你一个过渡字谜游戏。这个字谜游戏我认为是这个游戏非常好的设计，却是非常糟糕的实践。这个谜题根据你前往终极问题的路上每站一个小字谜的解题表现，来决定你终极问题的难度。作为一个解谜游戏，又要做成一款阖家欢乐的游戏是非常难的，很难同时讨好解谜硬核玩家和休闲玩家。从想法上来说非常好。实践上糟糕的地方在于，题目描述得有问题，很多人甚至都没有看懂题目。而这个题目的糟糕之处更在于，在没看懂题目的情况下你竟然还可以正常做完。</p><p>但无论如何，这个谜题很好维持了完成综合性谜题后通往终极问题的紧张感。让你知道前方会有一个非常激动人心的挑战。</p><p>Final Mission 谜题的第一步被设计成一个迷你数独，虽然我没有严格证明一下，但大致可以确定是一个 NP Complete 问题。而根据 S、A、B 难度不同，谜题的已知部分不一样。我完成的是 S Rank 的 Final Mission 挑战，按理说应该很难，而且通过人来解一个很难的 NPC 问题，应该会耗费很大的精力。但这时候就要提到游戏刚刚那个 i18n 的败笔。我单纯排列组合一下，就直接找到了 Final Mission 的答案。</p><p>在提交答案后，游戏最后对你手上的手册提出最后的谜题，在一系列纸币的综合挑战后，游戏就正式完成，给你播放通关动画。而这又带来了游戏的第二个大败笔，所谓的难度分支根本就形同虚设，无论你选择什么难度，在通关过程中没有任何差别。这使得游戏渐强然后慢慢达到解谜的高潮的感觉完全违背，突然而来的结局，就好像小说写不下去突然把所有人都写死一样让人崩溃。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>从游戏开始的 10 点到最后通关的下午 5 点，整个游戏流程不满 7 个小时，期间看了三次的 Hint。游戏难度设计上我认为还是适中的，但也不是人人可以通关的难度。游戏的整体流程设计和铺垫可圈可点。但是由于游戏设计的重心失衡，和 i18n 设计上的严重失误，使得游戏体验并不算很完美。</p><p>通过这个游戏，我觉得我可以关注一下 SCRAP 其它的<a href="http://realdgame.jp/" target="_blank" rel="noopener">「リアル脱出ゲーム」</a>，至少这个游戏的形式设计得还是不错的。如果剧本能够更平衡一些，或者引入一些主线剧情想必会更好。另外就是，如果可以，我希望明年体验一下日文版的游戏，说不定会有更好的体验。</p><p>另外就是，我们神奈川乡下人进一次城真不容易。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;序&quot;&gt;&lt;a href=&quot;#序&quot; class=&quot;headerlink&quot; title=&quot;序&quot;&gt;&lt;/a&gt;序&lt;/h2&gt;&lt;p&gt;这个几年来久闻东京地下铁解谜游戏的大名，一支没有完整地体验一下这个游戏。终于在去年年底的时候尝试了一下这款游戏。体验下来的感觉褒贬不一，所以我打算从
      
    
    </summary>
    
    
      <category term="游戏" scheme="https://coderemixer.com/tags/%E6%B8%B8%E6%88%8F/"/>
    
      <category term="设计" scheme="https://coderemixer.com/tags/%E8%AE%BE%E8%AE%A1/"/>
    
      <category term="混合现实" scheme="https://coderemixer.com/tags/%E6%B7%B7%E5%90%88%E7%8E%B0%E5%AE%9E/"/>
    
  </entry>
  
  <entry>
    <title>Ant Design 错了吗？</title>
    <link href="https://coderemixer.com/2018/12/25/is-antd-wrong/"/>
    <id>https://coderemixer.com/2018/12/25/is-antd-wrong/</id>
    <published>2018-12-25T13:43:54.000Z</published>
    <updated>2018-12-25T14:01:50.354Z</updated>
    
    <content type="html"><![CDATA[<h2 id="引"><a href="#引" class="headerlink" title="引"></a>引</h2><p>Ant Design 今天的<a href="https://github.com/ant-design/ant-design/issues/13848" target="_blank" rel="noopener">圣诞门</a>闹得沸沸扬扬，Ant Design 内建的圣诞彩蛋在各个使用 antd 的产品中被「强制」弹出，令许多人措手不及，造成了很大的社会影响。但事实上，Ant Design 使用的是 MIT LICENSE，完全是一个使用者「后果自负」的协议。然而，Issue 里哭天喊地要开发者「负责」的舆论却又一面倒。</p><p>在此，我要问一个问题：「Ant Design 错了吗？」</p><p>​<img src="/static/is-ali-wrong.jpg" alt="is-ali-wront"></p><p>就我来看，毋庸置疑，错了。</p><p>但这篇文章讨论的是以下几点：</p><ul><li>Ant Design 犯了什么错？</li><li>开源的权利与责任的界限在哪里？</li><li>我们应当怎么从这个事件中获取教训？</li></ul><h2 id="Ant-Design-犯了什么错？"><a href="#Ant-Design-犯了什么错？" class="headerlink" title="Ant Design 犯了什么错？"></a>Ant Design 犯了什么错？</h2><p>从产品的角度来看，这个彩蛋，连彩蛋的定义都不符合。彩蛋（Easter Eggs）是一个隐藏在程序中的信息，而不是突然糊在你脸上的定时炸弹。所以从想出这个问题的那个人就已经不太对劲了。但我们抛开这个产品的问题，从实现上，这个 <code>Santa.jsx</code> 文件也同样是非常糟糕。作为一个组件级项目，很多人会对组件样式做二次开发，这一坨硬编码（Hardcoded）并没有起到它彩蛋的作用，相反还把很多网站弄得一团糟。如果你试图阅读过 Ruby 的代码，你往往会发现 Ruby 有那么多错误命名的 C API 为什么一直不把它改对呢？因为这种语言级别的东西，你无法确定用户是怎么使用的时候，就必须保持最低限度的兼容。Ant Design 也是如此。</p><p>然而「人主之患在莫之应，故曰：一手独拍，虽疾无声。」导致 Ant Design 问题的，不单单是彩蛋本身的错，更大的是 Ant Design 开源社区开发流程的问题。或者换一句话说：是软件工程的问题。</p><p>如果我们现在要往一个开源项目中加入一个不合适的东西，其实并不那么容易。Ant Design 有基于 GitHub Pull Request 系统的 Code Review 机制。一个并非紧急的代码，为什么可以直接跳过 Code Review 直接推上去？Ant Design 作为一个组件级的基础项目，到底应该怎么设计测试？</p><p>这个 <a href="https://github.com/ant-design/ant-design/commit/f706e2554f706b4e47f0c0cb3bcada1fe24dc32d" target="_blank" rel="noopener">2017 年 12 月 25 日</a> 写下的代码，写入到发作的这一年中，暴露的并不是谁的错，而是这个项目本身就是一个错误。</p><h2 id="如何运行一个开源项目？"><a href="#如何运行一个开源项目？" class="headerlink" title="如何运行一个开源项目？"></a>如何运行一个开源项目？</h2><p>Ant Design 错了，需要检讨，需要反省，需要道歉。但另一方面，在 Issue 下大骂「要阿里负责，要阿里赔偿」的则是走向了另一个极端。今天的开源项目，在使用常见的 Copyleft 许可证的情况下，大多数（包含且不止包含 MIT、BSD、GPLv2、GPLv3、AGPLv3、LGPLv3、MPL 2.0、Apache License 2.0、The Unlicensed）都在许可证中明确写了，不包括任何保修的条款，使用者自行负责。这让很多人听起来匪夷所思，觉得 Ant Design 一个阿里的产品，怎么也是阿里在背书。然而事实上，可能除了信誉，没有规定任何东西是实质的背书。前几天有人在 Ruby China 上开了个<a href="https://ruby-china.org/topics/37902" target="_blank" rel="noopener">帖子</a>问：</p><blockquote><p>到某某网站上浏览时，发现上面说，以上版本均需获取商业授权，方可做商业运营使用，既然是开源的，咋还涉及到商业授权啊，不理解，请指教。谢谢！</p></blockquote><p>然而版权的实际情况却恰恰相反。源代码放出来只是让你看，并不能让你用。就像别人放在那里的芒果，你不能寻思是别人不要了吧。代码是不是开源，需要取决于使用什么授权协议。哪怕是 GPL 的 RedHat 也有卖商业服务的。如果人家没有设定任何授权协议的话，那就只能默认是 Copyright 私有了。而只有签了具体包含保修责任的条款的协议后，对方才有保修的义务。不然，我自己写着玩开源出来，你用的时候也已经同意免责了。你用出问题了为什么要来找我呢？有问题你自己 fork 了改不就好了？</p><p>这就牵扯到了另一个问题：开源的社会价值。当一个开源产品，比如 Ant Design，有大量的用户在使用的时候，对于这个开源社区的期待是完全不同的。这也是为什么世界上大多数的大型开源项目，都有一个庞大的组织在维护着。其目的很大程度上，就是要维护代码的可靠性，担负起其社会价值。<del>你觉得阿里价值观能担负起社会价值吗？</del></p><p>有人在我微博下呛：</p><blockquote><p>照右边这个逻辑的话，广大 MIT 框架作者应该纷纷往自己代码加挖矿，这世界不需要开源，人与人也不需要信任。别人写好的高级语言也别用啊，一起汇编起来。</p></blockquote><p>然而事实上，如果你愿意找一下，GitHub 上许多 MIT 项目是有暗藏挖矿的，甚至还有暗藏后门的。至于「别人写好的高级语言也别用啊」也是如此，UNIX 创始人 Ken Thompson 在 30 年前获得图灵奖的获奖演说中，就有提到这种类似的暗藏在 C 语言编译器中的手段实现攻击。这也是为什么一方面 C 语言编译器也有一套复杂的自举发布流程，像 gcc 还会有严格的代码审查机制来避免这种问题的发生。然而甚至硬件本身，也不是 100% 可信的。这不是「人与人的信任」问题，相反，就算 100% 相信别人不去做坏事，但是由于人都会犯错，总会做出错误的东西，我们需要的是通过机制来避免它发生。</p><p>在以前一个非常有名的 NVIDIA 开源驱动的维护项目 <a href="https://github.com/MrMEEE/bumblebee-Old-and-abbandoned/issues/123" target="_blank" rel="noopener">bumblebee</a> 中就有出现过开发者疏失，导致更新的用户直接把所有的 <code>/usr</code> 用户文件不小心删了个精光。甚至<a href="https://www.omgubuntu.co.uk/2013/11/nsa-ask-linus-torvalds-include-backdoors-linux-father-says-yes" target="_blank" rel="noopener">有人</a>曾试图通过给 Linux 项目提交 patch 的形式，将后门埋入操作系统中。并且这些看起来不经意的错误，甚至会使得一些人为的 Code Review 失效，所以 Linux 还有复杂的安全性和回归测试来保证其可靠性。</p><p>如果这不是无意的行为，而是有意的。那么对于开源世界，我们有个更简单的方法：fork。我们只要分叉一个自己的版本，自己维护自己负责就可以了。MySQL 被 Oracle 收购后，虽然 Oracle 暂时还没有做什么坏事，大家为了谨防这种情况发生，就有一些开发者 fork 出了 MariaDB。</p><p>但是，我也反过来问一句：你 fork 后的项目，你真的能维护得更好吗？</p><p>软件工程是一个复杂而庞大的东西，把七个积木搭在一起，和把七千万块积木堆在一起是完全不同的系统工程问题。开源软件的管理看起来松散，于是更需要设计合理的制度防范于未然。在挑选开源项目的时候，并不只是挑一个能用的就行了，对于其质量、维护能力、开源协议都必须是评估的内容。我不是在说「用开源的东西不审查代码，出了问题活该」，但是什么都不看，不出问题才奇怪吧？</p><h2 id="教训"><a href="#教训" class="headerlink" title="教训"></a>教训</h2><p>为什么包括谷歌微软在内的大公司，在使用别人的开源项目时，都要经过内部审查。虽然不至于精确到每行代码，但也要大致确认一下这个项目的状况。这也是为什么，Facebook 之前内部许可证事件沸沸扬扬，因为这真的很重要。就好像，警察在努力阻止盗窃案的发生，但我们自身平时就要做好防范，而不能大门敞开，出了事去骂警察吧。</p><p>然而现实的情况却是，用 Ant Design 的本来就是一群想用个组件库草草了事的人，根本没有可能去参与到开源项目的审查中。而 Ant Design 目前草率的开发流程，确实也无法承担如此大的社会责任。如果今天不是「偏右」的圣诞节代码出了问题，明天后天一样会出别的问题。如果今天是「偏右」辞退就来平息风波，那么明天后天 Ant Design 还是会继续出问题（<del>毕竟是阿里嘛</del>）。</p><p>​<img src="/static/judge.png" alt="judge"></p><p>今天 Ant Design 的问题是一个典型的软件工程问题，让任何一个个人来负责，都只是息事宁人的策略，并不能从根本上解决问题。对于一个「开发公司 HR 工具的离职谈话功能推到开发者头上；匿名表达对老员工，特别是对彭姓员工不满，大老板可能含沙射影地让你滚；用脚本在公司网站抢月饼，可能违反价值观」的公司，你指望它在软件工程上有秩序吗？</p><p>我觉得你在做梦。</p><p>总结一下：</p><ul><li>开源项目本身并没有所谓的「责任」的概念，你要有自己评估其可靠性的能力，并承担风险。</li><li>评估可靠性不在于其背后是多大的公司，更在于其是否有健全的开发流程，因为人为疏失不可避免。</li><li>越是底层、组件级的项目对于可靠性的要求越高。</li><li>只要不是主观上故意犯错误，我们更应该检讨我们的系统工程，而不单单是检讨个人。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;引&quot;&gt;&lt;a href=&quot;#引&quot; class=&quot;headerlink&quot; title=&quot;引&quot;&gt;&lt;/a&gt;引&lt;/h2&gt;&lt;p&gt;Ant Design 今天的&lt;a href=&quot;https://github.com/ant-design/ant-design/issues/138
      
    
    </summary>
    
    
      <category term="阿里巴巴" scheme="https://coderemixer.com/tags/%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B4/"/>
    
      <category term="前端" scheme="https://coderemixer.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="开源" scheme="https://coderemixer.com/tags/%E5%BC%80%E6%BA%90/"/>
    
  </entry>
  
  <entry>
    <title>[Ruby Quiz] Base32 字母表 —— 加密猫基因解码</title>
    <link href="https://coderemixer.com/2018/12/08/ruby-quiz-base32/"/>
    <id>https://coderemixer.com/2018/12/08/ruby-quiz-base32/</id>
    <published>2018-12-08T01:54:43.000Z</published>
    <updated>2018-12-08T01:58:48.756Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/static/cryptokitties.png" alt="Crypto Kitties"></p><p>刚刚在 ruby-talk 的邮件列表读到一个很有意思的 Ruby Quiz，题目可以<a href="https://github.com/planetruby/quiz/tree/master/008" target="_blank" rel="noopener">见此</a>。想到好久没有看到 Ruby Quiz 了，就做了并翻译了一下。</p><h2 id="题目翻译"><a href="#题目翻译" class="headerlink" title="题目翻译"></a>题目翻译</h2><p>庆祝 CryptoKitties 一周年 —— 区块链上诞生了超过 100 万只可爱的小猫！</p><p>我们来尝试转换 “sekretoooo” 加密猫的基因，一个 240 位的整数，以每 5 位进行分割，再通过 base32 (2^5=32) 进行转换，转至 kai 标注。</p><p>Q: 什么是 kai 标注？</p><p>Kai 标注（因为 <a href="https://medium.com/@kaigani/the-cryptokitties-genome-project-on-dominance-inheritance-and-mutation-b73059dcd0a4" target="_blank" rel="noopener">Kai Turner</a> 解码了加密猫的基因而命名）是一种针对 240 位整数分割成 5 位块的 base58 的变种（子集）。每个 5 位块含有 32 种可能性，240 位基因可以给分割成 12 组，每组 4 (x 5 位）基因。</p><p>举例：</p><table><thead><tr><th>Kai</th><th>Binary</th><th>Num</th><th>Kai</th><th>Binary</th><th>Num</th><th>Kai</th><th>Binary</th><th>Num</th><th>Kai</th><th>Binary</th><th>Num</th></tr></thead><tbody><tr><td><strong>1</strong></td><td>00000</td><td>00</td><td><strong>9</strong></td><td>01000</td><td>08</td><td><strong>h</strong></td><td>10000</td><td>16</td><td><strong>q</strong></td><td>11000</td><td>24</td></tr><tr><td><strong>2</strong></td><td>00001</td><td>01</td><td><strong>a</strong></td><td>01001</td><td>09</td><td><strong>i</strong></td><td>10001</td><td>17</td><td><strong>r</strong></td><td>11001</td><td>25</td></tr><tr><td><strong>3</strong></td><td>00010</td><td>02</td><td><strong>b</strong></td><td>01010</td><td>10</td><td><strong>j</strong></td><td>10010</td><td>18</td><td><strong>s</strong></td><td>11010</td><td>26</td></tr><tr><td><strong>4</strong></td><td>00011</td><td>03</td><td><strong>c</strong></td><td>01011</td><td>11</td><td><strong>k</strong></td><td>10011</td><td>19</td><td><strong>t</strong></td><td>11011</td><td>27</td></tr><tr><td><strong>5</strong></td><td>00100</td><td>04</td><td><strong>d</strong></td><td>01100</td><td>12</td><td><strong>m</strong></td><td>10100</td><td>20</td><td><strong>u</strong></td><td>11100</td><td>28</td></tr><tr><td><strong>6</strong></td><td>00101</td><td>05</td><td><strong>e</strong></td><td>01101</td><td>13</td><td><strong>n</strong></td><td>10101</td><td>21</td><td><strong>v</strong></td><td>11101</td><td>29</td></tr><tr><td><strong>7</strong></td><td>00110</td><td>06</td><td><strong>f</strong></td><td>01110</td><td>14</td><td><strong>o</strong></td><td>10110</td><td>22</td><td><strong>w</strong></td><td>11110</td><td>30</td></tr><tr><td><strong>8</strong></td><td>00111</td><td>07</td><td><strong>g</strong></td><td>01111</td><td>15</td><td><strong>p</strong></td><td>10111</td><td>23</td><td><strong>x</strong></td><td>11111</td><td>31</td></tr></tbody></table><p><strong>注意：数字 0 和字母 l 不会在 kai 中被使用。</strong></p><p>我们开始编程吧！举例来说：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># A 240-bit super "sekretoooo" integer genome</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># hexadecimal (base 16)</span></span><br><span class="line">genome = <span class="number">0x4a52931ce4085c14bdce014a0318846a0c808c60294a6314a34a1295b9ce</span></span><br><span class="line"><span class="comment"># decimal (base 10)</span></span><br><span class="line">genome = <span class="number">512955438081049600613224346938352058409509756310147795204209859701881294</span></span><br><span class="line"><span class="comment"># binary (base 2)</span></span><br><span class="line">genome = 0b01001010010100101001001100011100111001000000100001011100000101001011110111001110000000010100101000000011000110001000010<span class="number">0</span>\</span><br><span class="line">           <span class="number">011010100000110010000000100011000110000000101001010010100110001100010100101000110100101000010010100101011011100111001110</span></span><br></pre></td></tr></table></figure><p>我们可以把 10 进制数转换成 16 进制或 2 进制数：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">p genome    <span class="comment"># printed as decimal (base 10) by default</span></span><br><span class="line"><span class="comment"># =&gt; 512955438081049600613224346938352058409509756310147795204209859701881294</span></span><br><span class="line"></span><br><span class="line">p genome.to_s(<span class="number">16</span>)</span><br><span class="line"><span class="comment"># =&gt; "4a52931ce4085c14bdce014a0318846a0c808c60294a6314a34a1295b9ce"</span></span><br><span class="line"></span><br><span class="line">p genome.to_s(<span class="number">2</span>)</span><br><span class="line"><span class="comment"># =&gt; "10010100101001010010011000111001110010000001000010111000001010010111101110011100000000101001010000000110001100010000100\</span></span><br><span class="line"><span class="comment">#     011010100000110010000000100011000110000000101001010010100110001100010100101000110100101000010010100101011011100111001110"</span></span><br><span class="line"></span><br><span class="line">bin = <span class="string">'%0240b'</span> % genome     <span class="comment"># note: adds leading zeros - to_s(2) does not</span></span><br><span class="line">p bin.size</span><br><span class="line"><span class="comment"># =&gt; 240</span></span><br><span class="line">p bin</span><br><span class="line"><span class="comment"># =&gt; "010010100101001010010011000111001110010000001000010111000001010010111101110011100000000101001010000000110001100010000100\</span></span><br><span class="line"><span class="comment">#     011010100000110010000000100011000110000000101001010010100110001100010100101000110100101000010010100101011011100111001110"</span></span><br><span class="line"></span><br><span class="line">hex = <span class="string">'%060x'</span> % genome     <span class="comment"># note: adds leading zeros - to_s(16) does not</span></span><br><span class="line">p hex.size</span><br><span class="line"><span class="comment"># =&gt; 60</span></span><br><span class="line">p hex</span><br><span class="line"><span class="comment"># =&gt; 60</span></span><br><span class="line"><span class="comment"># =&gt; "4a52931ce4085c14bdce014a0318846a0c808c60294a6314a34a1295b9ce"</span></span><br></pre></td></tr></table></figure><p>最终要得到的效果是：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">kai = kai_encode( genome )   <span class="comment">## number to base32 kai notation</span></span><br><span class="line">p kai</span><br><span class="line"><span class="comment"># =&gt; "aaaa788522f2agff16617755e979244166677664a9aacfff"</span></span><br></pre></td></tr></table></figure><p>挑战：创建 <code>kai_encode</code> 方法并通过 RubyQuizTest :-).</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">kai_encode</span><span class="params">( num )</span></span></span><br><span class="line">  <span class="comment"># ...</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>对于 Level 1 挑战，你需要把 240 位整数转换成 Base 32 的 Kai 标注。<br>对于 Level 2 挑战，你要把结果 4 个 4 个进行分组，将</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"aaaa788522f2agff16617755e979244166677664a9aacfff"</span></span><br></pre></td></tr></table></figure><p>转换成</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"aaaa 7885 22f2 agff 1661 7755 e979 2441 6667 7664 a9aa cfff"</span></span><br></pre></td></tr></table></figure><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">kai_fmt</span><span class="params">( kai )</span></span></span><br><span class="line">  <span class="comment"># ...</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>你可以从头开始编码，也可以使用任何你想用的库 / gem。你需要通过如下的测试：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">require</span> <span class="string">'minitest/autorun'</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RubyQuizTest</span> &lt; MiniTest::Test</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">################################</span></span><br><span class="line">  <span class="comment"># test data</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">genomes</span></span></span><br><span class="line">     [</span><br><span class="line">       [<span class="number">0x00004a52931ce4085c14bdce014a0318846a0c808c60294a6314a34a1295b9ce</span>,</span><br><span class="line">        <span class="string">"aaaa 7885 22f2 agff 1661 7755 e979 2441 6667 7664 a9aa cfff"</span>]</span><br><span class="line">     ]  </span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">#############</span></span><br><span class="line">  <span class="comment"># tests</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">test_kai_encode</span></span></span><br><span class="line">    genomes.each <span class="keyword">do</span> <span class="params">|pair|</span></span><br><span class="line">      num       = pair[<span class="number">0</span>]</span><br><span class="line">      exp_value = pair[<span class="number">1</span>].gsub(<span class="string">' '</span>,<span class="string">''</span>)   <span class="comment"># note: remove spaces</span></span><br><span class="line"></span><br><span class="line">      assert_equal exp_value, kai_encode( num )</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">end</span> <span class="comment"># method test_kai_encode</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">test_kai_fmt</span></span></span><br><span class="line">    genomes.each <span class="keyword">do</span> <span class="params">|pair|</span></span><br><span class="line">      kai       = pair[<span class="number">1</span>].gsub(<span class="string">' '</span>,<span class="string">''</span>) <span class="comment"># remove spaces</span></span><br><span class="line">      exp_value = pair[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">      assert_equal exp_value, kai_fmt( kai )</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">end</span> <span class="comment"># method test_kai_fmt</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span> <span class="comment"># class RubyQuizTest</span></span><br></pre></td></tr></table></figure><p>注：对于解码后与基因的对应关系表实在太长了，而且和题目无关。如果想看可以查<a href="https://github.com/planetruby/quiz/blob/master/008/README.md" target="_blank" rel="noopener">原文</a>。</p><h2 id="剧透时间"><a href="#剧透时间" class="headerlink" title="剧透时间"></a>剧透时间</h2><p>我想出来的使用 Ruby 的一行解：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">kai_encode</span><span class="params">(num)</span></span></span><br><span class="line">  num.to_s(<span class="number">2</span>).rjust(<span class="number">240</span>, <span class="string">'0'</span>).scan(<span class="regexp">/.&#123;5&#125;/</span>).map &#123;<span class="params">|n|</span> <span class="string">'123456789abcdefghijkmnopqrstuvwx'</span>[n.to_i(<span class="number">2</span>)]&#125;.join</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">kai_fmt</span><span class="params">(kai)</span></span></span><br><span class="line">  kai.scan(<span class="regexp">/.&#123;4&#125;/</span>).join(<span class="string">' '</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">kai_encode(<span class="number">0x00004a52931ce4085c14bdce014a0318846a0c808c60294a6314a34a1295b9ce</span>) <span class="comment"># =&gt; "aaaa788522f2agff16617755e979244166677664a9aacfff"</span></span><br><span class="line">kai_fmt(kai_encode(genome)) <span class="comment"># =&gt; "aaaa 7885 22f2 agff 1661 7755 e979 2441 6667 7664 a9aa cfff"</span></span><br></pre></td></tr></table></figure><p>好在 Ruby 的 <code>rjust</code> 方法是内建的，而不需要 import 一个叫 <code>left-pad</code> 的包，一旦被删除了就天下大乱了（逃</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/static/cryptokitties.png&quot; alt=&quot;Crypto Kitties&quot;&gt;&lt;/p&gt;
&lt;p&gt;刚刚在 ruby-talk 的邮件列表读到一个很有意思的 Ruby Quiz，题目可以&lt;a href=&quot;https://github.com/
      
    
    </summary>
    
    
      <category term="Ruby" scheme="https://coderemixer.com/tags/Ruby/"/>
    
      <category term="Ruby Quiz" scheme="https://coderemixer.com/tags/Ruby-Quiz/"/>
    
  </entry>
  
  <entry>
    <title>十分钟速通 Y Combinator</title>
    <link href="https://coderemixer.com/2018/12/07/y-combinator-in-ten-minutes/"/>
    <id>https://coderemixer.com/2018/12/07/y-combinator-in-ten-minutes/</id>
    <published>2018-12-07T07:44:33.000Z</published>
    <updated>2018-12-07T11:39:51.544Z</updated>
    
    <content type="html"><![CDATA[<h2 id="引"><a href="#引" class="headerlink" title="引"></a>引</h2><p>这学期在学校选了一门讲可计算性（Computability）的计算机科学基础课程。过程中也把很多概念给自己重新复习了一下，不过从这课课堂的反馈来看，可以说同学都听得非常吃力。我想到几年前我有尝试写过一篇通过 Y 组合子来讨论 Lambda 演算的文章，考虑到当时写得很不完善，我打算拿出来重新炒一下冷饭。顺便改使用傻子都能看懂的 JavaScript 来描述这个问题。顺便调试一下我博客系统 Markdown 引入 $\LaTeX$ 后会遇到的坑。</p><h2 id="循环-gt-递归"><a href="#循环-gt-递归" class="headerlink" title="循环 -&gt; 递归"></a>循环 -&gt; 递归</h2><p>我们还是从下面这个简单的循环问题开始探讨。通过写一个循环（不使用等差数列的情况下），求自然数列 1 到 n 的和（即 $1+2+3+…+n$）。一个最容易想到的实现可能如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> result = <span class="number">0</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    result += i</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sum(<span class="number">10</span>) <span class="comment">// =&gt; 55</span></span><br></pre></td></tr></table></figure><p>我们现在对这个问题稍作变形，如果在这个程序中不得使用 <code>for</code> 循环，我们还能实现这个程序吗？显然这也是非常简单的，因为我们还可以用 <code>while</code> 循环。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> result = <span class="number">0</span></span><br><span class="line">  <span class="keyword">let</span> counter = <span class="number">1</span></span><br><span class="line">  <span class="keyword">while</span> (counter &lt;= n) &#123;</span><br><span class="line">    result += counter</span><br><span class="line">    counter++</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sum(<span class="number">10</span>) <span class="comment">// =&gt; 55</span></span><br></pre></td></tr></table></figure><p>或者进一步地，我们可以写成：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> result = <span class="number">0</span></span><br><span class="line">  <span class="keyword">let</span> counter = <span class="number">1</span></span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (counter &gt; n) <span class="keyword">break</span></span><br><span class="line">    result += counter</span><br><span class="line">    counter++</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sum(<span class="number">10</span>) <span class="comment">// =&gt; 55</span></span><br></pre></td></tr></table></figure><p>抽象地来看，我们这里使用到的 <code>counter</code> 变量，既可以看成是循环变量，更可以看成是一个程序计数器。也就是从一个状态转移到下一个状态的过程，而 <code>break</code> 则是指出了终止状态发生的位置。我们现在对这个题目进行进一步地变形，如果我们不允许在这里使用包括 <code>while</code> 在内的任何循环，我们还能实现这个程序吗？</p><p>我们不但能，而且程序写起来更简单了。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (n === <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">  <span class="keyword">return</span> sum(n - <span class="number">1</span>) + n</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sum(<span class="number">10</span>) <span class="comment">// =&gt; 55</span></span><br></pre></td></tr></table></figure><p>这个写法可以优雅地由数学形式表示：</p><p>$$<br>sum(x)=<br>\begin{cases}<br>  0 &amp;x = 0 \cr<br>  sum(x-1) + x &amp;otherwise<br>\end{cases}<br>$$</p><p>也就是我们只需要定义 $sum(0) = 0$，然后无论求什么的和，都是其之前所有数的和加上当前这个数。计算机会一次一次向下找，直到找到 0 为止，最后把找到的数全部加起来。解决！当然你可能会觉得这么做的效率很低，计算机不停递归会影响性能，我们会在之后讨论这个问题，我们目前暂时先只讨论「可计算性」上的等价。</p><h2 id="匿名函数化"><a href="#匿名函数化" class="headerlink" title="匿名函数化"></a>匿名函数化</h2><p>「$\lambda$ 演算」和我们刚刚那个例子很接近，但是又稍有不同。我们先抛开「$\lambda$ 演算」本身复杂的定义，从其性质入手，就可以简单对「$\lambda$ 演算」有直观的认识。</p><ul><li>如果有这么一个式子 $\lambda x.x$，那么 <code>x</code> 就是一个变量。对于一个变量，我们可以任意更换其名字，比如可以从 <code>x</code> 改成 <code>y</code>，得到 $\lambda y.y$，这一步称作「$\alpha$ 等价」。</li><li>如果有形如一个式子 $(\lambda x.x+1)(1)$，我们可以把后面的 <code>1</code> 替代掉前面的 <code>x</code>，即 $(\lambda x.x+1)(1) = 1+1 = 2$，这一步称作「$\beta$ 规约」。</li></ul><p>如果你对符号不敏感，可能看到这里有点晕。但如果你敏感一点的话，就会发现这里其实只不过是换了一个说法的「匿名函数」而已。像我们之前的例子里，我们定义函数都要起一个函数名。但如果我们一次性使用这个函数，我们完全可以不命名，定义完接受的参数和运算方法直接执行即可，这就是所谓的「匿名函数」。用 JavaScript 的语言来描述的话如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// alpha 等价</span></span><br><span class="line">(x) =&gt; x</span><br><span class="line">(y) =&gt; y</span><br><span class="line"><span class="comment">// 这两个东西是等价的</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// beta 规约</span></span><br><span class="line">(<span class="function">(<span class="params">x</span>) =&gt;</span> x + <span class="number">1</span>)(<span class="number">1</span>) <span class="comment">// =&gt; 1 + 1 =&gt; 2</span></span><br></pre></td></tr></table></figure><p>如果你不熟悉 ES6 的箭头函数，用 ES5 写的话如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// alpha 等价</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> (<span class="params">x</span>) </span>&#123; <span class="keyword">return</span> x &#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> (<span class="params">y</span>) </span>&#123; <span class="keyword">return</span> y &#125;</span><br><span class="line"><span class="comment">// 这两个东西是等价的</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// beta 规约</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">x</span>) </span>&#123; <span class="keyword">return</span> x + <span class="number">1</span> &#125;)(<span class="number">1</span>) <span class="comment">// =&gt; 1 + 1 =&gt; 2</span></span><br></pre></td></tr></table></figure><p>换句话说，也就是说「$\alpha$ 等价」说明了匿名函数中的变量名不会影响运算结果，而「$\beta$ 规约」就是去执行这个匿名函数而已。</p><h2 id="为什么？"><a href="#为什么？" class="headerlink" title="为什么？"></a>为什么？</h2><p>我们之前讨论了一个递归和循环的例子，这和「匿名函数」有什么关系呢？我们可以看到，我们现在的匿名函数看起来很方便，但是实际上用来实现递归和循环听起来就很奇怪。首先，纯「$\lambda$ 演算」并没有像是 <code>while</code> 或 <code>for</code> 这样的循环命令。不过好在我们刚刚发现，所有的循环都可以被我们转换成递归</p><p>递归听起来就和函数更相关一些，不过我们又产生了一个新问题：递归时，我们需要具名地指定我们递归调用那个函数。而我们现在的函数，没有名字。我们还能实现递归吗？</p><h3 id="尝试"><a href="#尝试" class="headerlink" title="尝试"></a>尝试</h3><p>我们先大致写一个类似递归的匿名函数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function">(<span class="params">n</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (n === <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">  <span class="keyword">return</span> n + <span class="comment">// 我不知道这里要加什么东西</span></span><br><span class="line">&#125;)(<span class="number">10</span>) <span class="comment">// 应该要输出 55</span></span><br></pre></td></tr></table></figure><p>不过既然递归要调用一个函数，我们先假设我们存在这个函数，将其命名为 <code>f</code>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function">(<span class="params">n</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (n === <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">  <span class="keyword">return</span> n + f(n - <span class="number">1</span>)</span><br><span class="line">&#125;)(<span class="number">10</span>) <span class="comment">// 应该要输出 55</span></span><br></pre></td></tr></table></figure><p>我们可以想象，对于匿名函数，如果没有全局变量，那么其获取数据的来源是唯一的，那就是参数。那我们为什么不把我们想要的函数 <code>f</code> 作为参数呢？</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function">(<span class="params">f, n</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (n === <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">  <span class="keyword">return</span> n + f(n - <span class="number">1</span>)</span><br><span class="line">&#125;)(<span class="number">10</span>) <span class="comment">// 应该要输出 55</span></span><br></pre></td></tr></table></figure><p>这样似乎已经快到我们想要的结果了，既然我们加了一个参数 <code>f</code>，那么在执行的时候，这个 <code>f</code> 又是多少呢？答案很简单，就是这个匿名函数自己。匿名函数不能起名字，但其本身还是可以作为参数传递啊，于是我们得到了：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function">(<span class="params">f, n</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (n === <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">  <span class="keyword">return</span> n + f(f, n - <span class="number">1</span>)</span><br><span class="line">&#125;)(<span class="function">(<span class="params">(f, n</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (n === <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">  <span class="keyword">return</span> n + f(f, n - <span class="number">1</span>)</span><br><span class="line">&#125;), <span class="number">10</span>) <span class="comment">// # =&gt; 55</span></span><br></pre></td></tr></table></figure><p>解决！我们使用了纯匿名函数解决了这个问题。</p><h3 id="Y-组合子"><a href="#Y-组合子" class="headerlink" title="Y 组合子"></a>Y 组合子</h3><p>那什么是 Y 组合子（Y Combinator）呢？Y 组合子不过是解决这一类问题的通用方案而已。Y 组合子的定义是</p><p>$$<br>Y := \lambda f.(\lambda x.(f (x\ x)) \lambda x.(f (x\ x)))<br>$$</p><p>听起来挺搞脑子的，不过如果我们代入任何一个东西算一下的话，就会发现其实很简单。如果我们存在一个函数 <code>g</code>，那么：</p><p>$$<br>\begin{align}<br>  Y\ g &amp; = \lambda f.(\lambda x.(f (x\ x)) \lambda x.(f (x\ x))) g \\<br>  &amp; = \lambda x.(g (x\ x)) \lambda x.(g (x\ x)) \\<br>  &amp; = \lambda y.(g (y\ y)) \lambda x.(g (x\ x)) \\<br>  &amp; = (g (\lambda x.(g (x\ x)) \lambda x.(g (x\ x)))) \\<br>\end{align}<br>$$</p><p>而同时：</p><p>$$<br>\begin{align}<br>  g (Y\ g) &amp; = g (\lambda f.(\lambda x.(f (x\ x)) \lambda x.(f (x\ x))) g) \\<br>  &amp; = (g (\lambda x.(g (x\ x)) \lambda x.(g (x\ x)))) \\<br>\end{align}<br>$$</p><p>故 $Y g = g (Y\ g) = g (g (Y\ g)) = g (g (g (Y\ g))) $，也就是对于任意函数都能实现递归。</p><p>这里我们再使用 JavaScript 来实现一下 Y 组合子版的自然数列 1 到 n 的和：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// \lambda f.(\lambda x.(f (x x)) \lambda x.(f (x x)))</span></span><br><span class="line"><span class="keyword">const</span> Y = <span class="function"><span class="params">fn</span> =&gt;</span> (<span class="function"><span class="params">f</span> =&gt;</span> fn(<span class="function"><span class="params">x</span> =&gt;</span> f(f)(x)))(<span class="function"><span class="params">f</span> =&gt;</span> fn(<span class="function"><span class="params">x</span> =&gt;</span> f(f)(x)))</span><br><span class="line"></span><br><span class="line">g = <span class="function"><span class="params">f</span> =&gt;</span> n =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (n === <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">  <span class="keyword">return</span> n + f(n - <span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Y(g)(<span class="number">10</span>) <span class="comment">// =&gt; 55</span></span><br></pre></td></tr></table></figure><h3 id="不动点组合子"><a href="#不动点组合子" class="headerlink" title="不动点组合子"></a>不动点组合子</h3><p>你也许听过 Y 组合子是一类不动点组合子。不动点组合子究竟是什么意思呢？组合子是一种消除变量的函数。在 Y 组合子中你可以看到并没有用任何 <code>let</code> <code>var</code> <code>const</code> 之类的变量定义，而是通过一系列参数传递消除了这一过程。而至于不动点，你可能在初中的代数课本上学习过「不动点」的概念，这在这里几乎是一样的。通常我们眼中的不动点，即在函数 $f(x) = y$ 上找到一个值 <code>x</code> 使得 $x = f(x)$。比如对于函数 $f(x) = x^2 - 1$，就有两个不动点 1 和 -1。</p><p>但是初中的代数中的这个不动点的定义其实是一个简化版本。事实上所谓找到一个「值」<code>x</code>，也可以被表述成「找到一个『函数』」<code>g(x)</code>，使得 $g(x) = f(g(x))$。而值 <code>x</code> 是这个 <code>g(x)</code> 的一个特例，即常值函数 <code>g(x) = c</code>（c 是一个常数）。</p><p>这样我们就不难理解不动点组合子的意义了。我们找到一个函数 <code>Y</code>，使得 $Y\ g = g(Y\ g)$。这就是所谓的不动点组合子。</p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>费了那么大劲到底干什么？因为图灵机、递归和 $\lambda$ 演算被证明在可计算性上是等价的，如果存在一个问题（比如递归或者循环）在其中一种可计算，在另一种不可计算。这是有悖于数学原理的。而更重要的是，我们基于 Y 组合子这个例子，可以一次性将图灵机、递归和 $\lambda$ 演算的知识一次性串联起来，建立一个对可计算性的直观系统的理解。</p><p>岂不是很好吗？</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;引&quot;&gt;&lt;a href=&quot;#引&quot; class=&quot;headerlink&quot; title=&quot;引&quot;&gt;&lt;/a&gt;引&lt;/h2&gt;&lt;p&gt;这学期在学校选了一门讲可计算性（Computability）的计算机科学基础课程。过程中也把很多概念给自己重新复习了一下，不过从这课课堂的反馈来看，
      
    
    </summary>
    
    
      <category term="JavaScript" scheme="https://coderemixer.com/tags/JavaScript/"/>
    
      <category term="Lambda 演算" scheme="https://coderemixer.com/tags/Lambda-%E6%BC%94%E7%AE%97/"/>
    
  </entry>
  
  <entry>
    <title>部署家中网络的流水帐</title>
    <link href="https://coderemixer.com/2018/11/26/home-network-fujisawa/"/>
    <id>https://coderemixer.com/2018/11/26/home-network-fujisawa/</id>
    <published>2018-11-26T10:37:47.000Z</published>
    <updated>2018-11-26T11:58:45.682Z</updated>
    
    <content type="html"><![CDATA[<h2 id="引"><a href="#引" class="headerlink" title="引"></a>引</h2><p>我今年 9 月搬家到了藤泽，签了一个非常恶心人的 Softbank 的网络合约之后，花了大半个月才搞清楚这个网络的状况。于是就基于自己的需求，在家中部署了多项服务。今天写这篇文章就是来分享一下部署过程中遇到的困难以及解决的方案。</p><h2 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h2><ol><li>能够有稳定的有线、无线网络</li><li>每个设备都有 IPv6 支持</li><li>访问学校资源时自动通过 VPN 连接学校内网</li><li>在局域网内提供 NAS 服务</li><li>在局域网内提供私有 git 服务来维护代码</li><li>支持通过 VPN 访问家中网络</li><li>对外提供 Web 网络服务</li></ol><p>之所以定成这样有几个理由。一个是我从来不相信所谓的云网盘，一定要自己存文件才是安全的。其次是经过测试，我的网络基于 IPv6 的传输速度比 IPv4 快不少，上下行都能稳定在 600Mbps 左右。这也使得家中不止要有无线网络，千兆有线网络对于压榨性能也是必不可少的。</p><p>为了达成这个网络部署，前后也是经历了两三个月时间细心打磨方案，下面就是具体的过程。</p><h2 id="网络拓扑"><a href="#网络拓扑" class="headerlink" title="网络拓扑"></a>网络拓扑</h2><p><img src="/static/home-network.jpg" alt="Home Network"></p><p>光纤自 NTT 的 GPON 接入 Softbank 的路由。之所以要接入 Softbank 的路由而不是直接接在自己的路由上，是因为 Softbank 使用了一个非常诡异的 IPoE + IPv6 的网络分配形式。其 IPv4 的地址是基于 IPoE 下发的，而其鉴权过程写死在了其定制的路由器中。如果使用 PPPoE 进行拨号，没有办法达到最高的网速，经过实测，PPPoE 只能达到 30Mbps 上下行对等的速度。</p><h2 id="路由系统"><a href="#路由系统" class="headerlink" title="路由系统"></a>路由系统</h2><p>路由进来后就需要考虑自己的路由系统了，由于这个 Softbank 富士康路由器能调的选项实在是太少，有必要弄一个自己的路由器。考虑到我还打算部署服务，于是就决定弄一个服务器，通过虚拟化的方式来实现。既然说到虚拟化，那么面向个人免费的 ESXi 就是个不错的选择，挑一个对 ESXi 兼容性比较好的，适合放在家里的服务器就可以。</p><p>我最终的选择是 HP MicroServer Gen8，</p><ol><li>首先 HP 这款设备虽然有点老，但是性能还是勉强够用，在二手市场上价格非常便宜。新版本甚至不支持 iLO，算什么服务器？</li><li>其次就是 HP 对这款设备在其官网上就有 ESXi 的配套驱动，不需要担心兼容性的问题</li><li>再者由于存储了文件，需要有 RAID 支持来保障文件的可靠性，而这款设备有原生的 RAID 1 支持</li><li>然后就是自带了三个网口，去掉一个 iLO 管理口，剩下两个还能做上下行，满足我们对路由设备的需求</li><li>最后就是这款机器定位家庭服务器、小型公司服务器，所以是静音且不需要机柜的，这可太适合我们这个项目了</li></ol><p><img src="/static/hp-microserver.jpg" alt="HP MicroServer"></p><p>最终，我在 Yahoo 拍卖上以 35,000 日元（折合人民币 2200 元）的价格买到了一台 Xeon CPU E3-1220L V2 2.3GHz CPU，8GB 内存，没有硬盘的设备。然后单独购买了两块 4TB 的硬盘做 RAID 1。</p><p>在 BIOS 中配置好 RAID 选项，直接从 HP 官网上下载相应的 ESXi 镜像，通过 iLO 连接远程安装系统，这一过程非常轻松。另一个网口自然就是要来接交换机的，我在日本亚马逊上以 3,180 日元（折合人民币 200 元）买了一台 NETGEAR GS308-100JPS 的交换机，一共 8 个千兆口，基本够家里使用了。</p><p>操作系统选了 OpenWRT 18.06.1，直接 img 拉下来转成 vmdk 塞进 ESXi 里，就可以直接运行了。在 ESXi 中虚拟两个交换机 vSwtich0 接路由器虚拟机、外网网口、管理网；vSwitch1 接路由器、交换机网口以及之后的各种服务。</p><p>启动后把外网 IPv4 做成 DHCP，IPv6 做成接力模式。配置内网的 DNS 服务为 ESXi 和 OpenWRT 设置好便于访问的别名，第一阶段完工。</p><h2 id="外网服务"><a href="#外网服务" class="headerlink" title="外网服务"></a>外网服务</h2><p>接下来来说这个外网服务的问题，这个问题是导致这个项目的网络拓扑变得如此复杂的直接原因。尽管 Softbank 宣称只要打开 DMZ 和防火墙，就可以从公网 IP 访问到设备。经过我将近一个星期的调试，我只想讲一句 fnndp。</p><p>在网上找了半天，找到一篇 <a href="https://nashippe.blog/network/rtx/ipv6-hybrid/" target="_blank" rel="noopener">博客</a>，讲了它是通过开启路由的 PPPoE 穿透，在内网拨号，从而让家中上网走 IPoE + IPv6 的快速网络，而提供服务走的是 PPPoE 的较慢的网络。于是我也打算按照这个方法实施。</p><p>我在 ESXi 上安装了一个新的 Debian 虚拟机，也同时接入 vSwitch0 和 vSwitch1 两个虚拟交换机。在 vSwitch0 上进行 PPPoE 拨号，同时从 vSwitch1 上做 DHCP 客户端。然后通过手写 ip rules 的方法实现路由分流。从而让这台设备成为网关 (gateway) 设备，其它服务可以通过这台的端口代理完成部署。</p><p>接下来就是比较简单的，配置 StrongSwan 做了一个 IKEv2 的 VPN；安装 GitLab 做了一个私有的 Git 服务。为了方便更多的 Web 服务部署，我使用了 OpenResty，并在上面运行 <a href="https://github.com/GUI/lua-resty-auto-ssl" target="_blank" rel="noopener">lua-resty-auto-ssl</a> 的方式自动签发 HTTPS 证书。有关安全的 HTTPS 配置，可以使用 <a href="https://mozilla.github.io/server-side-tls/ssl-config-generator/" target="_blank" rel="noopener">Mozilla SSL Configuration Generator</a> 生成。</p><h2 id="内网服务"><a href="#内网服务" class="headerlink" title="内网服务"></a>内网服务</h2><p>一个单独拿出来讲的是 NAS。我的选型是 OpenMediaVault。这个系统开源，而且基于 Debian，非常稳定。之所以没有选 FreeNAS，因为我一共只有 8GB 内存，跑 ZFS 还是太吃力了一些。我在 ESXi 上单独虚拟了一个 OpenMediaVault，需要虚拟两块硬盘出来，一块系统盘，一块存储盘，这样管理起来比较容易。</p><p>WiFi 的部分是个坑，我一开始觉得这个 Softbank 富士康自带的 WiFi 质量还挺好的，5GHz 能跑上 300Mbps。但后来发现一个严重问题，就是会莫名其妙断流，这个在比如联机玩个马里奥赛车的时候会抓狂。</p><p><img src="/static/cisco-ap.jpg" alt="Cisco AP"></p><p>这时候某好友送了我一台 Cisco CAP-3502i。虽然这设备 5GHz 连 802.11ac 都不支持，只支持 n。但是却非常稳定。可惜这玩意使用 PoE 供电，如果换成 PoE 的交换机的话，实在是太浪费钱了。于是我就趁着回国间隙从京东买了一个 TP-LINK TL-POE150S PoE 供电模块（99 元）。TP-LINK 这设备又便宜又稳定，<strong>但是</strong>  赠品的 RJ45 网线还不如不送，送的竟然是 CAT-5 规格的线。我到现在都没搞清，在藤泽，扔网线属于哪一类垃圾，怎么才能扔出去。</p><h2 id="杂项"><a href="#杂项" class="headerlink" title="杂项"></a>杂项</h2><p>除了上面说到这些，还做了一些小的东西。首先有一个台风天的晚上，我的房间断电了 1 秒不到，我感受到是因为我的服务器重启了。为了应对这种情况，我花了 5,980 日元（折合人民币 366 元）买了一台 255W 的 <a href="https://www.amazon.co.jp/gp/product/B01MY53XVO/ref=oh_aui_detailpage_o05_s00?ie=UTF8&amp;psc=1" target="_blank" rel="noopener">家用 UPS</a> 以应对突发情况。（长时间的断电我也不防了，毕竟是家用。）</p><p><img src="/static/switch-desktop.jpg" alt="Switch Desktop"></p><p>另外我给我的桌面上单独配了 Type-C 到以太网的网口，和电源一起接在适配器上，随时把 Macbook Pro 插上去就可以比较好地工作。另外给 Nintendo Switch 也单独配了网线和 USB 网口。<strong>千万</strong> 不要买任天堂官方的 USB 网口，那玩意甚至是 USB 2.0 的。随便在 Amazon 上都可以买到，比官方的又便宜，速度又快的网口转接器。</p><p>最后就是为了访问方便，还是搞一个 DDNS 服务来为家里配一个固定的域名。虽然这 Namecheap 的官方 Guidelines 里讲的花里胡哨的，结果连个 Debian 的例子都没有。我用的是 ddclient 客户端，反正配置还挺简单的。</p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><ol><li>别签 Softbank</li><li>我不确定这套玩意跑两年加上电费和云主机哪个便宜</li><li>要是来个地震直接把硬盘砸穿了啥 RAID 都没用</li><li>手写过 iptables 和 ip rules，才知道里面有多少坑</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;引&quot;&gt;&lt;a href=&quot;#引&quot; class=&quot;headerlink&quot; title=&quot;引&quot;&gt;&lt;/a&gt;引&lt;/h2&gt;&lt;p&gt;我今年 9 月搬家到了藤泽，签了一个非常恶心人的 Softbank 的网络合约之后，花了大半个月才搞清楚这个网络的状况。于是就基于自己的需求，在家中
      
    
    </summary>
    
    
      <category term="生活" scheme="https://coderemixer.com/tags/%E7%94%9F%E6%B4%BB/"/>
    
      <category term="网络" scheme="https://coderemixer.com/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>使用字体，怎样不惹官司</title>
    <link href="https://coderemixer.com/2018/11/24/how-to-use-fonts/"/>
    <id>https://coderemixer.com/2018/11/24/how-to-use-fonts/</id>
    <published>2018-11-24T01:48:02.000Z</published>
    <updated>2018-11-25T02:35:01.752Z</updated>
    
    <content type="html"><![CDATA[<h2 id="引"><a href="#引" class="headerlink" title="引"></a>引</h2><p>近来，知名 up 主敖厂长因为在视频中使用了「造字工房」家的某些字体，使得惹上了官司，被求偿十多万的赔偿费用。在字体行业内，其实这样的事情屡见不鲜。从 2011 年方正诉保洁的「飘柔」商标字体案，到 2015 年造字工房诉湖南卫视《歌手3》节目字体侵权案，字体公司的名字似乎和侵权官司脱不开关系。那么今天我们就来聊一聊中文字体行业的发展现状，以及作为一个用户，怎样使用字体，不容易惹上官司。</p><h2 id="字体行业现状"><a href="#字体行业现状" class="headerlink" title="字体行业现状"></a>字体行业现状</h2><p>字体行业的生存相当困难，目前国内其实混得比较好的字体公司只有那么几家。大家熟悉的简体字的字型逃不开北大方正、常州华文，还有台湾的威锋数位（也就是之前的华康字体）、文鼎字体和蒙纳字体这几家公司的设计。这些品牌几乎都是伴随中国计算机发展从无到有的几十年过程中的重要见证。而这次的主角造字工房，虽然也是一家成立了十年的老公司了，但比起这些公司，还算是比较年轻的。</p><p>首先设计中文字体的过程，不得不说是比较艰辛的。一个完整的西文字体通常需要拉丁字母、希腊字母、西里尔字母以及常见的符号，这样就已经有近千个字型需要设计了。而中文字形则更多，根据中国 GB2312-80 中华人民共和国国家标准简体中文字符集规范，包括 6763 个汉字（其中一级汉字 3755 个，二级汉字 3008 个）。而即使这样，也只能覆盖中国大陆 99.75% 的使用频率。一旦使用到一些偏僻字，我们还有 GB18030 国家标准来涵盖偏僻字，其收录汉字 70,244 个。像是政府公文喜欢用的仿宋、楷体，都有对应的 GB18030 标准实现，来保证尽可能地不会缺字。这还不算上各种 hinting、ligature 之类细节调教所需要的工时，甚至还要面向不同操作系统使用的不同渲染方式进行微调。</p><p>而在这种情况下，付出了大量的设计师成本后，字体公司的盈利模式又是如何的呢？</p><p>我们可以大致把常见的字体公司盈利模式，分成下述几类：</p><ul><li>研发授权</li><li>字体定制</li><li>字体销售</li><li>诉讼收入</li></ul><p>像是微软雅黑就是微软委托给方正和蒙纳设计的；而 Adobe 和 Google 合作研发的思源黑体的中文部分，是委托给常州华文设计的；而像苹果新的 iOS 和 macOS 中内置的苹方字体则是委托威锋数位设计的。这是字体公司盈利的很大来源，这些国际大厂有着广泛的字体设计的评价标准，属于比较懂事的甲方。以微软雅黑为例，据坊间传闻，微软雅黑的平均每个汉字的价格是 100 美元，也就是说一个 2 万个汉字的字体，微软付出了 200 万美元的合作价格，以获取微软雅黑能在 Windows 操作系统下使用的授权。</p><p>除了整个字库整个字库的研发，另一种更便宜的作法就是字体定制。比如根据你的品牌形象，专门定制一个 Logo 用的字体，让别人能从字体一眼认出你的品牌也是一个常见的盈利模式。而对于普通用户，正规的字体获取渠道，也就是字体销售，实际情况是比较惨淡的。中国早年的软件销售就饱受盗版问题的影响，自己辛辛苦苦设计出来的字体人人都在用，自己却一分钱都没有收到，放到是谁好像也不能接受。于是，很快我们就发展出了一个全新的被各大字体公司广泛使用的盈利模式：</p><p><strong>诉讼！</strong></p><p>简单说，就是字体公司会请一个庞大的法务部门，天天上网找那些非法使用字体的公司，然后一个个起诉他们。起诉小公司，通常付出的成本和回报不符，所以也会专挑知名的公司或个人下手。虽然通常不会走到对簿公堂的最后一步，大多问题都能通过协商和庭外和解解决。但这种先上车，后补票的方式，一方面让人感觉很奇怪，而另一方面则让没钱维护法务关系的小字体公司很难生存。这也不难解释为什么说到字体公司，脑海中浮现的就只有这么几家了。</p><h2 id="什么是商业使用"><a href="#什么是商业使用" class="headerlink" title="什么是商业使用"></a>什么是商业使用</h2><p>这次敖厂长的事件一个争议点就是「商业使用」，因为造字工房有说对于个人非商业使用，可以不收费。「我是个人做视频，怎么就算商业使用了呢？」这是很多人的第一个想法。虽然不同公司的具体授权协议有所不同，像方正就会比较严格一些。但实际情况是，商业使用的界限在于字体公司本身怎么设计的授权协议，使用者是没有讨价还价的余地的。你只有在使用前向字体公司确认自己的使用是不是合法，是不是可以免费使用。等到对方来起诉你的时候，这一点几乎是毋庸置疑的了。</p><p>通常对商业使用的界定就是以 <strong>获得经济收益</strong> 为界限的。个人制作的视频虽然是免费的，但平台方的广告收入、观众的捐款、赞助，都可以被划到商业使用的界限中。所以不止是海报、电视节目等传统用途，各位 up 主在使用字体时也必须要格外的小心。</p><h2 id="怎么做？"><a href="#怎么做？" class="headerlink" title="怎么做？"></a>怎么做？</h2><p>世间大多数问题的可以用「喜欢就买 不行就分 多喝热水 重启试试」这四个真理解决。而字体就属于「喜欢就买」这个范畴的。如果你想用一个字体，而又有钱，那就买啊。大多数的字体商业使用的一年授权费也就在几干元人民币左右，你发一个月设计师薪水都不够，为什么非要省下这个钱呢？顺便一提，使用字体的被授权方应该是字体的实际使用者。比如对于一个设计师接了一个案子，那应该是你的甲方去买字体，你买字体通常并不能解决问题。</p><p>那对于一些新人创作者，还没有多少收入，又想要规避掉潜在的法律风险，万一以后红了被告了多麻烦。这时候又有什么选择呢？我在此给一些推荐。</p><p>我们可以把字体大致分为几种授权情况：开源协议、非商用授权、商用授权和无法授权。我会根据使用情况来对这几种授权方式进行说明。</p><p>我们先讲最奇葩的情形：无法授权。这一类的典型代表就是「康熙字典体」。由于这款字体被卖断，已经不再提供任何销售了，请务必不要使用这一字体。推荐的替代品有「喜鹊古字典体」（个人可商用 99 元）和「方正清刻本悦宋」（个人不可商用 2 元、商用授权 7000 元）。</p><p>开源协议的字体主要有两种类型，一种是 OFL (SIL) 协议，典型的代表有思源黑体、思源宋体。其要求是你不能卖这个字体本身，但搭配这个字体使用的商业活动可以销售。这是对于商业活动最宽松的字体，而且是免费的。在此强烈推荐最近刚更新的思源黑体 2.0，不但字型很全，对于大量生僻字支持很好，甚至支持了超出 GB18030 的生僻字，还针对简体、台湾繁体、香港繁体、韩国汉字、日文汉字的不同写法单独做了优化。</p><p>但不是所有开源协议都是安全的，像著名的在 Linux 系统下常见到的文泉驿开源字体。文泉驿微米黑的授权为 Apache 2.0 和 GPL v3 双授权，而文泉驿点阵宋体、正黑和 unibit 则是 GPL 单授权。对于 Apache 2.0 授权的字体可以在附上原始字体的协议、商标、专利声明自由商用，而对于 GPL 授权的字体，虽然可以商用，但使用的产品，必须也按照 GPL 协议开源发布，这一点则非常复杂了。</p><p>非商用授权的字体主要有造字工房的个人字体和方正的个人授权。造字工房的字体当你个人非商用时是免费的，而方正 2 元一个的个人授权，也是不得用于商业用途的。这两家的商业用途字体需要单独购买，这点要特别注意。</p><p>商用授权的部分同样也有不少选项。一个是对于个人用户，喜鹊造字家的字体都是可以以 99 元的价格进行商用的。方正字体中方正黑体、方正书宋（注意不是新书宋）、方正仿宋、方正楷体这四款字体，针对「商业发布」这种使用方式免费。还有一个很特别的情况，一位网友曾给苹果发邮件询问 Mac 自带的字体可否商用，得到了肯定的回答。「Mac 内置字体，直接在苹果电脑上操作并输出为商用是没有问题的。」那么 Windows 呢？答案是，我不知道。由于微软和几家厂商的授权非常复杂，使用前请务必询问各个厂商得到具体答复。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>说到底还是几个问题。</p><ol><li>守法</li><li>搞不清授权情况要联系版权方</li><li>有能力请多支持正版字体</li></ol><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="https://www.foundertype.com/index.php/About/userAuth.html" target="_blank" rel="noopener">方正字库 商业授权</a></li><li><a href="https://github.com/adobe-fonts/source-han-sans/blob/master/LICENSE.txt" target="_blank" rel="noopener">思源黑体 License</a></li><li><a href="http://wenq.org/wqy2/index.cgi?Download" target="_blank" rel="noopener">文泉驿授权</a></li><li><a href="https://h.bilibili.com/9615827" target="_blank" rel="noopener">敖厂长事件相关帖文</a></li><li><a href="https://www.facebook.com/groups/enjoyfonts/permalink/841583915996485/" target="_blank" rel="noopener">关于 Mac 内置字体商用的讨论</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;引&quot;&gt;&lt;a href=&quot;#引&quot; class=&quot;headerlink&quot; title=&quot;引&quot;&gt;&lt;/a&gt;引&lt;/h2&gt;&lt;p&gt;近来，知名 up 主敖厂长因为在视频中使用了「造字工房」家的某些字体，使得惹上了官司，被求偿十多万的赔偿费用。在字体行业内，其实这样的事情屡见不鲜。
      
    
    </summary>
    
    
      <category term="字体" scheme="https://coderemixer.com/tags/%E5%AD%97%E4%BD%93/"/>
    
      <category term="法律" scheme="https://coderemixer.com/tags/%E6%B3%95%E5%BE%8B/"/>
    
  </entry>
  
  <entry>
    <title>从前几天收到的竞选广告说起</title>
    <link href="https://coderemixer.com/2018/10/22/waki-reiko/"/>
    <id>https://coderemixer.com/2018/10/22/waki-reiko/</id>
    <published>2018-10-22T09:19:36.000Z</published>
    <updated>2018-10-22T12:18:31.405Z</updated>
    
    <content type="html"><![CDATA[<h2 id="引"><a href="#引" class="headerlink" title="引"></a>引</h2><p>10 月 18 日那天信箱里收到了日本左翼政党立宪民主党藤泽女性市议员参选人脇 れい子的竞选广告。立宪民主党是之前民进党拆伙后独立的政党，右翼部分和希望党合并成立了国民党。看了下这位市议员的竞选广告，Slogan 是「人が生きる町」，竞选主轴围绕藤泽市大量的老年人口的照顾问题，然而这议题占了整个广告页的 1/12 不到。</p><p>花了 1/4 篇幅讲了要推动「候补者均等法案」的实行，查了一下这个法案的具体内容。是在地方和国会选举中要求男女候补者人数均等的法案。此议案在今年 5 月参院全票通过。1/4 的篇幅是和各个其它政客的合照，意义不明。然后 1/4 篇幅列举了自己的求学、工作简历。1/4 要求进行「性暴力被害者支援法」立法。还有一些细碎的其它政见。</p><p>我看完后的感受是——一头雾水。首先，「性暴力被害者支援法」立法工作是立宪民主党的政见，而市议员又不是两院的议员，选不选上都无关。候补者均等法案感觉也很怪，不去讨论解决女性参政者少的背后原因，去立法平衡人数这不是变相的性别歧视吗？也不知道这法案怎么就如此朝野一致地通过了。内容多而杂，很多和竞选内容无直接关系，看完了完全没有对这个议员留下什么好印象。</p><p>如果不是特意细读了一下，恐怕大多数人看完这广告连候选人名字都记不住吧。感觉很失败。</p><h2 id="政治人物的自我修养"><a href="#政治人物的自我修养" class="headerlink" title="政治人物的自我修养"></a>政治人物的自我修养</h2><p>作为一个政治人物，一个最核心的思考方式就是「选民要什么？」和「自己能干什么？」。如果连基本的自我定位都做不好，要么无法获得选民的认可，要么心有余而力不足，不能为选民做好服务。</p><p>在这则广告里，候选人同时犯了这两个错误。</p><p>第一个错误就是弄不清选民要什么。先不说「候补者均等法案」能不能真正推动性别平权，「推动『候补者均等法案』」的这个动作的本身，直接受益者是不是女性呢？答案其实很明显，就算是，也不会是女性的主体。日本地方议员定数是每 100 万人口 500 人，也就是万分之五的比例。如果女性议员不得小于 40%，那就是有万分之二的人口得到了直接受益。间接的受益者则很难计算，即使是女性议员在议会中，也并不代表会为女性直接发声，更何况其仍处于相对的少数。藤泽市人口根据 2015 年联合国数据，是 42.39 万，这样的竞选目标，能不能催出 1000 张选票都成问题，以至于这样的宣传成本和受益是极大不匹配的。</p><p>第二个错误就是对「性暴力被害者支援法」立法工作的推动。「性暴力被害者支援法」自然是个有必要立法的法案。但市议员并不能参与国会的立法，最多只能参与地区的立法，而立法的范围也非常有限。「性暴力被害者支援法」是候选人所在立宪民主党的政见，而市议员又不是两院的议员，选不选上都无关。这样的议题，如果真的被选上了，这位市议员又如何推动立法的执行呢？最后不只能变成一句大话空话吗？会不让人民失望吗？</p><h2 id="利益、政党、财团"><a href="#利益、政党、财团" class="headerlink" title="利益、政党、财团"></a>利益、政党、财团</h2><p>然而问题是，只要一个候选人不是西瓜，受过基本的政治学教育，那么都应该理解上面的道理。但事实上，为什么无论在哪里的选举，这样的事情却屡见不鲜呢？</p><p>这不免和我们现行的民主制度是直接相关的。为使选举资源利用效率最大化，集团化党派化是最便利的形式；而财团和党派长期的良好关系又是运作党派最便利的形式。虽然是民众一票一票投出来来的政治人物，但一个人物，在成为政治人物之前，就已经接受了财团、政党巨大的恩惠了，是为选民直接负责，还是也要为财团、政党服务就成了问题。这在大多数时候不会显得太过矛盾，但一旦财团与人民的利益起冲突时，事情就会起微妙的变化。</p><p>2017 年的台湾政坛的一个重要事件就是<a href="https://zh.wikipedia.org/wiki/2017%E5%B9%B4%E5%8F%B0%E7%81%A3%E5%8B%9E%E5%8B%95%E5%9F%BA%E6%BA%96%E6%B3%95%E4%BF%AE%E6%AD%A3%E7%88%AD%E8%AD%B0" target="_blank" rel="noopener">「台湾劳动基准法修正争议」事件</a>。在这个事件中，我们看到了无数换位置换脑袋的现象。蔡英文选前之夜说「人民的声音，不管怎么大声，到了凯道就停住了」，而 2017 年，蔡英文就把劳基法的抗议民众赶出了凯道。选前和民进党关系极为密切的劳工朋友，竟然他们的声音在凯道前就被停住。那么问题来了，如果是国民党执政，他们就不会伤害劳工朋友吗？</p><p>答案当然是否定的。如果今天是 Hillary 当美国总统，她会为沙特被杀害的记者发声吗？我想也是不会的。要想在选举中浮上台面，需要大量的资源，这些资源可以以钱的形式，也可以不是。而拿了资源自然要为提供资源的人负责。选民能决定的东西，从一开始就是有限的。</p><p>某种意义上这就像纳什均衡一样，用人民的手投出并不最大化人民利益的结果。不只是美国，也不限于总统制，这确实是个很难例外的事，因为也很难想到更好的方式。</p><h2 id="民主政治的科技革命"><a href="#民主政治的科技革命" class="headerlink" title="民主政治的科技革命"></a>民主政治的科技革命</h2><p>选举需要资源，最大的目的是要能让选民接触到被选举人。以美国选举为例，2016 年美国人口 3.234 亿人，2016 年大选投出了 1.37 亿张选票。我们先不考虑美国特殊的选举人团制度，如果是简单多数决，只有两个主要候选人的情况下，至少也要 45% 的得票率，那就是 6100 万张选票。这 6100 万张选票的背后是 6100 万分布在美国各州各县各市，如何把自己的声音传给这 6100 万人就是一个极难解决的问题。所以候选人要控制媒体，从以前的控制报纸，到后来的控制电视，再到现在控制网络，都是一样的理由。控制媒体需要极高的成本，这时候政党和支持政党的财团就变得极为便利。这个世界上不存在一个绝对中立的个人，也不存在一个绝对中立的媒体。今天 Trump 觉得 New York Times 是 Fake News，我很大程度上同意，NYT 的专栏动不动就打自己的脸，要说其很很中立、仔细考证我是不信的。但 Fox News 就不是了吗？每个媒体都在制造 Fake News，但谁当局，谁就可以指定什么是 Fake News。每个人的精力是有限的，能接触到的信息亦是有限的。所谓的「同温层效应」就是人们往往会选择与自己观念相近的信息，而排斥立场相反的信息。</p><p>在这种情况下，有两个政治事件是我感到很惊讶的。一个是 <a href="https://zh.wikipedia.org/wiki/%E5%A4%AA%E9%99%BD%E8%8A%B1%E5%AD%B8%E9%81%8B" target="_blank" rel="noopener">2014 年台湾 318 学运</a> 中 <a href="https://zh.wikipedia.org/wiki/G0v%E9%9B%B6%E6%99%82%E6%94%BF%E5%BA%9C" target="_blank" rel="noopener">g0v 零时政府</a> 扮演的角色。g0v 通过网络，以更低的成本开放政府资料让政府透明，人民更容易做主。虽然我依然相信，和控制报纸和电视一样，拥有更多资源的选举人，只要对网络认识充分，方法妥当，依然有着更大可能性控制网络的舆论。但大多数旧时的选举人仍是迂腐的，所谓「肉食者鄙，未能远谋」。能不能利用网络的优势，以更低的成本来产生更能为人民服务好的政客，来摆脱人民被财团支配的命运？这个问题在我心中还是一个问号，且持悲观态度的。</p><p>但黑暗中的点点星光，还是能让人感受到丁点的希望的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;引&quot;&gt;&lt;a href=&quot;#引&quot; class=&quot;headerlink&quot; title=&quot;引&quot;&gt;&lt;/a&gt;引&lt;/h2&gt;&lt;p&gt;10 月 18 日那天信箱里收到了日本左翼政党立宪民主党藤泽女性市议员参选人脇 れい子的竞选广告。立宪民主党是之前民进党拆伙后独立的政党，右翼部分和
      
    
    </summary>
    
    
      <category term="政治观察" scheme="https://coderemixer.com/tags/%E6%94%BF%E6%B2%BB%E8%A7%82%E5%AF%9F/"/>
    
      <category term="日本" scheme="https://coderemixer.com/tags/%E6%97%A5%E6%9C%AC/"/>
    
  </entry>
  
  <entry>
    <title>Ruby 原生扩展开发指北</title>
    <link href="https://coderemixer.com/2018/10/21/ruby-native-ext-compass/"/>
    <id>https://coderemixer.com/2018/10/21/ruby-native-ext-compass/</id>
    <published>2018-10-21T13:44:43.000Z</published>
    <updated>2018-10-22T12:18:06.367Z</updated>
    
    <content type="html"><![CDATA[<h2 id="选题"><a href="#选题" class="headerlink" title="选题"></a>选题</h2><p>这个题目是我在 <a href="https://rubysummit.cn/" target="_blank" rel="noopener">RubySummit China</a> 2018 上的演讲题目。当时时间也比较紧，没有讲得特别深入；听众感觉大多数都还没有做过相关的开发，当场反馈也不是很好。回来后读了几篇新媒体稿件，把我读傻了。一路下来的感觉就是：</p><blockquote><p>我不是，我没有，我没讲过，我不是这个意思。</p></blockquote><p>既然如此，我也借此机会重新整理了一下。希望给听到或没有听到的各位重新梳理一下我对 Ruby 原生扩展开发的看法和建议。</p><h2 id="引"><a href="#引" class="headerlink" title="引"></a>引</h2><p>我从郑州东站出来后，打车去的会场。专车司机打电话给我用河南话一个劲地说：「在停车场 <strong>西南角</strong> <strong>西南角</strong>！」虽然河南话属于中原官话，听起来没困难，但关键是我根本分不清哪里是西南角，找了整整十五分钟才找到车。</p><p>写 Ruby 的原生扩展也是如此。</p><p>当你灵光乍现，感觉是不是应该写一个 Ruby 原生扩展的时候，脑海中可能会浮现如下的想法：</p><ul><li>写原生扩展能解决我的问题吗？</li><li>怎么写原生扩展？</li><li>我该选型哪一种原生扩展的开发方式？</li></ul><p>而我希望通过接下来的内容，在大家想到原生扩展时能打消掉上述的顾虑，清晰的知道自己要什么？怎么做。</p><h2 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h2><p>说到用开发 Ruby 的原生扩展，第一个反应就是提升性能。我们能提升多少性能？</p><p>（待续）</p><!-- 如果我们是单纯来提高性能的，我们为什么不直接写那些语言本身呢？比如我们刚刚提到的堆排序问题。谁会在生产中使用 Ruby 单独解决一个堆排序问题呢？## 插曲 -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;选题&quot;&gt;&lt;a href=&quot;#选题&quot; class=&quot;headerlink&quot; title=&quot;选题&quot;&gt;&lt;/a&gt;选题&lt;/h2&gt;&lt;p&gt;这个题目是我在 &lt;a href=&quot;https://rubysummit.cn/&quot; target=&quot;_blank&quot; rel=&quot;noopener
      
    
    </summary>
    
    
      <category term="编程" scheme="https://coderemixer.com/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="Ruby" scheme="https://coderemixer.com/tags/Ruby/"/>
    
  </entry>
  
  <entry>
    <title>在 Ruby 中实现一个 WebSocket 掩码</title>
    <link href="https://coderemixer.com/2018/07/10/ruby-websocket-in-c-lang/"/>
    <id>https://coderemixer.com/2018/07/10/ruby-websocket-in-c-lang/</id>
    <published>2018-07-10T12:47:45.000Z</published>
    <updated>2018-10-21T12:48:11.152Z</updated>
    
    <content type="html"><![CDATA[<h2 id="引"><a href="#引" class="headerlink" title="引"></a>引</h2><p>在 WebSocket 协议中有一个重要的实现就是 masking（掩码），根据 RFC 6455 <a href="https://tools.ietf.org/html/rfc6455#section-10.3" target="_blank" rel="noopener">10.3 章节</a> 的讨论，客户端连接服务器必须要打开掩码功能，当服务器收到一个客户端帧没有打开掩码时，应到立刻终止这一连接。关于为什么必须有一方开启 mask，可以参见 <a href="https://security.stackexchange.com/questions/36930/how-does-websocket-frame-masking-protect-against-cache-poisoning" target="_blank" rel="noopener">这个回答</a>。</p><p>一个 WebSocket 帧长成下面这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"> 0                   1                   2                   3</span><br><span class="line"> 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1</span><br><span class="line">+-+-+-+-+-------+-+-------------+-------------------------------+</span><br><span class="line">|F|R|R|R| opcode|M| Payload len |    Extended payload length    |</span><br><span class="line">|I|S|S|S|  (4)  |A|     (7)     |             (16/64)           |</span><br><span class="line">|N|V|V|V|       |S|             |   (if payload len==126/127)   |</span><br><span class="line">| |1|2|3|       |K|             |                               |</span><br><span class="line">+-+-+-+-+-------+-+-------------+ - - - - - - - - - - - - - - - +</span><br><span class="line">|     Extended payload length continued, if payload len == 127  |</span><br><span class="line">+ - - - - - - - - - - - - - - - +-------------------------------+</span><br><span class="line">|                               |Masking-key, if MASK set to 1  |</span><br><span class="line">+-------------------------------+-------------------------------+</span><br><span class="line">| Masking-key (continued)       |          Payload Data         |</span><br><span class="line">+-------------------------------- - - - - - - - - - - - - - - - +</span><br><span class="line">:                     Payload Data continued ...                :</span><br><span class="line">+ - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - +</span><br><span class="line">|                     Payload Data continued ...                |</span><br><span class="line">+---------------------------------------------------------------+</span><br></pre></td></tr></table></figure><p>举例来说：</p><p>当客户端向服务器发送一个 “Hello” 字符串的时候，二进制流长成下面这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0x81 0x85 0x37 0xfa 0x21 0x3d 0x7f 0x9f 0x4d 0x51 0x58</span><br></pre></td></tr></table></figure><p>其中：</p><ul><li>第一个 Byte 0x81，也就是 0b10000001，指的是 FIN=1，代表这帧传输了完整的数据，没有分片。Opcode 是 0x1，传输的是一个字符串。</li><li>第二个 Byte 0x85，也就是 0b10000101，指使用 Mask，Payload 的长度是 5。</li><li>第三到第六个 Byte 是 Mask 掩码 Key。</li><li>第七到十一个 Byte 原先是 0x48(H) 0x65(e) 0x6c(l) 0x6c(l) 0x6f(o)，但现在要被掩码盖住，掩码的计算方式就是循环进行异或运算。解码时只需要对着 Mask Key 再做一次异或就会回去，因为 a ^ b ^ b = a。<ul><li>0x48 ^ 0x37 = 0x7f</li><li>0x65 ^ 0xfa = 0x9f</li><li>0x6c ^ 0x21 = 0x4d</li><li>0x6c ^ 0x3d = 0x51</li><li>0x6f ^ 0x37 = 0x58</li></ul></li></ul><p>这个过程在 Ruby 中应该怎么实现呢？</p><h2 id="尝试"><a href="#尝试" class="headerlink" title="尝试"></a>尝试</h2><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">stream = StringIO.new([<span class="number">0x81</span>, <span class="number">0x85</span>, <span class="number">0x37</span>, <span class="number">0xfa</span>, <span class="number">0x21</span>, <span class="number">0x3d</span>, <span class="number">0x7f</span>, <span class="number">0x9f</span>, <span class="number">0x4d</span>, <span class="number">0x51</span>, <span class="number">0x58</span>].pack(<span class="string">'C*'</span>)) <span class="comment"># 模拟网络传进来的 byte 流</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mask</span><span class="params">(data)</span></span></span><br><span class="line">  first_byte = data.getbyte</span><br><span class="line">  opcode = first_byte &amp; 0b0001111 <span class="comment"># 先不考虑 fin</span></span><br><span class="line"></span><br><span class="line">  second_byte = data.getbyte</span><br><span class="line">  raise <span class="string">'NotMaskedError'</span> <span class="keyword">unless</span> (second_byte &amp; 0b1000000<span class="number">0</span>) == <span class="number">128</span></span><br><span class="line"></span><br><span class="line">  payload = second_byte &amp; 0b01111111</span><br><span class="line">  mask = Array.new(<span class="number">4</span>) &#123; data.getbyte &#125;</span><br><span class="line">  masked_msg = Array.new(payload) &#123; data.getbyte &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment"># Start Decoding</span></span><br><span class="line">  masked_msg = masked_msg.map.with_index <span class="keyword">do</span> <span class="params">|byte, i|</span></span><br><span class="line">    byte ^ mask[i % <span class="number">4</span>]</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> masked_msg.pack(<span class="string">'C*'</span>) <span class="keyword">if</span> [<span class="number">0x1</span>, <span class="number">0x9</span>, <span class="number">0xA</span>].<span class="keyword">include</span>? opcode <span class="comment"># String message</span></span><br><span class="line">  <span class="keyword">return</span> masked_msg</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">puts mask(stream) <span class="comment"># =&gt; Hello</span></span><br></pre></td></tr></table></figure><p>Bravo! 我们正确实现了解码过程，这段代码的性能如何呢？</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">require</span> <span class="string">'benchmark'</span></span><br><span class="line"></span><br><span class="line">N = <span class="number">1_000_000</span></span><br><span class="line">Benchmark.bm <span class="keyword">do</span> <span class="params">|x|</span></span><br><span class="line">  x.report &#123; N.times <span class="keyword">do</span> mask(StringIO.new([<span class="number">0x81</span>, <span class="number">0x85</span>, <span class="number">0x37</span>, <span class="number">0xfa</span>, <span class="number">0x21</span>, <span class="number">0x3d</span>, <span class="number">0x7f</span>, <span class="number">0x9f</span>, <span class="number">0x4d</span>, <span class="number">0x51</span>, <span class="number">0x58</span>].pack(<span class="string">'C*'</span>))) <span class="keyword">end</span> &#125;</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">    user     system      total        real</span><br><span class="line">5.083038   0.025399   5.108437 (  5.154494)</span><br></pre></td></tr></table></figure><p>emmm… 处理 1000 万个 byte 就这种性能… 恐怕用 WebSocket 做实时通讯不太行啊。</p><p>不过 <a href="http://en.wikipedia.org/wiki/Donald_Knuth" target="_blank" rel="noopener">Donald Knuth</a> 说过：「我们应该忘记细小的性能提升，在 97% 的情况下，过早的优化都是万恶之源。」</p><p><strong>好了，收工回家了。</strong></p><p>（完）</p><h2 id="才怪"><a href="#才怪" class="headerlink" title="才怪"></a>才怪</h2><p>高德纳还说过：「我们千万不能放弃剩下的 3%」而解码过程是每个请求都必须跑的，对于一个 I/O-bound 的 Web 应用，如果因为一个 decode 变成 CPU-bound 那可是个非常严重的问题，能优化一点都有很大的帮助。</p><p>于是，要想给一段代码找到性能问题，第一个想到的工具当然就是：</p><p><strong>profiler</strong> !!!</p><p>要在 Ruby 上使用 profiler 很简单，只需要引入 profile 库即可。不过 profiler 会让程序运行得很慢，要注意节制在潜在的性能问题上去单独跑。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ruby -rprofile test.rb</span><br></pre></td></tr></table></figure><p>报告如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">  %   cumulative   self              self     total</span><br><span class="line"> time   seconds   seconds    calls  ms/call  ms/call  name</span><br><span class="line"> 49.28     2.94      2.94   150000     0.02     0.05  Object#mask</span><br><span class="line"> 11.59     3.63      0.69    20000     0.03     0.09  Array#initialize</span><br><span class="line">  7.05     4.05      0.42    20000     0.02     0.10  Array#map</span><br><span class="line">  5.65     4.39      0.34   110000     0.00     0.00  StringIO#getbyte</span><br><span class="line">  4.16     4.64      0.25    10002     0.02     1.78  nil#</span><br><span class="line">  3.37     4.84      0.20    20002     0.01     0.10  Class#new</span><br><span class="line">  2.62     5.00      0.16    50000     0.00     0.00  Array#[]</span><br><span class="line">  2.60     5.15      0.16    50000     0.00     0.00  Integer#^</span><br><span class="line">  2.53     5.30      0.15    50000     0.00     0.00  Integer#%</span><br><span class="line">  1.77     5.41      0.11    10001     0.01     0.01  StringIO#initialize</span><br><span class="line">  1.75     5.51      0.10    10000     0.01     0.21  Enumerator#with_index</span><br><span class="line">  1.73     5.62      0.10    10001     0.01     0.02  StringIO.new</span><br><span class="line">  1.57     5.71      0.09    30000     0.00     0.00  Integer#&amp;</span><br><span class="line">  1.41     5.79      0.08    20001     0.00     0.00  Array#pack</span><br><span class="line">  1.26     5.87      0.08        1    75.09  5962.83  Integer#times</span><br><span class="line">  0.53     5.90      0.03    10000     0.00     0.00  Array#include?</span><br><span class="line">  0.52     5.93      0.03    10000     0.00     0.00  Integer#==</span><br><span class="line">  0.52     5.96      0.03    10001     0.00     0.00  BasicObject#initialize</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>这个 profiler 结果是我们最不愿意看到的，因为各个方法都平均地散落在哪里，并没有哪个方法特别占用时间。面对这种情况我们该怎么做呢？</p><h2 id="AOT？"><a href="#AOT？" class="headerlink" title="AOT？"></a>AOT？</h2><p>由于我们的操作几乎都是位操作，而以对象为单位来操作大大增加了各种开销。也许等之后 2.6.0 Ruby 有 JIT 的话，也许会随着跑的时间变长而优化，不过。。。我们可以 AOT 编译这些代码啊。</p><p>什么？你问 Ruby 什么时候支持 AOT 了？</p><p>Ruby 不支持，你自己判断这段代码是瓶颈，自己把这段代码写成 C 语言编译到二进制不就是 AOT 了？</p><p>在这篇 <a href="https://blog.jcoglan.com/2012/07/29/your-first-ruby-native-extension-c/" target="_blank" rel="noopener">博客</a> 中作者介绍了他是如何通过实现 C 扩展来提升 Faye WebSocket 的性能的。按这个思路，我之前对 <a href="https://github.com/midori-rb/midori.rb" target="_blank" rel="noopener">Midori</a> 库中 WebSocket 的 Mask 是类似实现的：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ruby.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">VALUE WebSocket = Qnil;</span><br><span class="line">VALUE MidoriWebSocket = Qnil;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Init_midori_ext</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">VALUE <span class="title">method_midori_websocket_mask</span><span class="params">(VALUE self, VALUE payload, VALUE mask)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Init_midori_ext</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  Midori = rb_define_module(<span class="string">"Midori"</span>);</span><br><span class="line">  MidoriWebSocket = rb_define_class_under(Midori, <span class="string">"WebSocket"</span>, rb_cObject);</span><br><span class="line">  rb_define_protected_method(MidoriWebSocket, <span class="string">"mask"</span>, method_midori_websocket_mask, <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">VALUE <span class="title">method_midori_websocket_mask</span><span class="params">(VALUE self, VALUE payload, VALUE mask)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">long</span> n = RARRAY_LEN(payload), i, p, m;</span><br><span class="line">  VALUE unmasked = rb_ary_new2(n);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> mask_array[] = &#123;</span><br><span class="line">      NUM2INT(rb_ary_entry(mask, <span class="number">0</span>)),</span><br><span class="line">      NUM2INT(rb_ary_entry(mask, <span class="number">1</span>)),</span><br><span class="line">      NUM2INT(rb_ary_entry(mask, <span class="number">2</span>)),</span><br><span class="line">      NUM2INT(rb_ary_entry(mask, <span class="number">3</span>))&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    p = NUM2INT(rb_ary_entry(payload, i));</span><br><span class="line">    m = mask_array[i % <span class="number">4</span>];</span><br><span class="line">    rb_ary_store(unmasked, i, INT2NUM(p ^ m));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> unmasked;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从理论上讲，这很好的减少了各种内存的分配，应该快很多，那么到底快了多少呢？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">    user     system      total        real</span><br><span class="line">5.293516   0.044790   5.338306 (  5.442116)</span><br><span class="line">4.627439   0.023852   4.651291 (  4.699278)</span><br></pre></td></tr></table></figure><p>1.16x 的速度。</p><h2 id="能不能快一点？"><a href="#能不能快一点？" class="headerlink" title="能不能快一点？"></a>能不能快一点？</h2><p>写 Ruby 上的 C 扩展一个比较麻烦的地方就在于这些 VALUE，VALUE 其实是一个指向 Ruby 对象的 uintptr_t 指针。如果我们减少对 Ruby 对象本身的调用，减少一些中间过程，理论上应该会更快。比如说，当我们发现 0x1 0x9 0xA 的 Opcode 是字符串类型，我们便可以不去创建 RARRAY 类型，而直接将字符串类型返回回去。</p><p>于是我们可以再实现一个 C 扩展函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ruby.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ruby/encoding.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">VALUE Midori = Qnil;</span><br><span class="line">VALUE MidoriWebSocket = Qnil;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Init_midori_ext</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">VALUE <span class="title">method_midori_websocket_mask</span><span class="params">(VALUE self, VALUE payload, VALUE mask)</span></span>;</span><br><span class="line"><span class="function">VALUE <span class="title">method_midori_websocket_mask_str</span><span class="params">(VALUE self, VALUE payload, VALUE mask)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Init_midori_ext</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  Midori = rb_define_module(<span class="string">"Midori"</span>);</span><br><span class="line">  MidoriWebSocket = rb_define_class_under(Midori, <span class="string">"WebSocket"</span>, rb_cObject);</span><br><span class="line">  rb_define_protected_method(MidoriWebSocket, <span class="string">"mask"</span>, method_midori_websocket_mask, <span class="number">2</span>);</span><br><span class="line">  rb_define_protected_method(MidoriWebSocket, <span class="string">"mask_str"</span>, method_midori_websocket_mask_str, <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">VALUE <span class="title">method_midori_websocket_mask</span><span class="params">(VALUE self, VALUE payload, VALUE mask)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">long</span> n = RARRAY_LEN(payload), i, p, m;</span><br><span class="line">  VALUE unmasked = rb_ary_new2(n);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> mask_array[] = &#123;</span><br><span class="line">      NUM2INT(rb_ary_entry(mask, <span class="number">0</span>)),</span><br><span class="line">      NUM2INT(rb_ary_entry(mask, <span class="number">1</span>)),</span><br><span class="line">      NUM2INT(rb_ary_entry(mask, <span class="number">2</span>)),</span><br><span class="line">      NUM2INT(rb_ary_entry(mask, <span class="number">3</span>))&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    p = NUM2INT(rb_ary_entry(payload, i));</span><br><span class="line">    m = mask_array[i % <span class="number">4</span>];</span><br><span class="line">    rb_ary_store(unmasked, i, INT2NUM(p ^ m));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> unmasked;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">VALUE <span class="title">method_midori_websocket_mask_str</span><span class="params">(VALUE self, VALUE payload, VALUE mask)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">long</span> n = RARRAY_LEN(payload), i, p, m;</span><br><span class="line">  <span class="keyword">char</span> result[n];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> mask_array[] = &#123;</span><br><span class="line">      NUM2INT(rb_ary_entry(mask, <span class="number">0</span>)),</span><br><span class="line">      NUM2INT(rb_ary_entry(mask, <span class="number">1</span>)),</span><br><span class="line">      NUM2INT(rb_ary_entry(mask, <span class="number">2</span>)),</span><br><span class="line">      NUM2INT(rb_ary_entry(mask, <span class="number">3</span>))&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    p = NUM2INT(rb_ary_entry(payload, i));</span><br><span class="line">    m = mask_array[i % <span class="number">4</span>];</span><br><span class="line">    result[i] = p ^ m;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> rb_enc_str_new(result, n, rb_utf8_encoding());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">    user     system      total        real</span><br><span class="line">5.372697   0.044040   5.416737 (  5.502921)</span><br><span class="line">4.994706   0.047653   5.042359 (  5.147833)</span><br><span class="line">3.745804   0.015971   3.761775 (  3.796537)</span><br></pre></td></tr></table></figure><p>这下，我们得到了 45% 的性能提升，这是个好开始。</p><h2 id="What-if…"><a href="#What-if…" class="headerlink" title="What if…"></a>What if…</h2><p>既然我们知道减少和 Ruby 对象的交互可以增加性能，如果我们把整个 decode 过程都用 C 实现一遍会怎么样呢？</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ruby.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ruby/encoding.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">VALUE Midori = Qnil;</span><br><span class="line">VALUE MidoriWebSocket = Qnil;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Init_midori_ext</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">VALUE <span class="title">method_midori_websocket_mask</span><span class="params">(VALUE self, VALUE payload, VALUE mask)</span></span>;</span><br><span class="line"><span class="function">VALUE <span class="title">method_midori_websocket_mask_str</span><span class="params">(VALUE self, VALUE payload, VALUE mask)</span></span>;</span><br><span class="line"><span class="function">VALUE <span class="title">method_midori_websocket_decode_c</span><span class="params">(VALUE self, VALUE data)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Init_midori_ext</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  Midori = rb_define_module(<span class="string">"Midori"</span>);</span><br><span class="line">  MidoriWebSocket = rb_define_class_under(Midori, <span class="string">"WebSocket"</span>, rb_cObject);</span><br><span class="line">  rb_define_protected_method(MidoriWebSocket, <span class="string">"mask"</span>, method_midori_websocket_mask, <span class="number">2</span>);</span><br><span class="line">  rb_define_protected_method(MidoriWebSocket, <span class="string">"mask_str"</span>, method_midori_websocket_mask_str, <span class="number">2</span>);</span><br><span class="line">  rb_define_method(MidoriWebSocket, <span class="string">"decode_c"</span>, method_midori_websocket_decode_c, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">VALUE <span class="title">method_midori_websocket_mask</span><span class="params">(VALUE self, VALUE payload, VALUE mask)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">long</span> n = RARRAY_LEN(payload), i, p, m;</span><br><span class="line">  VALUE unmasked = rb_ary_new2(n);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> mask_array[] = &#123;</span><br><span class="line">      NUM2INT(rb_ary_entry(mask, <span class="number">0</span>)),</span><br><span class="line">      NUM2INT(rb_ary_entry(mask, <span class="number">1</span>)),</span><br><span class="line">      NUM2INT(rb_ary_entry(mask, <span class="number">2</span>)),</span><br><span class="line">      NUM2INT(rb_ary_entry(mask, <span class="number">3</span>))&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    p = NUM2INT(rb_ary_entry(payload, i));</span><br><span class="line">    m = mask_array[i % <span class="number">4</span>];</span><br><span class="line">    rb_ary_store(unmasked, i, INT2NUM(p ^ m));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> unmasked;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">VALUE <span class="title">method_midori_websocket_mask_str</span><span class="params">(VALUE self, VALUE payload, VALUE mask)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">long</span> n = RARRAY_LEN(payload), i, p, m;</span><br><span class="line">  <span class="keyword">char</span> result[n];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> mask_array[] = &#123;</span><br><span class="line">      NUM2INT(rb_ary_entry(mask, <span class="number">0</span>)),</span><br><span class="line">      NUM2INT(rb_ary_entry(mask, <span class="number">1</span>)),</span><br><span class="line">      NUM2INT(rb_ary_entry(mask, <span class="number">2</span>)),</span><br><span class="line">      NUM2INT(rb_ary_entry(mask, <span class="number">3</span>))&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    p = NUM2INT(rb_ary_entry(payload, i));</span><br><span class="line">    m = mask_array[i % <span class="number">4</span>];</span><br><span class="line">    result[i] = p ^ m;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> rb_enc_str_new(result, n, rb_utf8_encoding());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">VALUE <span class="title">method_midori_websocket_decode_c</span><span class="params">(VALUE self, VALUE data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> byte, opcode;</span><br><span class="line">  ID getbyte = rb_intern(<span class="string">"getbyte"</span>);</span><br><span class="line"></span><br><span class="line">  byte = NUM2INT(rb_funcall(data, getbyte, <span class="number">0</span>));</span><br><span class="line">  opcode = byte &amp; <span class="number">0xf</span>;</span><br><span class="line"></span><br><span class="line">  byte = NUM2INT(rb_funcall(data, getbyte, <span class="number">0</span>));</span><br><span class="line">  <span class="keyword">if</span> ((byte &amp; <span class="number">0x80</span>) != <span class="number">0x80</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    rb_raise(rb_eRuntimeError, <span class="string">"NotMaskedError"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> n = byte &amp; <span class="number">0x7f</span>;</span><br><span class="line">  <span class="keyword">char</span> result[n];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> mask_array[] = &#123;</span><br><span class="line">      NUM2INT(rb_funcall(data, getbyte, <span class="number">0</span>)),</span><br><span class="line">      NUM2INT(rb_funcall(data, getbyte, <span class="number">0</span>)),</span><br><span class="line">      NUM2INT(rb_funcall(data, getbyte, <span class="number">0</span>)),</span><br><span class="line">      NUM2INT(rb_funcall(data, getbyte, <span class="number">0</span>))&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    result[i] = NUM2INT(rb_funcall(data, getbyte, <span class="number">0</span>)) ^ mask_array[i % <span class="number">4</span>];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (opcode == <span class="number">0x1</span> || opcode == <span class="number">0x9</span> || opcode == <span class="number">0xA</span>)</span><br><span class="line">    <span class="keyword">return</span> rb_enc_str_new(result, n, rb_utf8_encoding());</span><br><span class="line"></span><br><span class="line">  VALUE result_arr = rb_ary_new2(n);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    rb_ary_store(result_arr, i, INT2NUM(result[i]));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result_arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>跑一下 benchmark：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    user     system      total        real</span><br><span class="line">5.020994   0.029096   5.050090 (  5.108254)</span><br><span class="line">4.836846   0.035304   4.872150 (  4.953138)</span><br><span class="line">3.826166   0.021345   3.847511 (  3.892810)</span><br><span class="line">2.021958   0.014087   2.036045 (  2.066971)</span><br></pre></td></tr></table></figure><p>2.47x 速度，至此，我们将解码速度提高了 147%。</p><h2 id="副作用"><a href="#副作用" class="headerlink" title="副作用"></a>副作用</h2><p>然而显然，用 C 语言来写这样的代码安全性是很难保证的。特别是大家的 C 语言水平通常都不会太高超，一不小心来个内存泄漏分分钟就 gg 了。大多数时候，我们解决的性能问题都不是直接封装成库，如果是企业内部用，那么我们可以对编译过程提一些要求。一个比较有趣的尝试是 Rust 上的 <a href="https://usehelix.com/" target="_blank" rel="noopener">helix</a>。可以在保障内存安全的情况下写一些辅助函数，并且通过 Rust 宏的支持下，使得代码也没有 C 语言那么难看。</p><p>如果在你的业务场景中也有遇到运算密集（注意不是 I/O 密集瓶颈）时，通过 profiler 确认，不妨也可以试试用 C 扩展来实现一下吧！</p><p>最后留一个小问题，如果收到的 WebSocket 流非常长，能不能通过什么魔法使得编译器优化过程中触发 CPU 的 SIMD 特性，从而得到更快的速度呢？</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;引&quot;&gt;&lt;a href=&quot;#引&quot; class=&quot;headerlink&quot; title=&quot;引&quot;&gt;&lt;/a&gt;引&lt;/h2&gt;&lt;p&gt;在 WebSocket 协议中有一个重要的实现就是 masking（掩码），根据 RFC 6455 &lt;a href=&quot;https://tools.i
      
    
    </summary>
    
    
      <category term="编程" scheme="https://coderemixer.com/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="Ruby" scheme="https://coderemixer.com/tags/Ruby/"/>
    
  </entry>
  
  <entry>
    <title>Ruby 内联私有方法与原理</title>
    <link href="https://coderemixer.com/2018/07/03/ruby-inline-private-method/"/>
    <id>https://coderemixer.com/2018/07/03/ruby-inline-private-method/</id>
    <published>2018-07-03T12:35:49.000Z</published>
    <updated>2018-10-21T12:37:05.226Z</updated>
    
    <content type="html"><![CDATA[<p>孔乙己有一回对我说道，“你学过 Ruby 么？”我略略点一点头。他说，“学过 Ruby，……我便考你一考。private 私有方法，怎样写的？”我想，讨饭一样的人，也配考我么？便回过脸去，不再理会。孔乙己等了许久，很恳切的说道，“不能写罢？……我教给你，记着！这些字应该记着。将来做 CTO 的时候，写码要用。”我暗想我和 CTO 的等级还很远呢，而且我们 CTO 也从不在 Ruby 里写 private 方法；又好笑，又不耐烦，懒懒的答他道，“谁要你教，不是  <code>private</code>  换行之后就是  <code>def</code>  的都是私有方法么？”孔乙己显出极高兴的样子，将两个指头的长指甲敲着柜台，点头说，“对呀对呀！…… <code>private</code>  的三种写法，你知道么？”我愈不耐烦了，努着嘴走远。孔乙己刚用指甲蘸了酒，想在柜上写字，见我毫不热心，便又叹一口气，显出极惋惜的样子。</p><p>孔乙己这里说的 <code>private</code> 的三种写法其中有两种是非常常见的，第一种是：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span></span><br><span class="line">    private</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">a</span></span></span><br><span class="line">        <span class="string">'a'</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>另一种则是：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">a</span></span></span><br><span class="line">        <span class="string">'a'</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"> private <span class="symbol">:a</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>这两种各有优劣，第一种  <code>private</code>  后的方法都是私有方法，有效组织了方法顺序。而第二种则可以随意定义方法，之后再定义哪些是  <code>private</code>  方法。</p><p>之前在看 Rubocop 的代码风格的一些 Issue 讨论的时候，看到了  <code>private</code>  的第三种写法，目前 midori 项目中使用的是这种作法：内联私有方法。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span></span><br><span class="line">    private <span class="function"><span class="keyword">def</span> <span class="title">a</span></span></span><br><span class="line">        <span class="string">'a'</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>这种写法的好处是，可以很清楚知道某一个方法是不是私有方法，也可以随意组织方法的顺序。但是奇怪了，似乎很少有看到 Ruby 正式的文档里提到过这种写法，这到底是一种什么写法？Ruby 为什么支持这种写法？</p><p>我们运行一下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ruby -e <span class="string">"class Test; private def a; 'a'; end; end"</span> --dump parseTree</span><br></pre></td></tr></table></figure><p>看一下 Ruby 对这段魔法代码的 AST 树：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">###########################################################</span><br><span class="line">## Do NOT use this node dump for any purpose other than  ##</span><br><span class="line">## debug and research.  Compatibility is not guaranteed. ##</span><br><span class="line">###########################################################</span><br><span class="line"></span><br><span class="line"># @ NODE_SCOPE (line: 1, code_range: (1,0)-(1,40))</span><br><span class="line"># +- nd_tbl: (empty)</span><br><span class="line"># +- nd_args:</span><br><span class="line"># |   (null node)</span><br><span class="line"># +- nd_body:</span><br><span class="line">#     @ NODE_PRELUDE (line: 1, code_range: (1,0)-(1,40))</span><br><span class="line">#     +- nd_head:</span><br><span class="line">#     |   (null node)</span><br><span class="line">#     +- nd_body:</span><br><span class="line">#     |   @ NODE_CLASS (line: 1, code_range: (1,0)-(1,40))</span><br><span class="line">#     |   +- nd_cpath:</span><br><span class="line">#     |   |   @ NODE_COLON2 (line: 1, code_range: (1,6)-(1,10))</span><br><span class="line">#     |   |   +- nd_mid: :Test</span><br><span class="line">#     |   |   +- nd_head:</span><br><span class="line">#     |   |       (null node)</span><br><span class="line">#     |   +- nd_super:</span><br><span class="line">#     |   |   (null node)</span><br><span class="line">#     |   +- nd_body:</span><br><span class="line">#     |       @ NODE_SCOPE (line: 1, code_range: (1,0)-(1,40))</span><br><span class="line">#     |       +- nd_tbl: (empty)</span><br><span class="line">#     |       +- nd_args:</span><br><span class="line">#     |       |   (null node)</span><br><span class="line">#     |       +- nd_body:</span><br><span class="line">#     |           @ NODE_BLOCK (line: 1, code_range: (1,10)-(1,35))</span><br><span class="line">#     |           +- nd_head (1):</span><br><span class="line">#     |           |   @ NODE_BEGIN (line: 1, code_range: (1,10)-(1,10))</span><br><span class="line">#     |           |   +- nd_body:</span><br><span class="line">#     |           |       (null node)</span><br><span class="line">#     |           +- nd_head (2):</span><br><span class="line">#     |               @ NODE_FCALL (line: 1, code_range: (1,12)-(1,35))</span><br><span class="line">#     |               +- nd_mid: :private</span><br><span class="line">#     |               +- nd_args:</span><br><span class="line">#     |                   @ NODE_ARRAY (line: 1, code_range: (1,20)-(1,35))</span><br><span class="line">#     |                   +- nd_alen: 1</span><br><span class="line">#     |                   +- nd_head:</span><br><span class="line">#     |                   |   @ NODE_DEFN (line: 1, code_range: (1,20)-(1,35))</span><br><span class="line">#     |                   |   +- nd_mid: :a</span><br><span class="line">#     |                   |   +- nd_defn:</span><br><span class="line">#     |                   |       @ NODE_SCOPE (line: 1, code_range: (1,20)-(1,35))</span><br><span class="line">#     |                   |       +- nd_tbl: (empty)</span><br><span class="line">#     |                   |       +- nd_args:</span><br><span class="line">#     |                   |       |   @ NODE_ARGS (line: 1, code_range: (1,25)-(1,25))</span><br><span class="line">#     |                   |       |   +- nd_ainfo-&gt;pre_args_num: 0</span><br><span class="line">#     |                   |       |   +- nd_ainfo-&gt;pre_init:</span><br><span class="line">#     |                   |       |   |   (null node)</span><br><span class="line">#     |                   |       |   +- nd_ainfo-&gt;post_args_num: 0</span><br><span class="line">#     |                   |       |   +- nd_ainfo-&gt;post_init:</span><br><span class="line">#     |                   |       |   |   (null node)</span><br><span class="line">#     |                   |       |   +- nd_ainfo-&gt;first_post_arg: (null)</span><br><span class="line">#     |                   |       |   +- nd_ainfo-&gt;rest_arg: (null)</span><br><span class="line">#     |                   |       |   +- nd_ainfo-&gt;block_arg: (null)</span><br><span class="line">#     |                   |       |   +- nd_ainfo-&gt;opt_args:</span><br><span class="line">#     |                   |       |   |   (null node)</span><br><span class="line">#     |                   |       |   +- nd_ainfo-&gt;kw_args:</span><br><span class="line">#     |                   |       |   |   (null node)</span><br><span class="line">#     |                   |       |   +- nd_ainfo-&gt;kw_rest_arg:</span><br><span class="line">#     |                   |       |       (null node)</span><br><span class="line">#     |                   |       +- nd_body:</span><br><span class="line">#     |                   |           @ NODE_STR (line: 1, code_range: (1,27)-(1,30))</span><br><span class="line">#     |                   |           +- nd_lit: &quot;a&quot;</span><br><span class="line">#     |                   +- nd_next:</span><br><span class="line">#     |                       (null node)</span><br><span class="line">#     +- nd_compile_option:</span><br><span class="line">#         +- coverage_enabled: false</span><br></pre></td></tr></table></figure><p>关键地方在</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">#     |           +- nd_head (2):</span><br><span class="line">#     |               @ NODE_FCALL (line: 1, code_range: (1,12)-(1,35))</span><br><span class="line">#     |               +- nd_mid: :private</span><br><span class="line">#     |               +- nd_args:</span><br><span class="line">#     |                   @ NODE_ARRAY (line: 1, code_range: (1,20)-(1,35))</span><br><span class="line">#     |                   +- nd_alen: 1</span><br><span class="line">#     |                   +- nd_head:</span><br><span class="line">#     |                   |   @ NODE_DEFN (line: 1, code_range: (1,20)-(1,35))</span><br><span class="line">#     |                   |   +- nd_mid: :a</span><br><span class="line">#     |                   |   +- nd_defn:</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>可见，这里的  <code>private</code>  被视作一个方法，而接收的参数的  <code>def</code>  定义的方法的返回。<code>def</code>  的返回是什么呢？是方法的  <code>Symbol</code>。也就是说：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">private <span class="function"><span class="keyword">def</span> <span class="title">a</span></span></span><br><span class="line">    <span class="string">'a'</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 等价于</span></span><br><span class="line"></span><br><span class="line">tmp = <span class="function"><span class="keyword">def</span> <span class="title">a</span></span></span><br><span class="line">    <span class="string">'a'</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">tmp <span class="comment"># =&gt; :a</span></span><br><span class="line"></span><br><span class="line">private tmp</span><br></pre></td></tr></table></figure><p>可见这个方法并不是真正所谓的内联，并没有什么  <code>private def</code>  的关键字，只是使用了一些 tricky 的方法使它看起来是内联的。那么这种写法有什么副作用？</p><p>让我们梦回一下 2013 年，看一眼 2013 年 Ruby 2.1 的发布<a href="https://github.com/ruby/ruby/blob/v2_1_0/NEWS" target="_blank" rel="noopener">新闻</a>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">def-expr now returns the symbol of its name instead of nil.</span><br></pre></td></tr></table></figure><p>也就是说  <code>def</code>  表达式返回其名字的  <code>Symbol</code>  正是当时引入的特性。在这个特性的支持下，也就可以实现内联私有方法这种 trick 了。如果你的项目仍需要向下兼容到 Ruby 2.1 就不能使用这种方法了。</p><p>考虑到 Ruby 2.2 也已经 <a href="https://www.ruby-lang.org/en/news/2018/06/20/support-of-ruby-2-2-has-ended/" target="_blank" rel="noopener">EOL</a> 了，是否是用这种方法来实现私有方法已经完全变成了一种代码风格的取舍。如果你喜欢这种风格的私有方法，不妨在下一个项目里试一试吧。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;孔乙己有一回对我说道，“你学过 Ruby 么？”我略略点一点头。他说，“学过 Ruby，……我便考你一考。private 私有方法，怎样写的？”我想，讨饭一样的人，也配考我么？便回过脸去，不再理会。孔乙己等了许久，很恳切的说道，“不能写罢？……我教给你，记着！这些字应该记着
      
    
    </summary>
    
    
      <category term="编程" scheme="https://coderemixer.com/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="Ruby" scheme="https://coderemixer.com/tags/Ruby/"/>
    
  </entry>
  
  <entry>
    <title>关于学习编程的一箩筐问题</title>
    <link href="https://coderemixer.com/2018/06/06/coding-tutorial/"/>
    <id>https://coderemixer.com/2018/06/06/coding-tutorial/</id>
    <published>2018-06-05T19:21:04.000Z</published>
    <updated>2018-10-21T12:24:37.951Z</updated>
    
    <content type="html"><![CDATA[<h2 id="序"><a href="#序" class="headerlink" title="序"></a>序</h2><p>两个月前和 16 岁 JK 美少女 @-顾兮- 一起吃饭的时候聊到了计算机教育入门的话题。之前虽然我写过一些批判培训班的文章，但是所谓只破不立，至于到底怎么学习是对的，很难有个界定标准。想到今天睡不着觉，于是想到以后如果再有微博私信问计算机教育空洞而广泛的问题的话，这篇文章将是我想说的全部答案。</p><h2 id="为什么需要编程？"><a href="#为什么需要编程？" class="headerlink" title="为什么需要编程？"></a>为什么需要编程？</h2><p>以前我喜欢把这个问题表达成「为什么要学习编程？」在收到了不少「为了钱」这样的答案之后，我决定换个方式来问这个问题。「为什么需要编程？」如果你提供编程的服务，而别人为此付钱。别人为什么付钱？别人为什么要从你这里购买服务？这个答案最宽泛的回答就是「我们用编程来解决问题。」</p><p>人们的日常工作生活有大量的问题，比如低下的沟通效率、低下的执行效率等等。而我们使用编程的技术，来帮助人类解决这其中的 <strong>一部分</strong> 问题。而这，是编程的根本意义。</p><h2 id="学习编程的前置条件"><a href="#学习编程的前置条件" class="headerlink" title="学习编程的前置条件"></a>学习编程的前置条件</h2><p>显然地，编程不是魔法。要想写代码，事实上随便学习一下，几个月能写出一些东西我想是没有问题的。这也是为什么那么多培训班能存活下来的原因。但要想写好代码，两个必不可少的因素是对数学的敏感和放洋屁的能力。这两点既需要人的一些天赋，亦需要长时间的训练才能达到。</p><p>对于数学的敏感性不是指对算术的敏感性。中国人扎实的基础教育让大家对算术都很敏感，去买个菜从来不会算错找零钱。但事实上，在编程中，算术问题是极易通过计算机来解决的。人所要做的，是如何让计算机解决问题。要想做到这一点，要有能很好地将现实中的问题转换成清晰、直观的数学模型的能力。</p><p>而放洋屁的能力关键落在编程的社会性上。我知道不少因为英语问题而被严重困扰的码农们的日常。虽然大多数东西都能找到「中文文档」，但在大多数情况下，中文文档往往不是一手资料，甚至有可能是过时资料。英文是假设每个不在使用易语言的程序员都应该掌握的能力。当你使用的库遇到了 bug，跑到 GitHub 上狂开一通中文，且不说礼貌问题，对于解决问题本身亦会造成极大的困难。</p><p>这两点对于很多人来说可能是灾难性的。大学 CS101 写个求<a href="https://en.wikipedia.org/wiki/Narcissistic_number" target="_blank" rel="noopener">水仙花数</a>的题目，对于一些人来说，就像是说话一样在描述问题，而对另一些人完全找不到下手的地方。还有我非常喜欢讨论的 <a href="https://en.wikipedia.org/wiki/Fizz_buzz" target="_blank" rel="noopener">FizzBuzz 问题</a>，亦是考察描述模型时考虑是否周全的好例子。而另一些人看到英文字母就头晕，完全没有读下去的能力。对于这些人来说，我的建议是我不太推荐你来学习编程。这不是说你不能通过学习来通过编程谋生，而是你的职业道路会非常坎坷，你会因为基础的不牢固而还债。</p><h2 id="计算机科学"><a href="#计算机科学" class="headerlink" title="计算机科学"></a>计算机科学</h2><p>今天看到一个知乎上的问题：</p><p><a href="https://www.zhihu.com/question/279911002/" target="_blank" rel="noopener">「既然终究要成为码农，那么大学计算机系的意义何在？」</a></p><blockquote><p>此问题，源于 Hacker News 上的一个帖子：<a href="https://link.zhihu.com/?target=https%3A//news.ycombinator.com/item%3Fid%3D17235832" target="_blank" rel="noopener">Are you working on interesting technical problems?</a></p><p>题主对此也是很有感触，今年刚换了工作，令我惊讶的是身边的同事有一批二本毕业的（没有歧视，就事论事），有几个比我还小，题主的大学虽然只是普通 211 但是我一直在努力地学习技术，毕业两年下班之后几乎没有过多的娱乐时间，都在看内核相关的东西，可是结果却是两年过后我依然和他们在同一个水平线上。四年的大学生涯并没有为自己增加多少能力，所谓的离散数学，所谓的算法，所谓的计算机原理，到现在为止都没有用上，至于那些 Linux 操作之类的完全没必要早接触，还不如那些在工作中临时学的人节省时间。工作中的用到的大部分知识基本都可以在工作中逐渐学会，大学努力所学的一切，所花费的精力都在一瞬间成为了泡影。感觉自己正在失去信念，越来越觉得大学计算机系和培训机构没什么太大区别，学出来都是做码农的，知乎上大神们谈论的高深的计算机科学到底在哪里，为什么这么难以见到？</p></blockquote><p>事实上这个问题的前提「既然终究要成为码农」就有一些问题，显然不是所有人都会成为码农。我现在的工作，和 Linux 底层、算法就强相关。写代码，可以做业务强相关的码农。但计算机科学，有很多与业务相对无关，非常重视底层技术的工作需要做，而且这些工作还很难找到适任的人。</p><p>「都在看内核相关的东西，可是结果却是两年过后我依然和他们在同一个水平线上。」这一点我是相当怀疑的，所谓看内核的东西，究竟是看看博客当小说，还是带着问题，特别去深究一些功能究竟在干什么，要解决什么问题。这些信息往往在解决特定问题的时候会变得非常实用。</p><p>高德纳说过：「在大概 97% 的时间里，我们应该忘记微小的性能提升。过早优化是万恶之源。」</p><p>很多人把这句话视为教条，但这句话的后半句紧跟着就是「我们不能放弃剩下的 3%。」怎么发现 3%，发现 3% 后怎么解决？而这 3% 的关键问题往往是决定你产品快和慢、好用还是不好用甚至是能用还是不能用的关键。如果你已经甘心成为一名码农放弃了这 3%，那么你自然不会觉得这些东西有用。</p><p>读大学的时候时间非常充沛，要想边工作边阅读 Linux 内核实现、gcc 的实现恐怕已经变得越来越难了。大学时的算法、数据结构、编译原理、离散数学、计算机组成原理这些经典基础课程存在是你来解决这些问题的基础。然而一个非常值得诟病的一点是，事实上，我们今天的大学计算机科学教育在科学上教得太浅在工程上也教得不深。如果学生本身没有兴趣，没有深入自学这些内容，这甚至使得大学毕业的同学无论是当一名码农还是当一名计算机科学家都不适任，大学毕业后在一批转岗后，最后又回到了师傅带徒弟的技工模式。</p><h2 id="初学者该学哪门语言？"><a href="#初学者该学哪门语言？" class="headerlink" title="初学者该学哪门语言？"></a>初学者该学哪门语言？</h2><p>这个问题大概是我被问到次数最多，也是最让我无语的问题。就我个人认为，除了某些学习要求特别高的语言比如什么 Haskell、Idris 之类的，大多数我们常听到的语言都可以作为初学语言，比如 Python、Java、Swift、Ruby、PHP、C#、C、C++ 甚至是 Scheme。我不认为学习某一种语言本身是一种障碍，虽然每一门语言各有特色和优劣，但因为编程的逻辑大体上基本是相通的，学习编程从来不是学习某一门特定语言。</p><p>然而后来我发现，大多数问这个问题的其实问的是另外一个意思，是「初学者学习哪一门语言有前（钱）途？」这个问题完全没有意思，如果你只想学一门语言，混吃等死，那么就永远没有前途。</p><p>P.S. 翻了下平均薪资，好像写 F# 最有前途（逃</p><h2 id="如何规划学习路径？需要报班吗？"><a href="#如何规划学习路径？需要报班吗？" class="headerlink" title="如何规划学习路径？需要报班吗？"></a>如何规划学习路径？需要报班吗？</h2><p>这也是一个常被问到的问题，特别是已经入门学习了一点编程知识的人。我觉得既然编程的本质是来帮助人类解决问题，那么问题就是关键。既然我们在为这个互联网世界服务，那么我们也可以利用互联网来为我们自己服务。简单来讲就是「从兴趣出发，从问题出发」。</p><p>之前有收到一封私信，内容如下：</p><blockquote><p>博主您好，我是一名非计算机专业在校生，刚刚自学计算机课程已学的有 C 语言、组成原理、数据结构、操作系统四门，但发现您和很多技术博主包括论坛上的大部分内容我还是看不懂，尤其是其中的很多英文简称。请问您是否可以告诉我如何开始学习那些知识？</p></blockquote><p>无论是 C 语言、计算机组成原理、数据结构、操作系统都是非常基础的课程，他们是构成软件构成非常底层的内容。当我们谈论某一些具体的技术的时候，通常很碎片，并不会直接讨论这些东西。举例来说，如果我们要讨论非阻塞 I/O，那么我们会举例一些实际的技术，比如 Linux 上的 epoll。至于需要弄清 epoll 的实现，了解 epoll 为什么快，就可以通过比较 epoll 和比如 Windows 上的 IOCP。而比较过程就需要对操作系统、算法有比较好的理解。而这些在你单独上这几门课的时候都不会讲得非常具体。</p><p>那么怎么学习这些东西呢？用 Google 搜索，查 Wikipedia，找 Stack Overflow。当你知道一个你不知道的关键词的时候，就去搜索它，然后会出来更多你不知道的概念，直到你了解的概念为止。你就能搞清楚这个技术具体是什么，以及解决了什么具体的问题。然后要自己具体去实践，写一些相关的代码，尝试做一些与之有关的 Hobby Project。就会让你对这东西有比较好的了解，也能从碎片中掌握一门新的技术了。</p><p>至于需不需要报班，在这个过程中我想已经有答案了。因为你从班上能学习到的知识，明明点点鼠标就已经可以知道了。而如果你需要一个班来给你填鸭式地教学，那么出了这个班，你依然没有学习的能力。</p><h2 id="女孩子可以学习编程吗？"><a href="#女孩子可以学习编程吗？" class="headerlink" title="女孩子可以学习编程吗？"></a>女孩子可以学习编程吗？</h2><p>讲道理，我也认为这是一个非常鬼扯的问题，但是确实就是有很多人问。</p><p>你能举出男性在学习编程的过程中和女性又任何差别吗？女性有任何生理上的不同限制了她不能学习编程吗？</p><p>或者换个说法：</p><p>既然一个男孩子可以编程，那么一个女装子可以编程吗？</p><p>那么一个做了变性手术的男孩子可以编程吗？</p><p>如果一个男孩子，看起来像女孩子，游泳像女孩子，叫声像女孩子，那么他可以……编程吗？</p><h2 id="结"><a href="#结" class="headerlink" title="结"></a>结</h2><p>有一个很有趣的说法叫「Everything is a Remix」，类似于中文里的「天下作文一大抄」的感觉。天下所有歌曲都是 Remix，音符、和弦、调式、编曲模式都不是你发明的，但你把他们组合起来让它听起来好听。今天程序也是一个 Remix，我们将现有的技术组合起来解决现实问题，甚至组合起来发明更新的技术。程序，在一些人眼里也许非常魔法，但事实上了解一下它，并没有什么魔法的。</p><p>但讲真的，考虑几个月学还是不学，随便找个书、找个交互式编程网站之类的只需要几个小时就可以学起来嘛。到时候究竟自己是适合学习，还是不适合学习，不是几个小时后就能知道？</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;序&quot;&gt;&lt;a href=&quot;#序&quot; class=&quot;headerlink&quot; title=&quot;序&quot;&gt;&lt;/a&gt;序&lt;/h2&gt;&lt;p&gt;两个月前和 16 岁 JK 美少女 @-顾兮- 一起吃饭的时候聊到了计算机教育入门的话题。之前虽然我写过一些批判培训班的文章，但是所谓只破不立，至于
      
    
    </summary>
    
    
      <category term="编程" scheme="https://coderemixer.com/tags/%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>MySQL 惊险恢复记</title>
    <link href="https://coderemixer.com/2018/01/05/mysql-recover-from-general/"/>
    <id>https://coderemixer.com/2018/01/05/mysql-recover-from-general/</id>
    <published>2018-01-05T12:48:59.000Z</published>
    <updated>2018-10-21T12:54:32.098Z</updated>
    
    <content type="html"><![CDATA[<h2 id="引"><a href="#引" class="headerlink" title="引"></a>引</h2><p>昨天接到朋友的一个电话，说服务器被攻击了。上去一看，Windows 主机弱密码，直接被远程登录中了勒索病毒，要价就是好几十比特币。所有文件都被加密。遇到这个问题，第一反应就是完蛋，直接恢复备份吧。然而这是台物理机，而不是云主机，备份没有那么方便，所以这台机器</p><p><strong>没有备份。</strong></p><p>这基本上已经基本判了死刑了，当时的解决是立刻切断服务器电源，挂载到安全的电脑上找一些还没来得及被加密的文件抢救。</p><h2 id="初探"><a href="#初探" class="headerlink" title="初探"></a>初探</h2><p>由于朋友当时不知道怎么拆 RAID 阵列，所以就直接把服务器整机搬到了我家里。🤦‍</p><p>不过后来我拆开一看，其实只是一个 RAID 1，所以任何一块盘的内容是一样的，随便拔一块下来。联想收购 ThinkServer 后干的最大的大好事就是把硬盘架上的 T6H 螺丝换成了标准的十字螺丝。（我之前在 ThinkServer 螺丝问题上的坑爹遭遇参考<a href="/2017/02/14/build-up-x79-workstation/">此贴</a>）</p><p>SATA 连上电脑检查文件。硬盘的核心文件是一个 MySQL 数据库，其它文件都是 stateless 的代码，倒是很容易恢复。根据恢复 MySQL 数据库的经验，第一反应是去找 MySQL 二进制日志文件。许多数据灾难最后都是通过二进制日志恢复的，而且这些已经都有非常成熟的工具可以直接使用。</p><p>然而找到 <code>log</code> 的目录的时候发现所有的 <code>.bin</code> 文件已经变成了 <code>.bin.RESERVE</code>，显然是已经被加密没救了。</p><h2 id="转机"><a href="#转机" class="headerlink" title="转机"></a>转机</h2><p>然而接下来，我突然发现，这个病毒的实现有个 Bug，一个实实在在的 Bug，为这个事情发现了转机。病毒没有加密所有文件，因为如果这样，它也无法发送自己的勒索信息，所以它保留了其自己生成出来文件名的文件不被加密。然而为了方便判断这个「自己生成」的概念，病毒是直接依靠后缀的。病毒保留了 <code>.html</code> <code>.txt</code> 和 <code>.log</code> 后缀的所有文件。</p><p><code>.log</code>？这个通用的日志格式不也是 MySQL General Query Log 用的吗？虽然一般情况下，我们不会打开 MySQL General Query Log 这个那么低级别的 Log，<strong>但是</strong> 这台机器完全是一群不懂运维的人维护的。所有 MySQL 竟然是用 WAMP 全家桶安装的，还真的默认开启了 MySQL General Query Log。把 <code>mysql.log</code> 文件 dump 下来，果然完整叙述了这台机器运行一年间所有的连接和查询信息。依靠这个看来可以把所有数据都还原了！</p><h2 id="Oh-General-My-General"><a href="#Oh-General-My-General" class="headerlink" title="Oh General! My General!"></a>Oh General! My General!</h2><p>MySQL General Query Log 虽然信息全，但并没有好用的直接把数据倒回去的工具（毕竟会开这个选项的可能性就很小吧）。那么没有就自己写咯。</p><p>简单写了个 MySQL General Query Log 恢复工具：<a href="https://github.com/dsh0416/my-general" target="_blank" rel="noopener">my_general</a></p><p>这个工具的原理很简单，就是 parse log，然后判断这一行是不是一个 QUERY。然后简单判断了一下这个 QUERY 是不是一个 <code>SELECT</code> 或者 <code>SHOW</code>。如果是，就直接跳过；如果不是，那么就在数据库上运行一下。</p><p>然而这个还是有一些问题，有一些 QUERY 是在 <code>DATABASE</code> 层做的，有些是连接上具体 <code>DATABASE</code> 进行的。但是由于问题比较简单，我就先手动建立 <code>DATABASE</code>，然后过滤所有 <code>CREATE DATABASE</code> 和 <code>CREATE USER</code> 的操作。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&gt; gem install my_general</span><br><span class="line">&gt; my_general -l mysql.log -d connection.yaml</span><br><span class="line"></span><br><span class="line">Log File:           mysql.log</span><br><span class="line">Database YAML:      connection.yml</span><br><span class="line">[1/4] ⌚  Counting Complexity...</span><br><span class="line">[1/4] ⌚  Counting Complexity... OK [Complexity: 17793561]</span><br><span class="line">[2/4] 🔌  Dailing Database...</span><br><span class="line">[2/4] 🔌  Dailing Database... OK [Connected]</span><br><span class="line">[3/4] ⏳  Importing Data...</span><br><span class="line">Progress: |=====================================================================|</span><br><span class="line">[3/4] ⏳  Importing Data... OK [17793561/17793561]</span><br><span class="line">[4/4] 🚩  Finished!</span><br></pre></td></tr></table></figure><p>解决！</p><p>不过这玩意有一些问题，因为分隔符是换行号，如果主动比如在 <code>CREATE TABLE</code> 的时候自己拼一些换行号可能会爆炸。如果是用 ORM 做的 Migration 和日常使用，倒是没有这种特殊符号的问题。</p><h2 id="结"><a href="#结" class="headerlink" title="结"></a>结</h2><p>做备份啊，做备份。备份不到用的时候永远被低估，一旦用到就悔恨万分。</p><p>保持良好的用机习惯，不要没事上服务器下片。这服务器上连天猫、淘宝的浏览记录都有，还把 IE 的安全级别调低了。</p><p>还有就是，遇到这种非常规的问题，不能紧张，保持乐观，要仔细寻找线索。</p><p>反正修不好是常态，万一修好了呢。（逃</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;引&quot;&gt;&lt;a href=&quot;#引&quot; class=&quot;headerlink&quot; title=&quot;引&quot;&gt;&lt;/a&gt;引&lt;/h2&gt;&lt;p&gt;昨天接到朋友的一个电话，说服务器被攻击了。上去一看，Windows 主机弱密码，直接被远程登录中了勒索病毒，要价就是好几十比特币。所有文件都被加密。
      
    
    </summary>
    
    
      <category term="编程" scheme="https://coderemixer.com/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="Ruby" scheme="https://coderemixer.com/tags/Ruby/"/>
    
      <category term="运维" scheme="https://coderemixer.com/tags/%E8%BF%90%E7%BB%B4/"/>
    
      <category term="MySQL" scheme="https://coderemixer.com/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>Rack/Rails 服务器获取用户 IP 问题分享</title>
    <link href="https://coderemixer.com/2017/12/26/rack-rails-user-ip-bug/"/>
    <id>https://coderemixer.com/2017/12/26/rack-rails-user-ip-bug/</id>
    <published>2017-12-26T12:58:59.000Z</published>
    <updated>2018-10-21T12:59:46.519Z</updated>
    
    <content type="html"><![CDATA[<h2 id="引"><a href="#引" class="headerlink" title="引"></a>引</h2><p>由于最近论坛发生了某些讨论，出现了一个恶意攻击的账号。然而去查用户 IP 时，却发现没有拿到用户的 IP。这个问题非常诡异，几经排查，终于发现了问题，问题同时发生在 Rack 和 Rails 的实现上，这意味着这个问题可能影响几乎所有 Ruby Web 服务器。故有必要写下此文，分享这一问题。</p><h2 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h2><p>我们先做一个假设问题，如果你是 Rack 的作者，你会如何获取客户端的 IP 地址？</p><p>最容易想到的就是直接获取 TCP 连接的 IP。这个在 Rack 中已经被 parse 成  <code>env[&#39;REMOTE_ADDR&#39;]</code> 了，于是直接获取这个值就可以了。这个做法基本上是对的，但是很快就遇到了问题。如果我的服务器躲在 HTTP 反向代理或者负载均衡之后，那么我获取到的岂不是都是代理的 IP 而不是真正的用户 IP 了吗？</p><p>早年有一些公司会自己设置 HTTP header 来解决这一问题。2004 年 IETF 通过了 <a href="https://tools.ietf.org/html/rfc7239" target="_blank" rel="noopener">RFC 7239 标准</a>，为这样的问题制定了通用的标准。简单来说，就是用 <code>X-Real-IP</code> header 标记用户的真实 IP，用 <code>X-Forwarded-For</code> header 标记途径路由。</p><p>这时候你可能会想 <code>X-Real-IP</code> 不是已经表示了用户的真实 IP 了吗？为什么还需要 <code>X-Forwarded-For</code> 呢？因为 <code>X-Real-IP</code> 可能是用户伪造的。当然这也取决于你的反向代理是怎么配置的，如果你在 nginx 中强写 <code>X-Real-IP</code> 其实没有这一问题。</p><p>但 Rack 作为一个通用的 Web 服务器框架，并不能相信用户会正确处理这个 header。Rack 的判断逻辑初衷是这样的：请求经过了一系列的节点，写了 <code>X-Forwarded-For</code> header，去掉可信任的路由，经过的最后一个路由，是用户 IP。如果用户伪造这个头，那也会是最后一个被最后一个内网路由加上其真实的 IP，从而避开攻击。</p><p>听起来很合理，但是这留下了一个问题：</p><ul><li><strong>哪些路由 IP 是可信任的？</strong></li></ul><h2 id="大于配置的约定"><a href="#大于配置的约定" class="headerlink" title="大于配置的约定"></a>大于配置的约定</h2><h3 id="可信任-内网？"><a href="#可信任-内网？" class="headerlink" title="可信任 = 内网？"></a>可信任 = 内网？</h3><p>Rack 没有强制要求用户自己配置，其判断哪些是可信任的路由 IP 是通过判断 IP 是不是在内网下来的，这在大多数情况下，确实工作，所以我们可能根本不会注意到它。下面是代码：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># https://github.com/rack/rack/blob/b0818268fd9f4026a1b0fb205cc1060ee38a23cc/lib/rack/request.rb#L419</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">trusted_proxy?</span><span class="params">(ip)</span></span></span><br><span class="line">  ip =~ <span class="regexp">/\A127\.0\.0\.1\Z|\A(10|172\.(1[6-9]|2[0-9]|30|31)|192\.168)\.|\A::1\Z|\Afd[0-9a-f]&#123;2&#125;:.+|\Alocalhost\Z|\Aunix\Z|\Aunix:/i</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>这一串正则可以说是相当的刺激，抛开后面的 unix 文件描述符、localhost 和 IPv6 不讲。前面一部分的正则非常取巧。因为在 IP 地址 3 种主要类型（A 类地址、B 类地址、C 类地址）里各有一部分可以作为私有地址。</p><p>A类地址：10.0.0.0～10.255.255.255 </p><p>B类地址：172.16.0.0～172.31.255.255 </p><p>C类地址：192.168.0.0～192.168.255.255</p><p>而 Rack 就是把它们过滤掉了，这些确实描述了可能的内网地址。无论你架在云服务商那里，还是自建机房，能分配的内网确实就是这些。这在大多数情况下工作，除非：</p><h3 id="可信任-内网-可信任外网"><a href="#可信任-内网-可信任外网" class="headerlink" title="可信任 = { 内网, 可信任外网 }"></a>可信任 = { 内网, 可信任外网 }</h3><p>如果你的代理跨内网，比如在多个可用区之间代理，又或者把服务器架在高防后，而高防和你的 IP 不在同一个内网，那你就悲剧了。</p><p>因为中间跨越了公网 IP，Rack 的正则没有 match 上，所以自然就视其为不可信任的 IP，直接取了这个 IP 作为客户端的 IP。</p><p>特别是后者，因为你切换高防是一个很仓促的事件，可能根本想不清这些事，而一旦在高防期间出了问题，就真的查不到 IP 了。</p><h3 id="影响"><a href="#影响" class="headerlink" title="影响"></a>影响</h3><p>由于这个问题出在 Ruby Web 最常用的框架 Rack 上。无论是 Sinatra、Cuba 还是 Rails 都是直接建在上面，Rails 的各种 gem 例如 Devise 也是基于这个假设是正确的。所以几乎所有的 Ruby Web 应用都会受影响。<del>当然你裸写 TCP 本来就是要自己处理的，自然不受影响。</del></p><h2 id="如何配置-Rack"><a href="#如何配置-Rack" class="headerlink" title="如何配置 Rack"></a>如何配置 Rack</h2><p>于是，如果我们要配置，怎么配置呢？Rack 本身并没有直接暴露配置的接口，所以答案就只剩下一种：</p><p><strong>元编程</strong></p><p>例如我需要加入特殊可信任 IP 1.2.3.4，在你应用监听前，Rack 被 require 后（例如 Rails 的 initializer 里）加入形如以下的代码：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">module</span> <span class="title">Rack</span></span></span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Request</span></span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">trusted_proxy?</span><span class="params">(ip)</span></span></span><br><span class="line">      ip =~ <span class="regexp">/\A127\.0\.0\.1\Z|\A(10|172\.(1[6-9]|2[0-9]|30|31)|192\.168)\.|\A::1\Z|\Afd[0-9a-f]&#123;2&#125;:.+|\Alocalhost\Z|\Aunix\Z|\Aunix:|\A1\.2\.3\.4Z/i</span></span><br><span class="line">      <span class="comment"># 自定义的判断函数，可信任的返回任意值，不可信任的返回 nil 即可。</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>另外需要注意的时，这里不适合从文件或网络 I/O 中获取判断的条件，因为这个部分会被非常频繁地调用，除非你自己实现缓存。</p><h2 id="Rails-用户的坑"><a href="#Rails-用户的坑" class="headerlink" title="Rails 用户的坑"></a>Rails 用户的坑</h2><p>如果你是 Rails 应用，以为做到上面就够了吗？你有没有注意到 Rails 的默认中间件中有一个 <code>ActionDispatch::RemoteIp</code>，你知道这是啥玩意吗？</p><p>Rails 也认识到了 Rack 有这个问题，为了方便配置，把获取 IP 的部分自己单独实现了一遍，默认也是信任内网，然后新建了一个参数： <code>request.remote_ip</code> 用来记录这个值。Rails 看似好意其实带来了不便，因为仍然有许多 gem 是基于 Rack 的  <code>request.ip</code> 写的，比如黑名单工具 Rack Attack，所以并不能帮我们节省配置。</p><p>所以你还要再配置一遍 Rails 才行。</p><p>在  <code>config/application.rb</code>  下执行如下代码：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">proxies = [] <span class="comment"># proxies 这个参数接受多种形式的参数，详见 http://api.rubyonrails.org/classes/ActionDispatch/RemoteIp.html</span></span><br><span class="line"></span><br><span class="line">config.middleware.swap ActionDispatch::RemoteIp, ActionDispatch::RemoteIp, <span class="literal">true</span>, proxies</span><br></pre></td></tr></table></figure><p>解决！</p><p><strong>注：示例使用的是 Rails 5 的代码，Rails 3 和 4 的配置代码甚至还不一样🤦‍♀️</strong></p><p>旧版本详见 <a href="https://github.com/rails/rails/issues/5223" target="_blank" rel="noopener">Issue#5223</a> 这个被反复打开的 Issue。</p><h2 id="结"><a href="#结" class="headerlink" title="结"></a>结</h2><p>这是一个很不容易遇到的场景，但一旦遇到又很容易被忽视，忽视后有可能产生很大的麻烦。而且说实话，平时哪怕读 Rack 和 Rails 的源代码也想不到会有这种场景。了解后各位 Ruby 开发者在平时开发中多注意一下吧！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;引&quot;&gt;&lt;a href=&quot;#引&quot; class=&quot;headerlink&quot; title=&quot;引&quot;&gt;&lt;/a&gt;引&lt;/h2&gt;&lt;p&gt;由于最近论坛发生了某些讨论，出现了一个恶意攻击的账号。然而去查用户 IP 时，却发现没有拿到用户的 IP。这个问题非常诡异，几经排查，终于发现了问题
      
    
    </summary>
    
    
      <category term="编程" scheme="https://coderemixer.com/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="Ruby" scheme="https://coderemixer.com/tags/Ruby/"/>
    
  </entry>
  
  <entry>
    <title>程序员必看！中秋前后绝对不能做的 0x08 件事</title>
    <link href="https://coderemixer.com/2017/08/31/mid-autumn-2017/"/>
    <id>https://coderemixer.com/2017/08/31/mid-autumn-2017/</id>
    <published>2017-08-31T13:08:22.000Z</published>
    <updated>2018-10-21T13:09:46.240Z</updated>
    
    <content type="html"><![CDATA[<ul><li><p>0x00. 开发中秋活动相关页面（时间太急，可能有 BUG）</p></li><li><p>0x01. 开发与现实货币直接相关的比如电商、抢购业务（后果严重，容易在假期前后被攻击）</p></li><li><p>0x02. 匿名表达对老员工，特别是对彭姓员工不满（大老板可能含沙射影地让你滚）</p></li><li><p>0x03. 草率入职某开曼群岛注册公司的北京分公司（公司可能不会帮你办暂住证）</p></li><li><p>0x04. 开发公司 HR 工具的离职谈话功能（会说是你的问题）</p></li><li><p>0x05. 截图公司内网论坛（网站可能有数字水印）</p></li><li><p>0x06. 公开打包票没问题，否则赔你十万（可能会破产）</p></li><li><p>0x07. 用脚本在公司网站抢月饼（可能违反价值观）</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;&lt;p&gt;0x00. 开发中秋活动相关页面（时间太急，可能有 BUG）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;0x01. 开发与现实货币直接相关的比如电商、抢购业务（后果严重，容易在假期前后被攻击）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;0x02. 匿名表达对老员工，特别是
      
    
    </summary>
    
    
      <category term="阿里巴巴" scheme="https://coderemixer.com/tags/%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B4/"/>
    
  </entry>
  
  <entry>
    <title>如何读文档？</title>
    <link href="https://coderemixer.com/2017/07/16/how-to-read-the-fxxking-manual/"/>
    <id>https://coderemixer.com/2017/07/16/how-to-read-the-fxxking-manual/</id>
    <published>2017-07-16T12:57:12.000Z</published>
    <updated>2018-10-21T12:58:30.695Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>今天收到一份微博私信，问我之前 <a href="/2017/05/22/mass-produced-engineers/">量产型炮灰工程师</a> 中说一个良性的学习循环需要自己寻找线上资源学习、读文档等等，这些都没有在培训班中被学到。那怎样才能比较好的读文档呢？不分享一下的话，老说我是光破不立，光批评别人自己却没有任何解决。那么我来分享一下我读文档的思路吧。</p><h2 id="大局入手"><a href="#大局入手" class="headerlink" title="大局入手"></a>大局入手</h2><p>首先，这里的读文档并不局限于接口文档，接口文档更像是工具书，这里的文档泛指围绕代码周边的文字说明。你要学习一门语言、框架或者某个工具，肯定不是因为它是一个工具所以你就学。框架的开发者也不会是因为想写一个框架所以就写一个框架。凡事都一定有它的理由，一个语言、框架、工具的存在一定是为了解决某一个或某一类特定的问题而存在的。同一个类型的不同的语言、框架、工具之所以会不同，是因为他们试图在解决不同的问题，或者某个工具正在解决另一个不能解决的某种问题。这时候作者的想法是尤为重要的，如果弄清楚这方面想法对于你的学习自然是事半功倍的。</p><p>作者的想法在哪里？</p><p>在官方的教程、官方的概述里。对于 Ruby 来说，其官网的<a href="https://www.ruby-lang.org/zh_cn/about/" target="_blank" rel="noopener">关于页</a>短短一页就几乎解释了什么是 Ruby，Ruby 和其他语言的不同：</p><ul><li>Ruby 从多门语言中学习了经验，注重其平衡性</li><li>兼具函数式编程和命令式编程特色</li><li>Ruby 试着让语言更自然，而不是更简单</li><li>Ruby 将一切视为对象</li><li>Ruby 允许用户修改语言自身</li><li>Ruby 的闭包具有极强表现力</li><li>Ruby 对象只提供单继承，但支持混入</li><li>Ruby 的变量系统</li><li>Ruby 的其他细节</li></ul><p>有了这些大纲，这对于你理解 Ruby 中的很多表现就有了很大的认识。接着再去看 Ruby User’s Guide 或者 Programming Ruby 就会有很大的帮助。</p><h2 id="了解变化"><a href="#了解变化" class="headerlink" title="了解变化"></a>了解变化</h2><p>在学习了一个东西的大纲和入门教程之后，大版本的更新记录是文档中非常重要，却是最容易被忽略的部分。</p><p>比如 Qt 在 4.8 版本中引入了 QML。我相信很多公司都号称使用 Qt 做跨平台界面开发，却很少注意 Qt 本身的变化。很多公司 Qt 5 的代码写得和 Qt 3 也没有什么区别。QML 的引入对于界面的绘制，事件的绑定和数据的刷新提供了一整套 DSL，从而让整个开发变得容易和可读太多。大版本的更新记录很重要是因为之所以会有版本更新一定是因为之前写的不好，需要改进。如果只是从细节入手看接口，旧接口通常会为了兼容性而保留，这时候并不能宏观地知道作者想让你怎么用。</p><p>比如 Ruby 在 2.3.0 中引入了 Safe Navigation Operator <code>&amp;.</code>，其类似于 C# 中的 <code>?.</code>。Ruby 的 ActiveSupport 库中本来其实有类似的语法，它是 <code>Object#try</code>。但 Ruby 作者将这个东西从一个语义层面提升到了一个语法层面，体现了作者在这方面的重视。这是 Ruby 所说的 <code>注重其平衡性</code> 的一种体现。当你了解了作者的这种想法，你才能写出更好的代码，显然 Ruby 作者对 Ruby 的理解是相当深刻的。</p><p>再比如 HTML5 中引入了 WebSocket API，显然就是来解决 Web 双工实时通讯的问题的。如果放着这样的 API 不用，还在使用轮询，甚至在浏览器上做一些 tricks 来实现更长的连接，不但是浪费资源，更是浪费自己的精力。</p><h2 id="实践与细节"><a href="#实践与细节" class="headerlink" title="实践与细节"></a>实践与细节</h2><p>了解了框架的设计思路，了解了基本的使用方法，接下来才可以看接口文档。这时候你已经有了对框架的基本理解，你就知道自己需要看什么。可以结合一个自己要做的项目边写边看。需要用到什么具体的模块，就去查这个模块的所有 API。这通常查询起来会比较方便。当然光看 API 文档只是对框架的使用，还是不够的。一个好的项目不只是使用的优雅，更是管理的艺术。项目要管理得好更需要对项目做正确的抽象，这时候再去多看看这个框架的一些好的项目的开源实现，学习一下。之后就对整个框架不仅仅是熟悉使用了，更是有了大局上的认知，使用起来比单纯熟悉语法要好很多。</p><p>看别人的代码的思路其实和看文档是一样的，不要从细节入手，只会让自己「乱花渐欲迷人眼」。从大局入手，了解作者的实现思路，然后找出实现的最主要的抽象的部分，再慢慢去啃细节的实现自然会比一行一行读容易许多。</p><h2 id="最重要的是"><a href="#最重要的是" class="headerlink" title="最重要的是"></a>最重要的是</h2><p>写代码不是默写，没有人不让你边写边搜边找。读文档的关键是要在出了问题后知道自己要找什么，去哪里找。学习不是闭门造车，要多培养自学的能力，是为了让自己在脱离别人的教学之后知道自己怎么学，去哪里学。计算机软件行业是一个快速更迭的行业，只有让自己始终在学习，才能不至于在这个行业中落后。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;今天收到一份微博私信，问我之前 &lt;a href=&quot;/2017/05/22/mass-produced-engineers/&quot;&gt;量产型炮灰工程
      
    
    </summary>
    
    
      <category term="编程" scheme="https://coderemixer.com/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="Ruby" scheme="https://coderemixer.com/tags/Ruby/"/>
    
  </entry>
  
  <entry>
    <title>量产型炮灰工程师</title>
    <link href="https://coderemixer.com/2017/05/22/mass-produced-engineers/"/>
    <id>https://coderemixer.com/2017/05/22/mass-produced-engineers/</id>
    <published>2017-05-22T08:03:10.000Z</published>
    <updated>2018-10-21T12:32:43.475Z</updated>
    
    <content type="html"><![CDATA[<h2 id="在吗"><a href="#在吗" class="headerlink" title="在吗"></a>在吗</h2><p>写这篇文章之前我的顾虑非常多，因为它很得罪人而我却捞不到一点好处。但反过来说我写这篇文章并不是针对说「达○」这样的培训机构，或者「李○○」老师的一些言论，也不是针对说 Ruby China 上最新一些类似的培训帖。<del>我是说在座的，都是○○。</del></p><p>我要针对的甚至都不是培训行业，反过来，我认为对于整个软件行业而言，培训整件事情就不靠谱。这不是说我心血来潮，我想诸位的公司只要不是沙丁鱼罐头类型的外包公司，对于培训这件事本身都多少抵触。至于高端的培训班，我想你们也有自己的看法，只是有时候不方便说出来。但我最近了解了一些底层劳苦人民悲惨的事实，使我实在看不下去，只能出来批判一番了。</p><h2 id="丢人玩意，退群吧"><a href="#丢人玩意，退群吧" class="headerlink" title="丢人玩意，退群吧"></a>丢人玩意，退群吧</h2><p>我们先抛开培训班的问题，我们先来讨论一个经典的面试题，它叫做「FizzBuzz」。输出数字 1-100，逢 3 的整倍数输出 Fizz，逢 5 的整倍数输出 Buzz，又是 3 又是 5 的整倍数输出 FizzBuzz。那么稍有常识的人都知道，无论你学习什么语言，学的水平有多糟糕，这道题都很容易实现。但我们来看一下最常见的一些错误是怎么出现的：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">1</span>..<span class="number">100</span></span><br><span class="line">  <span class="keyword">if</span> i / <span class="number">3</span> == <span class="comment"># 写不下去了</span></span><br></pre></td></tr></table></figure><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">1</span>..<span class="number">100</span></span><br><span class="line">  <span class="keyword">if</span> i % <span class="number">3</span> == <span class="number">0</span></span><br><span class="line">    puts <span class="string">'Fizz'</span></span><br><span class="line">  <span class="keyword">elsif</span> i % <span class="number">5</span> == <span class="number">0</span></span><br><span class="line">    puts <span class="string">'Buzz'</span></span><br><span class="line">  <span class="keyword">elsif</span> i % <span class="number">15</span> <span class="comment"># 写不下去了...</span></span><br></pre></td></tr></table></figure><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">1</span>..<span class="number">100</span></span><br><span class="line">  <span class="keyword">if</span> i % <span class="number">3</span> == <span class="number">0</span></span><br><span class="line">    puts <span class="string">'Fizz'</span></span><br><span class="line">  <span class="keyword">elsif</span> i % <span class="number">5</span> == <span class="number">0</span></span><br><span class="line">    puts <span class="string">'Buzz'</span></span><br><span class="line">  <span class="keyword">elsif</span> i % <span class="number">15</span> == <span class="number">0</span></span><br><span class="line">    puts <span class="string">'FizzBuzz'</span></span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    puts i</span><br><span class="line">  <span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>很多培训班会告诉你这些算法的基础知识毫不重要，但事实上严格来说这都算不上是一道算法题，这没有任何已有的算法模板来解决，这只是一个最简单的循环和条件分支语句，有超过 9 成的开发者没法正确写对这道题。我认为，这些人压根就不该也不适合来写代码。</p><p>令人惊讶的是，这些人并非不能写业务逻辑，比如说让他们写个 CRUD，他们甚至不比你写得慢。但它们的问题在于连理解文字、理解需求的基本能力都不具备。当你说「整倍数」的时候他们无法想到用余数，当你先提到 3 和 5 的整倍数时，他们无法想到 15 应该放在他们两个之前判断。</p><p>对程序最基本的逻辑的考察没有通过，并不代表他们无法进行日常的开发，就好像数学应用题不会做也不一定会挂科一样。他们通常会写出非常糟糕的抽象，常见的例如在一个社交网络里给每种类型的 UGC 内容单独建表，然后再为每种类型单独建回复和点赞的表；将用户重置密码和管理员重置密码完全拆成两个方法来实现；无法正确判断自己方法在边界条件下的情况等等。</p><p>培训班对于培训这样的程序员来说是容易的，而且市场上需要这些程序员。各位可能很难相信，今天的互联网应用大多都没有什么鲁棒性可言，市面上至少一半的产品都存在高危的漏洞只不过是没有人想要攻击他们而已。市场需要这些能用的垃圾来建一个原型、骗一笔投资或者交付一笔外包。</p><p>培训班能教你的归根结底解决的问题是「如何使用一个工具」，而不是「解决问题的方法」。然而在使用工具这件事上，你无论如何都无法描述清所有的场景，就好像你在通过人为地输入一些逻辑，来让汽车学会自动驾驶一样是不完整的。然而在这层嘴脸上，无论是低端的还是所谓的高端的培训班都会用一种方式来糊弄过去，那就是「老师教给你的东西是有限的，更重要的是，你从老师这学到了代码的基本方法，你要上进才能更好学习」。但我们平心而论，老师真的教你们代码的基本方法了吗？他带着你们去学习如何阅读官方文档了？还是教你们程序背后的基本原理了？都没有，他明明在教你语法和一些非常弱智的场景。「解决问题的方法」是学不来的，是你大量日常的工作积累的，所以什么号称两个月掌握别人两年知识的都是骗子，你以为人家两年都在那里划水呢？你以为你两个月真能干出来什么吗？</p><p><strong>承认吧，如果有人真的写好了代码，就算他没报班，自学也不会比现在差。</strong></p><h2 id="暗示了，明抢了"><a href="#暗示了，明抢了" class="headerlink" title="暗示了，明抢了"></a>暗示了，明抢了</h2><p>我觉得从某种角度来说所谓低端的培训班和高端的培训班都是一丘之貉，都在宣传时给你过高的期望，而毕业后这个期望永远是落空的。低端的培训班告诉你培训后你们就可以月入上万的工程师，主要面向的是二线和是三线城市学业失败的人。毕业后通常需要通过伪造简历才能进入一家沙丁鱼罐头外包公司，拿着三四千的薪水，成天干着重复而无用的最底层的编码工作。</p><p>而高端的培训班则面对一线城市的中产阶级，宣传时让他们认为通过培训后他们能大大改善现在的生活，甚至利用自己的技术成为创业公司的 CTO，成为自己财务自由的垫脚石。然而毕业后他们能找到的工作也不过如此，根本没有脱离他们中产阶级的生活。</p><p>如果单单是这样，我其实并不会写今天这篇文章，因为他们至少是无害的。但事实上，低端的培训班通常伴随贷款出现，可以先上课后付款，学员因此被卖身；而高端培训班高昂的学费常常消耗掉一个中产家庭的全部积蓄，使其最少的财富积累化为乌有。可以说，培训班是坐庄稳赚，而学员们在培训后大多都变得更拮据和悲惨。这种资本驱动下的套路，就和卖老年保健品的那些灰色产业一样灰色。他们通过给你看到一个事物的片面使你盲信，从而满足了他们自己的利益。</p><p><strong>放弃吧，如果你没有能力自学，培训班根本帮不了你。</strong></p><h2 id="黑暗剑，不存在的"><a href="#黑暗剑，不存在的" class="headerlink" title="黑暗剑，不存在的"></a>黑暗剑，不存在的</h2><p>如果反过来回忆一下我们自己学习代码的历程，你会发现都是类似的，是螺旋上升的，是循序渐进的。你是从先会一些最简单的逻辑，到开始写一些能用但不好的代码，慢慢自己通过阅读文档、阅读别人的源码来慢慢提升。如果你一上来就来看 Rails 的实现，你肯定根本看不懂嘛。你对于一项技术的理解，也一定是先认为这是黑盒，这是魔法，再到了解其技术细节，最后和人说这东西其实很简单。</p><p>我相信不少 Ruby 程序员都是从 Java 程序员过来的，对于这些程序员来说，他们很容易理解 Ruby 的面向对象的机制，但对于开类和模块注入的一些方法却觉得很魔法。而如果你是从一门 FP 语言过来的程序员，比如说 Lisp，那你会对 Ruby 的 Block 机制感到很亲切，对于开类和注入觉得很容易理解。相反对于一些面向对象的一些手段感到不是很熟练。</p><p>这些都是人类「迁移学习」的能力，你将已知的东西来做类比从而理解新的未知的技术。全栈工程师之所以成为全栈工程师，是因为他一开始精通一部分，随着不断学习新技术，不断将已知的迁移上去，从而对技术栈拥有非常全面的大局的认识。然而一些培训班甚至能号称自己能培训「全栈工程师」，你连基础都没有，就相当于同时学习操作十台机器，你想想那可能吗？所以出来的那个不叫全栈工程师，那个叫全栈 Hello World 工程师。你可以在简历上写上：精通各种语言 Hello World 写法、掌握各种数据库的安装、熟练各种操作系统开机。你其实什么都不会。</p><p>写代码一方面需要灵性，需要实践经验的积累，另一方面需要打好基础。这些东西本应该是由本科教育提供给你的，但不得不说国内大多数大学的本科教育也没有提供合适的基础教育，而培训班在拮据的时间内也不可能教你这些基础教育的部分。举例来说，如何计算一段程序的时间复杂度、空间复杂度，如何理解栈、队列等数据结构，了解网络协议的基础。这些东西就像是 RTS 或者 MOBA 游戏的经济一样，当前的经济并不会直接影响到当前的局势，但发展一段时间之后，特别是后期和大后期就会立刻成为你的局限之处。如果你连时间复杂度都不会算，你怎么知道两段程序谁的性能更好，又是甚至性能差到根本不能工作的时候你又去求助谁。</p><p><strong>醒醒吧，写代码没有捷径，如果你希望在这条路上继续走下去，你必须打好基础，不断学习新的知识才有可能。</strong></p><h2 id="RUA"><a href="#RUA" class="headerlink" title="RUA"></a>RUA</h2><p>有位大佬曾告诫我，如果不是触及到自己的利益，那么就不要去断别人的财路。但也就是这样，业界和学界都充斥着一股药丸的气息。所有人做教育都是想着帮你卖出去，而你自己学习的目的也是把自己卖出去。所以大学连「SICP」都不上了，培训班才越来越猖狂；所以越来越多的人相信基础知识无用，认为存在让自己成功的捷径；所以加班昏天黑，干不到 35 岁就被退休了；所以发的 paper 申请的专利都是为了完成指标；所以学术上造假，商业上抄袭，技术上停滞；所以你只有跑不起来的代码，快不起来的程序，加不上的薪资<del>，届不到的恋</del>。</p><p>与其说这些培训机构在骗你，不如说是你贪小便宜的心态正中了这些培训机构的计。</p><p><strong>愿世界少一些套路。</strong></p><h2 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h2><p>在此篇文章发出后的几个小时内，我的微信上已收到了 9 篇不同公司对于某价格不菲的 Ruby 培训营的吐槽，内容竟还高度重合。现整理如下：</p><ol><li>连 SQL 是什么都不知道</li><li>不知道什么是 <code>group_by</code> 和 <code>count</code></li><li>MVP 模式的 CRUD 写得很熟练</li><li>面试面到无话可问</li><li>写一个简单的循环都写不出，并称是该届优秀的学生</li><li>已加入该公司面试的黑名单</li><li>在未经允许的情况下，将录取学员的公司的 Logo 挂至其官网进行宣传</li><li>给一个月时间写一个最简单的 Rack 中间件，最后回复不会写</li></ol><p>虽然此贴不是针对这个培训营，但这个营确实是在收智商税，并且暴露出来的问题还是很明显的。很多人报名的时候考虑到这个营是李○○办的，老师是 xd○○○。便认为这些背书可以成为帮助他们找到好工作的捷径。然而事实上这些背书确实起了作用，在第一批学员刚毕业的时候，社区里大多数的公司都抱着非常友好和鼓励的态度欢迎他们。但是随着时间的发展，大家越发认识到这些毕业生基础知识薄弱、学习能力低下的特点，哪怕一些已录取的员工也被转岗，开始出现了不少牢骚，对于这个营毕业的学生开始抵触。可见也就是这些人自己已经彻底毁掉了这个背书本身的价值了。</p><p>评论里还有反应这个营在培训时曾主张通过不断练习形成「肌肉记忆」。我从未在编程这件事上听说过这种词，如果说一件事情是「重复性」的，那当然就把它封装抽想起来，或者注入进脚手架，哪里有形成「肌肉记忆」这种说法。而这种错误的训练方式也解释了上述企业对于这些人的印象。</p><p>当然也不少人质疑说，光骂培训班，那受过高等教育毕业的学生技术就一定好了吗？当然也不是这样的，事实上我国大多数高等学府的计算机教育也是无用的，甚至是有害的。中国大学在多次扩招后，除了少数几个学校，专业教育的大部分也不靠谱。许多学校安排了四年的课程，确实涉及了不少基础知识，但结果却本末倒置，觉得学生听不懂课上得简单，学生也没有好好学好。我甚至见到过某 985 学校算法课期末考默写，因为好好考试会有太多人挂科。我也很难相信这种专业毕业的学生究竟是在给行业输送人才还是压力。</p><p><strong>希望所有在这行业里奋斗的同学们能沉下心多钻研，不要相信有所谓的捷径。</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;在吗&quot;&gt;&lt;a href=&quot;#在吗&quot; class=&quot;headerlink&quot; title=&quot;在吗&quot;&gt;&lt;/a&gt;在吗&lt;/h2&gt;&lt;p&gt;写这篇文章之前我的顾虑非常多，因为它很得罪人而我却捞不到一点好处。但反过来说我写这篇文章并不是针对说「达○」这样的培训机构，或者「李○○」老
      
    
    </summary>
    
    
      <category term="编程" scheme="https://coderemixer.com/tags/%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>口吐 bug</title>
    <link href="https://coderemixer.com/2017/05/17/spit-bugs/"/>
    <id>https://coderemixer.com/2017/05/17/spit-bugs/</id>
    <published>2017-05-17T13:10:50.000Z</published>
    <updated>2018-10-21T13:14:17.507Z</updated>
    
    <content type="html"><![CDATA[<p>甲：我们借这个机会给大家拜个早年。</p><p>乙：你等等吧你（拉扯状</p><p>甲：怎么了？</p><p>乙：没听说过。现在这五月份，前不着村后不着店的怎么拜早年了？</p><p>甲：这还用我说？</p><p>乙：嚯？</p><p>甲：这专栏说好月更的，你看看上回发是啥时候了？</p><p>乙：别。我们同台说个相声怎么还扯到专栏呢？别跳戏行不？</p><p>甲：这不叫跳戏，你告诉我，这专栏主要讲啥的？</p><p>乙：元编程？</p><p>甲：可不是，我们讲的不就是元相声嘛，相声演员当然得觉醒自己在讲相声的意识。</p><p>乙：还元相声呢。</p><p>甲：可不是嘛，我们元相声演员讲究五门功课。</p><p>乙：说学逗唱。诶不对，相声啥时候五门功课了？</p><p>甲：还有一门魔法，这是我们元相声演员也要掌握的。</p><p>乙：「时间都去哪儿了，还没好好写好代码就老了」</p><p>甲：怎么还突然唱起来了？</p><p>乙：这不是你说的魔法吗？</p><p>甲：不是这个魔法。</p><p>乙：啊，那还是哪个魔法？</p><p>甲：这你也好意思开元编程专栏，连魔法都不会？</p><p>乙：哦是元编程的魔法。</p><p>甲：可不是嘛，写起元编程来都是魔法。</p><p>乙：不对啊，那元相声和这个魔法有什么关系？</p><p>甲：说到这个元相声啊，来源于程序员工作时的一个传统。</p><p>乙：穿女装？</p><p>甲：穿女装是怎么回事啊。虽然这个也是传统，但元相声是来源于「代码评审」</p><p>乙：啊，code review。</p><p>甲：可不是嘛，code review 的时候程序员互相讨论，慢慢就形成了一门曲艺，那就是元相声。</p><p>乙：哇，这可是个新谱系啊。</p><p>甲：没错，和什么传统三大家可不一样，独成一派，师承谭浩强，我们元相声</p><p>乙：喂喂喂，师承谭浩强？</p><p>甲：怎么了？</p><p>乙：谭浩强来说过相声？</p><p>甲：不是，谭浩强虽然没说过相声，但其漏洞百出的教材为程序员贡献了无数的笑料，成为了元相声的鼻祖。</p><p>乙：Wat?</p><p>甲：虽然元相声还是个新门派，但为了能传承下去，我们还是动了不少脑经。</p><p>乙：哦？怎么还传承了？刚成立就遇到传承难题了？</p><p>甲：唉，大环境如此啊，老板最近都让我别说什么元相声了，去当偶像，几个程序员成立个女团。</p><p>乙：哇，我看还是这个靠谱点。</p><p>甲：但我不乐意啊，为了有更多人听到和了解元相声，我最近在写一本专著。</p><p>乙：我猜猜，Ruby 元相声？</p><p>甲：不是。</p><p>乙：Learn You a Meta-Crosstalk for Greak Good?</p><p>甲：不，我这咋还写英文书了呢？</p><p>乙：那是啥？</p><p>甲：「笠翁对韵」。这个「天对地，雨对风。大陆对长空。山花对海树，赤日对苍穹。」</p><p>乙：你给我等等。「笠翁对韵」是明末李渔写的对对子的书，关你们元相声什么事啊？</p><p>甲：当然关我们事，别看这字写得一样，读得一样，意思可大不一样。</p><p>乙：写得一样，读得一样，意思还能不一样？</p><p>甲：可不是嘛。而且我们这对子学了是很有实际意义的，是我们元相声演员做魔法对决的时候用的。</p><p>乙：这还魔法对决呢，咋不去霍格沃兹呢？那你给我解释一下，「天对地，雨对风」有个什么不一样？</p><p>甲：啊，这个「天」，可不是一般的天。</p><p>乙：这不是天还能是啥，难不成是「天空下载站」啊，那下面也该接「华军软件园」啊。</p><p>甲：这什么跟什么啊。这个天，是「天网」的天。</p><p>乙：我勒个去，这天可够科幻的啊。</p><p>甲：可不是嘛，这个地，就是「地三鲜」的地。</p><p>乙：扑通（没站稳）你这对的是个什么对啊。字数不对，意思也对不上啊。你这是哪家东北菜馆的防不胜防啊。</p><p>甲：不是，凑得上，这说的是程序员们做着「天网」那么复杂的工作，工资只够吃「地三鲜」的。</p><p>乙：啊，这还是个揭露资本主义阴暗面的对子。</p><p>甲：诶，资本主义国家的公司没一个好东西。你看我们垠神，写得一手好代码，被微软气得签了不平等条约。</p><p>乙：怎么还突然垠神了呢。</p><p>甲：那秘密离职协议签得也是够微软的。</p><p>乙：诶？停停停。你这不是「笠翁对韵」，怎么弄到微软身上去了。</p><p>甲：这就是我们元相声的特色。</p><p>乙：你这特色我可不承认。</p><p>甲：也难怪，你们这些麻瓜也听不懂我们这种魔法。</p><p>乙：嚯，还真当自己霍格沃兹毕业呢。我看你少挂着元相声的名义招摇撞骗了，还不如穿女装来得靠谱呢。</p><p>甲：别不承认，我的能力是受到认证的。</p><p>乙：谁给你颁的清真认证啊？</p><p>甲：什么清真认证啊，我的魔法能力是受到认证的。</p><p>乙：谁给你认证的？</p><p>甲：Jeff Dean</p><p>乙：谷歌那个大牛？</p><p>甲：没错。</p><p>乙：我看这要是真的，那是佩奇听了会骂娘，布林听了想打人还差不多。</p><p>甲：你这怎么说话的啊？</p><p>乙：什么怎么说话，就你这样，Jeff Dean 给你认证？还是认证什么魔法能力？</p><p>甲：你懂什么？Jeff Dean 那么牛你知道为什么吗？</p><p>乙：人家天资聪明勤学努力，代码思路清晰做事认真，还能怎样？</p><p>甲：屁，Jeff Dean 代码写得那么牛都是我的功劳？</p><p>乙：哈，这还能是你的功劳？</p><p>甲：我给 Dean 先生施法术了，所以人家代码没问题。</p><p>乙：唷？还法术呢？难不成啥法术还可以去除 bug？</p><p>甲：有，「口吐莲花」</p><p>乙：口吐莲花？</p><p>甲：没错，倒过一杯水来，我一念咒一吐，喷出个水球。这水球到半空中悬空一开，变朵莲花，莲花当间站个臭虫。</p><p>乙：臭虫？</p><p>甲：对，就这臭虫把你电脑程序里的 bug 全给吸出来了。冲台下三鞠躬，表示祝君晚安。鞠完躬，落在平地上，还是那点儿水。</p><p>乙：哇，这可了不得，那你咋就给 Jeff Dean 施法了呢？</p><p>甲：这不是你们不赏识我吗？人家 Jeff 赏识我。</p><p>乙：那。。。那您也请变个给我看看，我也想从此不出 bug 啊。</p><p>甲：喜欢看，您得帮我个忙。</p><p>乙：帮个啥忙？</p><p>甲：魔法少不了打锣的，您得给我借个锣。</p><p>乙：这戏法少不了打锣的，你魔法怎么也要打锣啊？</p><p>甲：没锣可变不了。</p><p>乙：你们这魔法师讲究的，借锣可没地方。</p><p>甲：找个代替的。</p><p>乙：拿什么代替啊？</p><p>甲：脑袋当锣，拿扇子一打您这脑袋就算打锣了。我念几句咒，就是锣套子溜口辙，这可不为念咒，就为用我这念回头我好变。</p><p>乙：您念吧。</p><p>甲：听我念咒，一二三，二三三。变不了。</p><p>乙：怎么变不了？</p><p>甲：这锣不响。</p><p>乙：是呀！这脑袋是肉的，怎么能响呀？</p><p>甲：可以用你那嘴发音，我这儿打两下子，您那儿就：“tuang! tuang! ”</p><p>乙：可以。</p><p>甲：一二三，二二三。</p><p>乙：tuang! tuang!</p><p>甲：不行太慢，快着点。</p><p>乙：行了，tuang! tuang!</p><p>甲：我还没打怎么就响了？</p><p>甲：锤到锣鸣！</p><p>乙：你早说不就是了。知道了知道了。</p><p>甲：一二三，二二三。</p><p>乙：tuang! tuang!</p><p>甲：跟随师父上茅山。(tuang! tuang!) 茅山有个图老道。</p><p>乙：诶，打住。图老道是谁啊？</p><p>甲：我师父，计算机科学开山鼻祖之一，英国数学家阿兰·图灵。</p><p>乙：你也知道阿兰图灵是英国人啊。</p><p>甲：怎么？</p><p>乙：英国人还老道？当时英国可是以基督教圣公会作为国教的啊。</p><p>甲：这不是嘛，图灵所以就被迫害死了么。</p><p>乙：啊？这怎么和我听到的版本不太一样啊。</p><p>甲：可以了，你还有没有点文化自信啊。</p><p>乙：行行行行行。</p><p>甲：一请天地动，二请鬼神惊。三请图老道，四请孙伯灵。五请拜伦女，六请方某某。</p><p>乙：停停停，你请谁啊这是？拜伦女是谁啊？</p><p>甲：拜伦女就是英国诗人拜伦的女儿爱达啊，世界上第一名计算机程序员。</p><p>乙：她也是神仙？</p><p>甲：这要防止 bug 你就要请一些应景的神仙啊。</p><p>乙：那方某某是谁啊，怎么还某某了？</p><p>甲：这是加固保险，我给你把 bug 吸出来，再让他给你弄个墙防护一下，他可是专家，只是这大师隐居，名字不让说。</p><p>乙：哦，是那个专家啊。</p><p>甲：诶。五请拜伦女，六请方某某。七请谭浩强，八请陈梓瀚。</p><p>乙：喂！</p><p>甲：怎么了？</p><p>乙：这谭浩强写的满书 bug 你也请来？</p><p>甲：啊这你不懂，谭浩强写那么多 bug，写得书也卖得出去这说明什么？</p><p>乙：这说明中国高校计算机教育水平差？</p><p>甲：有你这么说话的吗？</p><p>乙：不，这还能说明什么啊？</p><p>甲：这说明人家谭浩强身上有仙气！</p><p>乙：哈，是这么个道理。那那请人家陈梓瀚轮子哥来干嘛？</p><p>甲：这不是你写代码没 bug 了，空余时间就多了，没事你可以逛逛知乎，让轮子哥带你嘛？</p><p>乙：犯不着。</p><p>甲：啊，不用啊。</p><p>乙：我关注的女装话题有趣多了。</p><p>甲：噫！</p><p>乙：行行行，你接着变吧。</p><p>甲：七请谭浩强，八请陈梓瀚。早请早到，晚请晚到，如若不到，铜锣相叫。接神接仙，八抬大轿。净水泼街，黄土垫道。拾头一看，神仙来到哇，哇……</p><p>乙：先生，您倒是喷啊！</p><p>甲：噗！（滋一脸）</p><p>乙：瞎！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;甲：我们借这个机会给大家拜个早年。&lt;/p&gt;
&lt;p&gt;乙：你等等吧你（拉扯状&lt;/p&gt;
&lt;p&gt;甲：怎么了？&lt;/p&gt;
&lt;p&gt;乙：没听说过。现在这五月份，前不着村后不着店的怎么拜早年了？&lt;/p&gt;
&lt;p&gt;甲：这还用我说？&lt;/p&gt;
&lt;p&gt;乙：嚯？&lt;/p&gt;
&lt;p&gt;甲：这专栏说好月更的，你看
      
    
    </summary>
    
    
      <category term="瞎扯蛋" scheme="https://coderemixer.com/tags/%E7%9E%8E%E6%89%AF%E8%9B%8B/"/>
    
      <category term="相声" scheme="https://coderemixer.com/tags/%E7%9B%B8%E5%A3%B0/"/>
    
  </entry>
  
  <entry>
    <title>花了半个月捡垃圾</title>
    <link href="https://coderemixer.com/2017/02/14/build-up-x79-workstation/"/>
    <id>https://coderemixer.com/2017/02/14/build-up-x79-workstation/</id>
    <published>2017-02-14T12:51:58.000Z</published>
    <updated>2018-10-21T12:53:50.389Z</updated>
    
    <content type="html"><![CDATA[<h2 id="引"><a href="#引" class="headerlink" title="引"></a>引</h2><p>这半个月开源项目拖更，啥事没干成，主要要感谢我的 MacBook Pro。大年二十五，风扇异响；大年二十六，更换风扇；大年二十七，更换风扇后无法通过屏幕自检；大年二十九，更换主板；正月十二，主板短路，浓郁的线路烧焦的气味从风扇口传出；正月十三，机器第五次返厂维修，问题分类「安全性第一问题」，维修后需要返售前检测，预计需要到周四才能修好。这一下子家里一台能用的机器都没有。除了安装着 Windows 的一台机器，还有一台是 NAS，唯一装着 Linux 的是一台软路由。于是决定捡垃圾捡台新机器来写代码。</p><h2 id="捡垃圾思路"><a href="#捡垃圾思路" class="headerlink" title="捡垃圾思路"></a>捡垃圾思路</h2><ul><li>Q: 为什么是捡垃圾？</li><li>A: 因为是备机，不想花太多钱。穷。</li><li>Q: 从哪里捡？</li><li>A: 本来打算从闲鱼捡，后来想想闲鱼二手可靠性太差，最后还是打算主要零件从淘宝捡，一些配件从京东捡。</li><li>Q: 需要满足的需求？</li><li>A: 完美的日常编码和跑机器学习。</li></ul><p>主要是最近写了点卷积神经网络，放 CPU 上跑实在太慢。一开始试图接了个 GTX970，然后我这个数据预处理又太慢，最好能搞个核心数足够多的机器，这样才能爽。</p><p>一说到核心数多，第一反应就是二手服务器。1800 元收了个 IBM 的二手服务器，一代志强 E5645 双路，64GB 内存，2 块 SATA 的 1TB 机械硬盘。本来想把机器拆了，改装到家用主机上。因为服务器风墙实在太吵，实测 70db 噪音，受不了。</p><ul><li>Q: 为什么服务器二手那么便宜？</li><li>A: 很多服务器都是过了保修期就白菜价卖出来的，比如我手上的机器是百度卖出来的，开机自检还有百度 Logo。服务器的内存由于是 ecc 的，和 PC 内存不通用，更是便宜，这半个月翻遍淘宝，ddr3 reg ecc 内存的底价大约是 28 元 4GB，90 元 8GB。</li></ul><h2 id="改装机箱"><a href="#改装机箱" class="headerlink" title="改装机箱"></a>改装机箱</h2><p>结果 IBM 机器一拆，定制的主板规格，没有机箱能塞得下，只能另寻它路，最后买了块泰安 S7012 主板，这板子比英特尔的公版还好用，内存插槽 18 个，5 条 pci-e x8。英特尔的公版为了能让你差显卡，弄了个 x16 孔位的 x8，而这块主板更暴力，直接 x8 尾部不封死，想插几块 x16 随便你。说着也有意思，德州仪器不是山东的是美国的；泰安电脑是台湾的也不是山东的。这个山东地名真是风水好，建议硬件创业者可以观望注册。</p><p>京东上买了个先马坦克机箱打算装机，因为听说这机器拆掉了硬盘位正好能塞下 EEB-ATX 规格的主板。谁知道拿到货发现上当了，EEB-ATX 铜柱的孔位确实留了出来，但是孔位没有攻丝，据说早先批次的机箱是有攻丝的，新批次的机箱取消了。而我没有丝锥，这下就麻烦了。于是去楼下五金店要了个自攻螺丝，拧进去拔出来，然后把铜柱再拧进去，解决。</p><h2 id="改装散热"><a href="#改装散热" class="headerlink" title="改装散热"></a>改装散热</h2><p>泰安 S7012 虽然使用 1366 针，但散热器规格和标准的 1366 颇有区别，主要在于背后上了个不锈钢的富士康背板，正面留出的是四个 M3 螺丝槽位，而不是四个大洞，这大大方便了服务器风墙的安装，但 PC 散热器就装不上了。如果你使用的是有背板的散热器，很遗憾的是，怎么都是装不上的；再三尝试下，发现，扣具式的散热器，可以改装上去。具体方法是：</p><ol><li>准备一个 1366 扣具式的散热器</li><li>将提供的膨胀螺丝的下半部分剪掉，用以作为正常螺丝的垫片固定</li><li>使用 M3 螺丝拧入固定</li></ol><p><img src="https://l.ruby-china.org/photo/2017/34bb70e4258c71e71908eae46e31a583.png!large" alt=""></p><p>遇到的比较坑爹的问题是，楼下的五金店根本不懂 M3 是什么，经询问，发现这个不能去建材的五金店买，要去标准件店购买。不过后来在百安居的五金区域里找到了这个螺丝，拧入。</p><h2 id="安装系统"><a href="#安装系统" class="headerlink" title="安装系统"></a>安装系统</h2><p>由于主板过于古老，无法识别 USB-HDD 作为启动项。烧录 Windows 镜像到 USB 后，需要用 Force FDD 的模式，把 USB-HDD 转换成 USB-FDD 作为软盘读取，安装，成功。不过安装 Ubuntu 时就没那么幸运了，主要是，FDD 模式的 Ubuntu ISO 根本没法运行。最后在 Windows 下安装了 GRUB4DOS 作为引导，引导硬盘中的 ISO 安装。坑很多，特别是 GTX-970 驱动不识别，安装一点直接黑屏。需要加入启动参数 nomodeset，安装完毕后进入恢复模式选择安装专有驱动，开机，解决。</p><h2 id="成品和效果"><a href="#成品和效果" class="headerlink" title="成品和效果"></a>成品和效果</h2><p>机器弄完是这样的。噪音 12db，比起 70db 完全是可以睡觉的音量了。</p><p><img src="https://l.ruby-china.org/photo/2017/f4e39f04b995c095e0458c403734a1ab.jpg!large" alt=""></p><p><img src="https://l.ruby-china.org/photo/2017/41a2d8cfd20d780d8d805a5ce4d74c9a.jpg!large" alt=""></p><p>不服跑个分？</p><p><img src="https://l.ruby-china.org/photo/2017/7a4ee77fb37a26ff65b5535f2acf1ce6.png!large" alt=""></p><p>7zip 压缩和解压缩是 i7-5930K 的 1.2 倍性能，跑纯 CPU 的机器学习速度是 i7-4770K 的四倍。多核的优势被完全体现出来了，给一代志强又续了一秒。</p><p>不过这玩意游戏性能就捉急了，毕竟主频不高。不过由于显卡用了 GTX970，画质上还是不会有什么问题的。守望先锋 1080P 最高画质，60fps+ 流畅运行，但只能占用 14% 的 CPU，大约是完整吃掉 3 个逻辑核心的样子；</p><p><img src="https://l.ruby-china.org/photo/2017/60c5130673116193e45d080b40cf621f.jpg!large" alt=""></p><p>文明 6 2560x1080 最高画质，30 fps 到 60 fps 之间波动。不过文明 6 对多核有较好的优化，能占用 25% 左右的 CPU。</p><p><img src="https://l.ruby-china.org/photo/2017/68b6c0790b8eef45a93d262d42a88ef2.jpg!large" alt=""></p><p>在一些多核优化很差的游戏上就完全不忍直视了。可见这机器虽然物美价廉，但是你得熟悉你用在那里才能发挥它最大的价值。</p><h2 id="细节"><a href="#细节" class="headerlink" title="细节"></a>细节</h2><p>IBM 服务器使用的硬盘位螺丝极其复杂，标准件编号是 T6H，和传统梅花六角螺丝不同，中间还有个凸起，所以需要梅花六角中空心螺丝刀。这种螺丝刀一般出现在 T10 以上的大螺丝上，而 IBM 的硬盘位用的是 T6 规格的小螺丝。。。除了淘宝暂时没找到能买到这螺丝刀的地方。</p><p>服务器主板 I/O 口很少，没有板载声卡和板载 USB 3.0，我是通过 PCI-e 扩展获得的。</p><p>电源要求很复杂，因为双路需要 24+8+8 两个 CPU 电源供电，如果是全模组电源，应该是能搞的，支持这个的非模组电源很难找。</p><p>耗电略高，发热略高。至强一代有个特点就是待机功耗高，满负载其实还好。</p><p>仔细算了下，如果你没有走我很多弯路，大概能在 4000 左右搞下整台机器，而我花了 5000。（此价格包括一块 240GB 的 SSD 和一块 GTX970 的显卡，在家里翻出来的。。。如果买二手的话价格还能进一步压下去）</p><p>最后我有个问题：</p><h2 id="为什么散热器厂家都喜欢弄灯，弄得这服务器一整个光污染！"><a href="#为什么散热器厂家都喜欢弄灯，弄得这服务器一整个光污染！" class="headerlink" title="为什么散热器厂家都喜欢弄灯，弄得这服务器一整个光污染！"></a>为什么散热器厂家都喜欢弄灯，弄得这服务器一整个光污染！</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;引&quot;&gt;&lt;a href=&quot;#引&quot; class=&quot;headerlink&quot; title=&quot;引&quot;&gt;&lt;/a&gt;引&lt;/h2&gt;&lt;p&gt;这半个月开源项目拖更，啥事没干成，主要要感谢我的 MacBook Pro。大年二十五，风扇异响；大年二十六，更换风扇；大年二十七，更换风扇后无法通过
      
    
    </summary>
    
    
      <category term="生活" scheme="https://coderemixer.com/tags/%E7%94%9F%E6%B4%BB/"/>
    
  </entry>
  
  <entry>
    <title>关于 eval 是否 evil 的一些想法</title>
    <link href="https://coderemixer.com/2016/10/29/is-eval-evil/"/>
    <id>https://coderemixer.com/2016/10/29/is-eval-evil/</id>
    <published>2016-10-29T13:03:33.000Z</published>
    <updated>2018-10-21T13:06:55.189Z</updated>
    
    <content type="html"><![CDATA[<h2 id="引"><a href="#引" class="headerlink" title="引"></a>引</h2><p>对于大多数动态语言，都支持 <code>eval</code> 这个神奇的函数。这打他们太爷爷 Lisp 开始就支持这种方法。虽然写法（eg: <code>(eval &#39;(+ 1 2 3))</code> ）有稍许不同，但语义是一样的，就是说 <code>eval</code> 函数接受一个字符串类型作为参数，将其解析成语句并混合在当前作用域内运行。但我想大家也都听过这么一句话：</p><blockquote><p>eval is evil.</p></blockquote><p>但是 How evil is eval？那么既然 <code>eval</code> 如此罪恶，那么为什么它仍被那么多动态语言作为接口暴露呢？我们不妨来仔细探讨一下 <code>eval</code> 在使用中究竟会产生什么问题，在日常编程中究竟该不该使用 <code>eval</code>，如果要用，那么又该如何使用。</p><h2 id="字符串安全"><a href="#字符串安全" class="headerlink" title="字符串安全"></a>字符串安全</h2><p>说到 <code>eval</code> 第一个会被讨论的当然就是其安全性。比如说，我们现在来实现一个四则运算器：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">loop <span class="keyword">do</span></span><br><span class="line">  print(<span class="string">'Expression: '</span>)</span><br><span class="line">  puts(<span class="string">"result: <span class="subst">#&#123;eval gets.chomp&#125;</span>"</span>)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Expression: 1+1</span><br><span class="line">result: 2</span><br><span class="line">Expression: 2+2</span><br><span class="line">result: 4</span><br><span class="line">Expression: 3*4</span><br><span class="line">result: 12</span><br><span class="line">Expression: 4+(1*1)</span><br><span class="line">result: 6</span><br></pre></td></tr></table></figure><p>Awesome! 这段程序实现了全部四则运算的功能！只不过，这东西实现了 <strong>不止</strong> 四则运算的功能，事实上，它能处理任意 Ruby 语句，实际上这已经是一个 REPL（Read-Eval-Print Loop）了。我们可以运行一些「危险」的代码，比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Expression: exit</span><br><span class="line">Process exit with code 0</span><br></pre></td></tr></table></figure><p>更实际的应用是，在 JavaScript 中，如果你想要支持 IE7 的话，<code>JSON.parse()</code> 是不被支持的，除非你引入一个 JSON 解析库，最方便的写法就是 <code>eval(json)</code>，因为毕竟 JSON 也是合法的 JavaScript 语句，这样的方法安全性问题是显然的。</p><p>这样的问题不止 <code>eval</code> 有，事实上，所有和字符串打交道的事情，或多或少都有类似的问题。比如「SQL 注入」说到底也就是这么一回事。再比如你在 Ruby 代码中试图操作 <code>git</code> 命令的时候，如果你使用反引号，也可能遇到这样的问题。</p><p>不过我们来看下面这个例子：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># gems/rest-client-1.6.7/bin/restclient 摘自《Ruby 元编程(第二版)》第 142 页</span></span><br><span class="line">POSSIBLE_VERBS = [<span class="string">'get'</span>, <span class="string">'put'</span>, <span class="string">'post'</span>, <span class="string">'delete'</span>]</span><br><span class="line">POSSIBLE_VERBS.each <span class="keyword">do</span> <span class="params">|m|</span></span><br><span class="line">  eval <span class="string">&lt;&lt;-end_eval</span></span><br><span class="line"><span class="string">    def <span class="subst">#&#123;m&#125;</span>(path, *args, &amp;b)</span></span><br><span class="line"><span class="string">      r[path].<span class="subst">#&#123;m&#125;</span>(*args, &amp;b)</span></span><br><span class="line"><span class="string">     end</span></span><br><span class="line">  end_eval</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>在这个例子中，也使用了 <code>eval</code>，也在 <code>eval</code> 中拼接了字符串，存在字符串拼接的安全性问题吗？并没有。因为是从常量数组中读取的字符串，并不存在用户任意输入导致注入的问题。</p><p>但，我们反过来说，SQL 驱动自带的 <code>query</code> 函数都可能存在注入，难道我们就不用 SQL 了吗？并没有。事实上，注入问题是可以被解决的。如果我们做好对用户输入的 <strong>过滤</strong> 和 <strong>转义</strong> 同样也能解决。问题就在于，这么做的成本和 <code>eval</code> 带来的动态性好处，哪个更大的权衡问题。</p><h2 id="Lexer-amp-Parser"><a href="#Lexer-amp-Parser" class="headerlink" title="Lexer &amp; Parser"></a>Lexer &amp; Parser</h2><blockquote><p>本来想用中文写这个小标题，但感觉「词法分析器和语法分析器」实在这标题太长了</p></blockquote><p>学过一些《编译原理》都知道，无论是解释器还是编译器，拿到字符串无非就是</p><p><code>词法分析 -&gt; 语法分析 -&gt; 语义检查 -&gt; 生成语法树 -&gt; 代码优化 -&gt; 生成目标代码/执行</code></p><p>使用 <code>eval</code> 函数意味着，你的程序需要在运行时经历全部的这些步骤。通常来说即使是脚本语言，在你加载所有文件初始化运行的过程中。前期步骤通常都已经完成了，只剩下最后一步执行了。不过加入 <code>eval</code> 之后就不一样了。因为 <code>eval</code> 传入的是字符串，所以这意味着它需要对这一部分代码从词法分析开始重新走一遍。事实上，词法分析、语法分析、语义检查并不快。</p><p>比如说，我们对比下面的代码</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">GC.disable <span class="comment"># 禁用 GC 以避免后一段代码在运行过程中遭遇 GC 对其不公</span></span><br><span class="line"></span><br><span class="line">time = Time.now.to_f</span><br><span class="line"><span class="number">1000000</span>.times <span class="keyword">do</span></span><br><span class="line">  rand+rand</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">puts <span class="string">"Without eval: <span class="subst">#&#123;Time.now.to_f - time&#125;</span>"</span></span><br><span class="line"></span><br><span class="line">time = Time.now.to_f</span><br><span class="line"><span class="number">1000000</span>.times <span class="keyword">do</span></span><br><span class="line">  eval(<span class="string">'rand+rand'</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">puts <span class="string">"With eval: <span class="subst">#&#123;Time.now.to_f - time&#125;</span>"</span></span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Without eval: 0.11499691009521484</span><br><span class="line">With eval: 6.516125917434692</span><br></pre></td></tr></table></figure><p>慢了 55 倍。如果我们用 Ruby 自带的 profiler 对这两段代码跑一下的话，结果如下：</p><p>没有 eval：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"> %   cumulative   self              self     total</span><br><span class="line">time   seconds   seconds    calls  ms/call  ms/call  name</span><br><span class="line">62.15    17.03     17.03  1000000     0.02     0.02  nil#</span><br><span class="line">18.65    22.14      5.11        1  5110.00 27400.00  Integer#times</span><br><span class="line">12.77    25.64      3.50  2000000     0.00     0.00  Kernel#rand</span><br><span class="line"> 6.42    27.40      1.76  1000000     0.00     0.00  Float#+</span><br><span class="line"> 0.00    27.40      0.00        2     0.00     0.00  Time.now</span><br><span class="line"> 0.00    27.40      0.00        2     0.00     0.00  Fixnum#fdiv</span><br><span class="line"> 0.00    27.40      0.00        2     0.00     0.00  Numeric#quo</span><br><span class="line"> 0.00    27.40      0.00        2     0.00     0.00  Time#to_f</span><br><span class="line"> 0.00    27.40      0.00        1     0.00     0.00  Float#-</span><br><span class="line"> 0.00    27.40      0.00        1     0.00     0.00  Float#to_s</span><br><span class="line"> 0.00    27.40      0.00        2     0.00     0.00  IO#write</span><br><span class="line"> 0.00    27.40      0.00        1     0.00     0.00  IO#puts</span><br><span class="line"> 0.00    27.40      0.00        1     0.00     0.00  Kernel#puts</span><br><span class="line"> 0.00    27.40      0.00        1     0.00     0.00  TracePoint#enable</span><br><span class="line"> 0.00    27.40      0.00        1     0.00     0.00  TracePoint#disable</span><br><span class="line"> 0.00    27.40      0.00        2     0.00     0.00  IO#set_encoding</span><br><span class="line"> 0.00    27.40      0.00        2     0.00     0.00  Fixnum#+</span><br><span class="line"> 0.00    27.40      0.00        2     0.00     0.00  Time#initialize</span><br><span class="line"> 0.00    27.40      0.00        1     0.00 27400.00  #toplevel</span><br></pre></td></tr></table></figure><p>有 eval：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"> %   cumulative   self              self     total</span><br><span class="line">time   seconds   seconds    calls  ms/call  ms/call  name</span><br><span class="line">57.58    25.67     25.67  1000000     0.03     0.03  Kernel#eval</span><br><span class="line">16.02    32.81      7.14  1000000     0.01     0.04  nil#</span><br><span class="line">13.14    38.67      5.86        1  5860.00 44580.00  Integer#times</span><br><span class="line"> 9.17    42.76      4.09  2000000     0.00     0.00  Kernel#rand</span><br><span class="line"> 4.08    44.58      1.82  1000000     0.00     0.00  Float#+</span><br><span class="line"> 0.00    44.58      0.00        2     0.00     0.00  Fixnum#fdiv</span><br><span class="line"> 0.00    44.58      0.00        2     0.00     0.00  Numeric#quo</span><br><span class="line"> 0.00    44.58      0.00        2     0.00     0.00  Time#to_f</span><br><span class="line"> 0.00    44.58      0.00        1     0.00     0.00  Float#-</span><br><span class="line"> 0.00    44.58      0.00        1     0.00     0.00  Float#to_s</span><br><span class="line"> 0.00    44.58      0.00        2     0.00     0.00  IO#write</span><br><span class="line"> 0.00    44.58      0.00        1     0.00     0.00  IO#puts</span><br><span class="line"> 0.00    44.58      0.00        1     0.00     0.00  Kernel#puts</span><br><span class="line"> 0.00    44.58      0.00        1     0.00     0.00  TracePoint#enable</span><br><span class="line"> 0.00    44.58      0.00        1     0.00     0.00  TracePoint#disable</span><br><span class="line"> 0.00    44.58      0.00        2     0.00     0.00  IO#set_encoding</span><br><span class="line"> 0.00    44.58      0.00        2     0.00     0.00  Fixnum#+</span><br><span class="line"> 0.00    44.58      0.00        2     0.00     0.00  Time#initialize</span><br><span class="line"> 0.00    44.58      0.00        2     0.00     0.00  Time.now</span><br><span class="line"> 0.00    44.58      0.00        1     0.00 44580.00  #toplevel</span><br></pre></td></tr></table></figure><p>虽然在 profile 的掺和下，差距被缩小到了几倍之内，但也可以看出 <code>eval</code> 函数自行的语法解析有多么耗时。所以说，如果你的 <code>eval</code> 是一次性运行与加载时候的，比如上面那个 Rest Client 的例子里，问题并不大，但如果你的 <code>eval</code> 是被频繁调用的话，使用 <code>eval</code> 是非常影响性能的，不应该这么使用。</p><h2 id="静态分析与代码优化"><a href="#静态分析与代码优化" class="headerlink" title="静态分析与代码优化"></a>静态分析与代码优化</h2><p>在分析这个问题前，我们先来看两段代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">recursion_loop</span><span class="params">(<span class="keyword">int</span> count)</span></span>&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"Count: %d\n"</span>, count);</span><br><span class="line">  <span class="keyword">if</span> (count == <span class="number">0</span>) &#123;<span class="keyword">return</span>;&#125;</span><br><span class="line">  recursion_loop(count - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  recursion_loop(<span class="number">100000</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">recursion_loop</span><span class="params">(count)</span></span></span><br><span class="line">  puts(<span class="string">"Count: <span class="subst">#&#123;count&#125;</span>"</span>)</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">if</span> count == <span class="number">0</span></span><br><span class="line">  recursion_loop(count - <span class="number">1</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">recursion_loop(<span class="number">100000</span>)</span><br></pre></td></tr></table></figure><p>为什么第一段代码在 C++ 中可以正确运行（注：需要开启 -O2 编译选项），而第二段代码在 Ruby 下会报错。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">/Users/Delton/RubymineProjects/untitled/script4.rb:2:in `puts&apos;: stack level too deep (SystemStackError)</span><br><span class="line">from /Users/Delton/RubymineProjects/untitled/script4.rb:2:in `puts&apos;</span><br><span class="line">from /Users/Delton/RubymineProjects/untitled/script4.rb:2:in `recursion_loop&apos;</span><br><span class="line">from /Users/Delton/RubymineProjects/untitled/script4.rb:4:in `recursion_loop&apos;</span><br><span class="line">from /Users/Delton/RubymineProjects/untitled/script4.rb:4:in `recursion_loop&apos;</span><br><span class="line">from /Users/Delton/RubymineProjects/untitled/script4.rb:4:in `recursion_loop&apos;</span><br><span class="line">from /Users/Delton/RubymineProjects/untitled/script4.rb:4:in `recursion_loop&apos;</span><br><span class="line">from /Users/Delton/RubymineProjects/untitled/script4.rb:4:in `recursion_loop&apos;</span><br><span class="line">from /Users/Delton/RubymineProjects/untitled/script4.rb:4:in `recursion_loop&apos;</span><br><span class="line"> ... 10908 levels...</span><br><span class="line">from /Users/Delton/RubymineProjects/untitled/script4.rb:4:in `recursion_loop&apos;</span><br><span class="line">from /Users/Delton/RubymineProjects/untitled/script4.rb:7:in `&lt;top (required)&gt;&apos;</span><br><span class="line">from -e:1:in `load&apos;</span><br><span class="line">from -e:1:in `&lt;main&gt;&apos;</span><br></pre></td></tr></table></figure><p>报错的原因很显然，栈太深了。这个用递归实现的循环，需要建一个深度高达 100000 层深栈。一般的运行时都不会允许这么深的栈。诶？等一下，那为什么在 C++ 中这段代码可以正常运行呢？因为你的 C++ 编译器发现了这是一个「尾递归」，可以进行「尾递归优化」。尾递归可以被优化成一个非递归形式，自然就不需要那么深的栈了。</p><p>这就是 <code>词法分析 -&gt; 语法分析 -&gt; 语义检查 -&gt; 生成语法树 -&gt; 代码优化 -&gt; 生成目标代码/执行</code> 的倒数第二步。Ruby 中也有尾递归优化的选项，但默认不开启。开启的话方法也比较复杂，需要用到 <code>InstrctionSequence</code> 这个编译中间码的类，代码如下：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">RubyVM::InstructionSequence.compile_option = &#123;</span><br><span class="line">    <span class="symbol">:tailcall_optimization</span> =&gt; <span class="literal">true</span>,</span><br><span class="line">    <span class="symbol">:trace_instruction</span> =&gt; <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">source = <span class="string">&lt;&lt;-end_source</span></span><br><span class="line"><span class="string">  def recursion_loop(count)</span></span><br><span class="line"><span class="string">    puts("Count: \#&#123;count&#125;")</span></span><br><span class="line"><span class="string">    return if count == 0</span></span><br><span class="line"><span class="string">    recursion_loop(count - 1)</span></span><br><span class="line"><span class="string">  end</span></span><br><span class="line">  recursion_loop(<span class="number">100000</span>)</span><br><span class="line">end_source</span><br><span class="line"></span><br><span class="line">RubyVM::InstructionSequence.new(source).eval</span><br></pre></td></tr></table></figure><p><strong>注：事实上，这里开启的是尾调用优化，尾调用是尾递归的超集，开启尾调用优化不止会优化尾递归。</strong></p><p>但下面这段尾递归代码在即使开启优化的情况下，一样不会得到优化：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">recursion_loop</span><span class="params">(count)</span></span></span><br><span class="line">  puts(<span class="string">"Count: <span class="subst">#&#123;count&#125;</span>"</span>)</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">if</span> count == <span class="number">0</span></span><br><span class="line">  eval(<span class="string">'recursion_loop(count - 1)'</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">recursion_loop(<span class="number">100000</span>)</span><br></pre></td></tr></table></figure><p>这段代码把一个明明是尾递归的情况破坏成了非尾递归。因为编译器静态分析的时候根本不知道你 <code>eval</code> 里是什么东西。怎么可能给你优化？</p><p>虽然这个例子非常极端，但其实不止 <code>eval</code>，比如：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@next_recursion = proc &#123; <span class="params">|count|</span></span><br><span class="line">  recursion_loop(count - <span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">recursion_loop</span><span class="params">(count)</span></span></span><br><span class="line">  puts(<span class="string">"Count: <span class="subst">#&#123;count&#125;</span>"</span>)</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">if</span> count == <span class="number">0</span></span><br><span class="line">  @next_recursion.call(count)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">recursion_loop(<span class="number">100000</span>)</span><br></pre></td></tr></table></figure><p>大多数动态方法，都没有办法被静态分析，以提供足够的优化。以至于动态语言的代码优化也一直是一大难点。</p><h2 id="对-eval-魔法的思考"><a href="#对-eval-魔法的思考" class="headerlink" title="对 eval 魔法的思考"></a>对 eval 魔法的思考</h2><p>总结一下，谈一谈对「eval 魔法」的思考。<code>eval</code> 在元编程里也一直属于接近于禁术的那种类型。就好像核武器一样可怕。在用 <code>eval</code> 的时候要充分认识到可能带来的后果，才能对其进行使用。核国家的战争也不一定非要互相丢核武器，如果常规武器可以解决的，不必如此大动干戈。比如说前面 rest-client 的例子，也可以不用 <code>eval</code>：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">POSSIBLE_VERBS = [<span class="string">'get'</span>, <span class="string">'put'</span>, <span class="string">'post'</span>, <span class="string">'delete'</span>]</span><br><span class="line">POSSIBLE_VERBS.each <span class="keyword">do</span> <span class="params">|m|</span></span><br><span class="line">  define_method(m) <span class="keyword">do</span> <span class="params">|path, *args, &amp;b|</span></span><br><span class="line">    r[path].send(m, *args, &amp;b)</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>也可以解决这样的问题。不过 <code>define_method</code> 的方法，也不能给代码带来静态分析，而这又是在启动时一次性执行的代码，对性能的提升是微乎其微的。所以 rest-client 的 <code>eval</code> 实现并谈不上 evil。</p><p><code>eval</code> 被那么多语言至今沿用，其巨大的灵活性带来的便利是毋庸置疑的。只是说，使用 <code>eval</code> 包括使用任何元编程技巧的时候，都要充分考虑到这么做的可能造成的后果，以免莽撞瞎写，误伤自己。</p><h2 id="彩蛋"><a href="#彩蛋" class="headerlink" title="彩蛋"></a>彩蛋</h2><p>在 <a href="https://leetcode.com/problems/valid-parentheses/" target="_blank" rel="noopener">Leetcode #20</a> 括号匹配问题里，有一个可以用 JavaScript 的 <code>eval</code> 实现的魔法写法，非常有趣，大家可以看看开心开心。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;string&#125; s</span></span><br><span class="line"><span class="comment"> * @return &#123;boolean&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> isValid = <span class="function"><span class="keyword">function</span>(<span class="params">s</span>) </span>&#123;</span><br><span class="line">    s = s.replace(<span class="regexp">/\(/g</span>, <span class="string">'+('</span>);</span><br><span class="line">    s = s.replace(<span class="regexp">/\[/g</span>, <span class="string">'+['</span>);</span><br><span class="line">    s = s.replace(<span class="regexp">/\&#123;/g</span>, <span class="string">'+&#123;0:'</span>);</span><br><span class="line">    s = s.replace(<span class="regexp">/\)/g</span>, <span class="string">'+0)'</span>);</span><br><span class="line">    s = s.replace(<span class="regexp">/\]/g</span>, <span class="string">'+0]'</span>);</span><br><span class="line">    s = s.replace(<span class="regexp">/\&#125;/g</span>, <span class="string">'+0&#125;'</span>);</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="built_in">eval</span>(s);</span><br><span class="line">    &#125; <span class="keyword">catch</span>(err) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;引&quot;&gt;&lt;a href=&quot;#引&quot; class=&quot;headerlink&quot; title=&quot;引&quot;&gt;&lt;/a&gt;引&lt;/h2&gt;&lt;p&gt;对于大多数动态语言，都支持 &lt;code&gt;eval&lt;/code&gt; 这个神奇的函数。这打他们太爷爷 Lisp 开始就支持这种方法。虽然写法（eg: &lt;c
      
    
    </summary>
    
    
      <category term="编程" scheme="https://coderemixer.com/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="Ruby" scheme="https://coderemixer.com/tags/Ruby/"/>
    
  </entry>
  
  <entry>
    <title>从零开始 Ruby on PHP</title>
    <link href="https://coderemixer.com/2016/06/10/ruby-on-php/"/>
    <id>https://coderemixer.com/2016/06/10/ruby-on-php/</id>
    <published>2016-06-10T13:02:06.000Z</published>
    <updated>2018-10-21T13:02:40.964Z</updated>
    
    <content type="html"><![CDATA[<h2 id="关于什叶派-PHP-教徒"><a href="#关于什叶派-PHP-教徒" class="headerlink" title="关于什叶派 PHP 教徒"></a>关于什叶派 PHP 教徒</h2><p>PHP 早期的设计意图下整个语言都是模板驱动的。也就是说主要就是写个静态页面，在适当的需要动态的场合插入一些短小的 CGI 代码。然而逊尼派 PHP 教徒确认为 PHP 可以变成一门大而全的语言，摇身一变，强行又是 MVC 又是 MVC 的。各种框架层出不穷，抄完 Spring 又抄 Rails，甚至在一门模板驱动的语言中再搞一个模板渲染引擎。简直是异教。</p><h2 id="Ruby-on-PHP"><a href="#Ruby-on-PHP" class="headerlink" title="Ruby on PHP"></a>Ruby on PHP</h2><p>考虑到 Ruby 是一门强大的支持元编程的语言。很容易地我们能够将 Ruby 写成一门以模板来驱动的 CGI 语言。通过几行代码<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">require</span> <span class="string">'sinatra'</span></span><br><span class="line"></span><br><span class="line">get <span class="string">'/'</span> <span class="keyword">do</span></span><br><span class="line">  redirect <span class="string">'/index.php'</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">get /^\/(.*?)\.php$/ <span class="keyword">do</span> <span class="params">|c|</span></span><br><span class="line">  erb c.to_sym</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">post /^\/(.*?)\.php$/ <span class="keyword">do</span> <span class="params">|c|</span></span><br><span class="line">  erb c.to_sym</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></p><p>这样，只需要在 <code>./view</code> 下创建 erb 文件就可以当做 php 来写了，甚至连子目录都可以。<br>当然这样有一些小问题，比如，传进 erb 后连 request 来什么请求都不知道了。<br>所以我们可以稍作修改。<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">require</span> <span class="string">'sinatra'</span></span><br><span class="line"></span><br><span class="line">get <span class="string">'/'</span> <span class="keyword">do</span></span><br><span class="line">  redirect <span class="string">'/index.php'</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">get /^\/(.*?)\.php$/ <span class="keyword">do</span> <span class="params">|c|</span></span><br><span class="line">  erb c.to_sym, <span class="symbol">locals:</span> &#123;<span class="symbol">request:</span> request&#125;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">post /^\/(.*?)\.php$/ <span class="keyword">do</span> <span class="params">|c|</span></span><br><span class="line">  erb c.to_sym, <span class="symbol">locals:</span> &#123;<span class="symbol">request:</span> request&#125;</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></p><p>这样我们就有了一切 request 的数据了。自己在里面继续二次处理就是了。</p><h2 id="模板渲染"><a href="#模板渲染" class="headerlink" title="模板渲染"></a>模板渲染</h2><p>erb 模板是有趣的，但是像 PHP 那样一次性插十几行代码就不是很方便了。其实 erb 里也有这样的方法，只是 deprecated 而已。<br><figure class="highlight erb"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;%<span class="ruby"></span></span><br><span class="line"><span class="ruby">    puts <span class="string">'foo'</span></span></span><br><span class="line"><span class="ruby">    puts <span class="string">'bar'</span></span></span><br><span class="line"><span class="ruby">  </span>%&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure></p><p>然而问题来了，erb 里并不支持 echo 那样的命令。这样我们没法在一坨 Ruby 代码中输出某个东西到网页。<br>但是，Rails 里的 ActionView 不是支持 concat 吗？那么我们稍稍用点元编程的技巧，支持一下 echo 咯。<br>所以我们得到了最终代码<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># This is yet another PHP project</span></span><br><span class="line"><span class="keyword">require</span> <span class="string">'sinatra'</span></span><br><span class="line"><span class="keyword">require</span> <span class="string">'action_view'</span></span><br><span class="line"></span><br><span class="line">lookup_context = ActionView::LookupContext.new(<span class="string">'./views'</span>)</span><br><span class="line">lookup_context.cache = <span class="literal">false</span> <span class="keyword">if</span> development?</span><br><span class="line">view_context = ActionView::Base.new(lookup_context)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">module</span> <span class="title">ActionView::Helpers::TextHelper</span></span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">echo</span><span class="params">(string)</span></span></span><br><span class="line">    output_buffer &lt;&lt; string</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">get <span class="string">'/'</span> <span class="keyword">do</span></span><br><span class="line">  redirect <span class="string">'/index.php'</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">get /^\/(.*?)\.php$/ <span class="keyword">do</span> <span class="params">|c|</span></span><br><span class="line">  view_context.render(<span class="symbol">file:</span> c, <span class="symbol">locals:</span> &#123;<span class="symbol">request:</span> request&#125;)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">post /^\/(.*?)\.php$/ <span class="keyword">do</span> <span class="params">|c|</span></span><br><span class="line">  view_context.render(<span class="symbol">file:</span> c, <span class="symbol">locals:</span> &#123;<span class="symbol">request:</span> request&#125;)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></p><p>我们也能在 erb 里愉快地 echo 了<br><figure class="highlight erb"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">  &lt;body&gt;</span><br><span class="line">    Proudly Powered By </span><br><span class="line">    &lt;br&gt;</span><br><span class="line">  &lt;%<span class="ruby"></span></span><br><span class="line"><span class="ruby">    echo <span class="string">'PHP'</span></span></span><br><span class="line"><span class="ruby">  </span>%&gt;</span><br><span class="line">  &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></p><h2 id="副作用"><a href="#副作用" class="headerlink" title="副作用"></a>副作用</h2><p>根据上面的做法，我们把 Ruby 变成了一门什叶派 PHP 心目中 PHP 本该有的样子了。<br>顺便还带来了一点副作用那就是，Wappalyzer 把这个项目完全当做 PHP 项目了。<br>假如黑客试图用 PHP 的漏洞来攻击你，就等着看好戏吧。诶嘿~</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;关于什叶派-PHP-教徒&quot;&gt;&lt;a href=&quot;#关于什叶派-PHP-教徒&quot; class=&quot;headerlink&quot; title=&quot;关于什叶派 PHP 教徒&quot;&gt;&lt;/a&gt;关于什叶派 PHP 教徒&lt;/h2&gt;&lt;p&gt;PHP 早期的设计意图下整个语言都是模板驱动的。也就是说主要
      
    
    </summary>
    
    
      <category term="编程" scheme="https://coderemixer.com/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="Ruby" scheme="https://coderemixer.com/tags/Ruby/"/>
    
      <category term="PHP" scheme="https://coderemixer.com/tags/PHP/"/>
    
  </entry>
  
</feed>
